<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunMonkey</title>
  
  
  <link href="https://brraida.github.io/atom.xml" rel="self"/>
  
  <link href="https://brraida.github.io/"/>
  <updated>2022-07-22T00:17:29.620Z</updated>
  <id>https://brraida.github.io/</id>
  
  <author>
    <name>Brraida Hu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>格式化启动盘</title>
    <link href="https://brraida.github.io/posts/7e2d7be8/"/>
    <id>https://brraida.github.io/posts/7e2d7be8/</id>
    <published>2022-07-21T23:29:20.000Z</published>
    <updated>2022-07-22T00:17:29.620Z</updated>
    
    <content type="html"><![CDATA[<p>​最近把家里的老笔电换成了轻量的linux系统，但是在重新格式化启动盘出现了问题。参考了网上教程，完成了将启动盘恢复成普通的U盘。</p><span id="more"></span><ol><li>将U盘插入windows10的笔电下。</li><li><code>windows</code>+<code>R</code>，输入<code>cmd</code>，在按下<code>ctrl</code>+<code>shift</code>+<code>enter</code>打开管理员终端（防止权限不够）。</li><li>在终端输入<code>diskpart</code>。</li><li>在终端输入<code>list disk</code>，根据u盘的大小确定是哪个磁盘。</li><li>然后选择对应的磁盘，<code>select disk 2</code>。</li><li>输入<code>clean</code>（该命令将会清空磁盘，要确认选择正确的磁盘）。</li><li>在终端输入<code>create partition primary</code>。</li><li>在资源管理器中选中U盘，右键点击格式化，根据自己的需求选择<code>nfts</code>或是<code>fat32</code>，然后格式化。（可视化界面操作总是简单一些，并且还能选择快速格式化）</li></ol><p>参考:</p><blockquote><p><a href="https://blog.csdn.net/qq_40005528/article/details/107518431">(22条消息) U盘安装Linux系统后如何恢复正常容量_司文秦瘦的博客-CSDN博客</a></p><p>[2022指南：使用DiskPart和格式化軟體格式化硬碟 <a href="https://tw.easeus.com/partition-manager-tips/format-hard-drive-using-command-prompt.html#1">免費] - EaseUS</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​		最近把家里的老笔电换成了轻量的linux系统，但是在重新格式化启动盘出现了问题。参考了网上教程，完成了将启动盘恢复成普通的U盘。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="u盘" scheme="https://brraida.github.io/tags/u%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>以root用户进行登录</title>
    <link href="https://brraida.github.io/posts/71312d38/"/>
    <id>https://brraida.github.io/posts/71312d38/</id>
    <published>2022-06-08T14:37:22.000Z</published>
    <updated>2022-06-08T14:56:19.285Z</updated>
    
    <content type="html"><![CDATA[<p>​ssh以root用户远程登录。</p><span id="more"></span><ol><li>以普通用户登录</li><li>修改root密码（激活root用户）<code>sudo passwd root</code>；<code>sudo passwd --unlock root</code></li><li><code>sudo nano /etc/ssh/sshd_config</code></li><li>添加<code>PermitRootLogin yes</code>到最后一行</li><li>保存</li><li>重启<code>sudo reboot</code></li></ol><p>之后就可以使用root用户进行登录linux系统了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	ssh以root用户远程登录。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="ssh" scheme="https://brraida.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>smaba树莓派服务器</title>
    <link href="https://brraida.github.io/posts/6dc20ad6/"/>
    <id>https://brraida.github.io/posts/6dc20ad6/</id>
    <published>2022-06-07T07:07:31.000Z</published>
    <updated>2022-06-08T14:18:32.259Z</updated>
    
    <content type="html"><![CDATA[<p>​寻求方便和尝试smaba协议，所以建立一个smaba树莓派服务器。</p><span id="more"></span><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><ol><li><p>更新包和升级包</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre></div></figure></li><li><p>下载samba</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install samba samba-common-bin</code></pre></div></figure></li><li><p>创建一个文件夹用于共享文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir &#x2F;home&#x2F;pi&#x2F;shared</code></pre></div></figure></li><li><p>配置samba</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;samba&#x2F;smb.conf# 在文件最后添加以下内容[sharefile]path &#x3D; &#x2F;home&#x2F;pi&#x2F;sharedwriteable &#x3D; Yescreate mask&#x3D;0777directory mask&#x3D;0777public&#x3D;no</code></pre></div></figure></li></ol><p>​其中’[sharefile]’为之后访问地址的一部分，在树莓派中为<code>\\raspberrypi\sharefile</code>，raspberrypi是hostname，可以使用<code>hostname</code>命令查看。</p><p>​path就是自己定义的共享文件夹的路径地址了。</p><p>​writeable表示是否可写的意思。</p><p>​create mask和directory mask是给该路径下所有用户对文件、文件夹的操作，0777就是都拥有可写、可读、可执行的权限。</p><p>​public，若是设置no，那么就需要设置用户进行登录。</p><ol start="5"><li><p>创建用户</p><p>因为前面设置的public为no，所以创建一个用户。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo smbpasswd -a pi</code></pre></div></figure></li><li><p>启动配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl restart smbd</code></pre></div></figure></li></ol><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>windows下的连接：</p><ol><li>打开文件管理器。</li><li>点击顶部栏的’计算机’。如下图所示:</li></ol><p><img src="/img/article/sambaServer.assets/image-20220607154026280.png" alt="image-20220607154026280"></p><ol start="3"><li><p>点击映射网络驱动器，选择’映射网络驱动器’。</p></li><li><p>填入地址，如果和我配置一样就是填入<code>\\raspberrypi\sharefile</code>。如果失败了，那就先<code>hostname -I</code>得到树莓派的ip地址，然后将<code>raspberrypi</code>换成ip地址即可。</p></li><li><p>之后就是弹出窗口填用户名和密码。若是将public设置成yes，那么将能直接进入共享文件夹。</p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​在使用过程中，windows这边只用读和执行权限，但是之前配置有写的权限。若是你不考虑安全问题和深层次的原因，可以像我一样，直接给共享文件夹提权即可。</p><p><code>sudo chomo ugo+w shared</code></p><p>参考链接:</p><blockquote><p><a href="https://pimylifeup.com/raspberry-pi-samba/">How to Setup a Raspberry Pi Samba Server - Pi My Life Up</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	寻求方便和尝试smaba协议，所以建立一个smaba树莓派服务器。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="raspberry pi" scheme="https://brraida.github.io/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>利用nginx部署网站</title>
    <link href="https://brraida.github.io/posts/29a4812c/"/>
    <id>https://brraida.github.io/posts/29a4812c/</id>
    <published>2022-06-04T12:51:30.000Z</published>
    <updated>2022-06-08T13:48:46.572Z</updated>
    
    <content type="html"><![CDATA[<p>​利用nginx部署网站。</p><span id="more"></span><p>​防止nginx的默认配置干扰，我们可以先将默认配置去掉链接。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;etc&#x2F;nginx&#x2F;sites-enabled# 检查链接情况ls -ltr# 去掉默认配置unlink default</code></pre></div></figure><h2 id="一个页面"><a href="#一个页面" class="headerlink" title="一个页面"></a>一个页面</h2><p>​自定义页面的配置可以在<code>/nginx/conf.d/</code>目录下进行自定义。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;nginx&#x2F;conf.d&#x2F;mysite.conf# 配置内容server &#123;# 监听80端口listen 80 default_server;# 如果在var&#x2F;www&#x2F;mysite中存在以下形式的文件，则显示出来index index.html index.htm index.php;# 域名。在不使用域名的情况下，可以随便取，不影响server_name example.com;# 网站文件的根目录，mysite即为自己写的前端文件root &#x2F;var&#x2F;www&#x2F;mysite;&#125;# 测试配置文件sudo nginx -t# 测试成功后，热重载nginxsudo systemctl reload nginx#####以上配置完后，直接访问主机ip即可访问到对应的网站#####</code></pre></div></figure><h2 id="两个页面"><a href="#两个页面" class="headerlink" title="两个页面"></a>两个页面</h2><p>​倘若<code>mysite</code>文件夹下面有<code>index.html</code>和<code>subIndex.html</code>两个文件，并且两种为嵌套关系，即在index中按对应按钮，可以到达subIndex页面。</p><p>​一是可以在index页面中直接使用a标签，那么点击跳转后的网站的链接地址为<code>ip/subIndex.html</code>。</p><p>​而我学习到的视频的链接地址是<code>ip/sunIndex</code>，这种就需要进行nginx配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;# 监听80端口listen 80 default_server;# 如果在var&#x2F;www&#x2F;mysite中存在以下形式的文件，则显示出来index index.html index.htm index.php;# 域名。在不使用域名的情况下，可以随便取，不影响server_name example.com;# 网站文件的根目录，mysite即为自己写的前端文件root &#x2F;var&#x2F;www&#x2F;mysite;# 默认配置### 当任意请求过来时，可以查询根目录，下一级目录和各类html文件### 并且能返回400错误location &#x2F; &#123;try_files $uri $uri&#x2F; $uri.html &#x3D; 400;&#125;# 配置subIndex.htmllocation &#x2F;subIndex &#123;try_files $usi &#x2F;subIndex.html;&#125;&#125;</code></pre></div></figure><p>​其他正常页面都类似，比如关于我、标签、归档等。</p><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><p>​错误页面也可以自定义，有些许区别。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;# 监听80端口listen 80 default_server;# 如果在var&#x2F;www&#x2F;mysite中存在以下形式的文件，则显示出来index index.html index.htm index.php;# 域名。在不使用域名的情况下，可以随便取，不影响server_name example.com;# 网站文件的根目录，mysite即为自己写的前端文件root &#x2F;var&#x2F;www&#x2F;mysite;# 默认配置### 当任意请求过来时，可以查询根目录，下一级目录和各类html文件### 并且能返回400错误location &#x2F; &#123;try_files $uri $uri&#x2F; $uri.html &#x3D; 400;&#125;# 配置subIndex.htmllocation &#x2F;subIndex &#123;try_files $usi &#x2F;subIndex.html;&#125;error_page 400 404 &#x2F;400.html;location &#x3D; &#x2F;400.html &#123;internal;&#125;&#125;</code></pre></div></figure><p>参考：</p><blockquote><p><a href="https://www.youtube.com/watch?v=RzrIqzC9bQc&t=707s&ab_channel=Techbeast.org">(31) Part 1 - NGINX Web Server ( Installation &amp; Configuration ) - YouTube</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	利用nginx部署网站。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>树莓派镜像安装</title>
    <link href="https://brraida.github.io/posts/dd6b5a42/"/>
    <id>https://brraida.github.io/posts/dd6b5a42/</id>
    <published>2022-06-04T02:42:21.000Z</published>
    <updated>2022-06-08T15:01:13.290Z</updated>
    
    <content type="html"><![CDATA[<p>​现如今树莓派系统因为安全的原因，将pi这个默认用户删除了。需要在烧录时进行用户的创建与配置。在烧录过程中，还可以配置无线连接和ssh。这么一看，感觉确实省事了不少。</p><span id="more"></span><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>​sd卡的格式化工具可以使用<code>SD Card Formatter</code>。</p><p><img src="/img/article/raspberryPiOS.assets/image-20220604104837957.png" alt="image-20220604104837957"></p><p>整体样式如上图所示，选择需要格式化的sd卡，选择快速格式化，然后按格式化按钮即可。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​烧录工具使用<a href="https://www.raspberrypi.com/software/">raspberry pi imager</a>。</p><p>该工具提供在线下载镜像的功能，你也可以先将镜像下载到本地进行安装。</p><p><img src="/img/article/raspberryPiOS.assets/image-20220604105454906.png" alt="image-20220604105454906"></p><p>在齿轮处可以进行高级配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	现如今树莓派系统因为安全的原因，将pi这个默认用户删除了。需要在烧录时进行用户的创建与配置。在烧录过程中，还可以配置无线连接和ssh。这么一看，感觉确实省事了不少。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="raspberry pi" scheme="https://brraida.github.io/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>给用户sudo权限</title>
    <link href="https://brraida.github.io/posts/98c18f4f/"/>
    <id>https://brraida.github.io/posts/98c18f4f/</id>
    <published>2022-06-03T12:43:58.000Z</published>
    <updated>2022-06-08T15:11:24.489Z</updated>
    
    <content type="html"><![CDATA[<p>​给某一用户sudo权限。</p><span id="more"></span><p>在root下，给USER sudo的权限。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;sudoers.d&#x2F;USER# 填以下内容# 给用户不需要输入密码的sudo权限USER ALL&#x3D;(ALL) NOPASSWD:ALL# 给用户组不需要输入密码的sudo权限,只要加入该组的用户都拥有sudo的权限# %后面跟的是用户组%USER ALL&#x3D;(ALL) NOPASSWD:ALL</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	给某一用户sudo权限。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="sudo" scheme="https://brraida.github.io/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>typoraCrack</title>
    <link href="https://brraida.github.io/posts/6dd739dd/"/>
    <id>https://brraida.github.io/posts/6dd739dd/</id>
    <published>2022-06-03T11:49:47.000Z</published>
    <updated>2022-06-08T15:16:09.070Z</updated>
    
    <content type="html"><![CDATA[<p>​用习惯了typora和vue主题，但是一个学生党也没有闲钱去支持作者。所以选择crack。</p><span id="more"></span><blockquote><p><a href="https://www.nite07.com/typora/#%E6%88%AA%E5%9B%BE">Typora 1.2.5 学习版 | Nite07的小窝</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	用习惯了typora和vue主题，但是一个学生党也没有闲钱去支持作者。所以选择crack。&lt;/p&gt;</summary>
    
    
    
    
    <category term="crack" scheme="https://brraida.github.io/tags/crack/"/>
    
  </entry>
  
  <entry>
    <title>bbr</title>
    <link href="https://brraida.github.io/posts/5dd2df69/"/>
    <id>https://brraida.github.io/posts/5dd2df69/</id>
    <published>2022-06-01T13:43:15.000Z</published>
    <updated>2022-06-09T01:16:35.715Z</updated>
    
    <content type="html"><![CDATA[<p>    ‎BBR代表瓶颈带宽，RTT是一个拥塞控制系统。您可以在Linux桌面上启用TCP BBR以改善整体网上冲浪体验。默认情况下，Linux 使用 Reno 和 CUBIC 拥塞控制算法。‎</p><span id="more"></span><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>  先确认自己的系统是够适合开启bbr的前提条件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control</code></pre></div></figure><p>输出结果如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-20-13-debian:~# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control &#x3D; reno cubicroot@VM-20-13-debian:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control &#x3D; cubic</code></pre></div></figure><h2 id="开启bbr"><a href="#开启bbr" class="headerlink" title="开启bbr"></a>开启bbr</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vi &#x2F;etc&#x2F;sysctl.conf#在文件最后添加以下几行:net.core.default_qdisc&#x3D;fqnet.ipv4.tcp_congestion_control&#x3D;bbr#更新配置sysctl -p</code></pre></div></figure><p>参考链接:</p><blockquote><p><a href="https://wiki.crowncloud.net/?How_to_enable_BBR_on_Debian_10">CrownCloud Wiki - How To Enable BBR On Debian 10</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    ‎BBR代表瓶颈带宽，RTT是一个拥塞控制系统。您可以在Linux桌面上启用TCP BBR以改善整体网上冲浪体验。默认情况下，Linux 使用 Reno 和 CUBIC 拥塞控制算法。‎&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="debian" scheme="https://brraida.github.io/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>搭建云盘</title>
    <link href="https://brraida.github.io/posts/34664f8b/"/>
    <id>https://brraida.github.io/posts/34664f8b/</id>
    <published>2022-05-27T08:17:56.000Z</published>
    <updated>2022-06-09T01:20:28.416Z</updated>
    
    <content type="html"><![CDATA[<p>    看到大佬发的一个云盘，看起来很nice，心动就行动。其实搭建云盘还有一个目的就是为了收集材料方便。以前尝试在校园网在windows上搭建ftp服务器，在收集材料方面上确实方便了不少。但是因为中文字符，有些材料收集不上来。其实这个搭建得还是比较麻烦的，完全可以去找一些步骤更简单的云盘来搭建。</p><span id="more"></span><blockquote><p><a href="https://www.ioiox.com/archives/155.html/comment-page-1#comments">分享一个漂亮的云盘程序 vue-file-manager - 思有云 - IOIOX</a></p></blockquote><p>    说个前提，大佬发的是版本是1.8.3.13的。若是按官网教程安装，会出一堆php的deprecated。其原因是php版本太高了，安装php7.4即可。</p><hr><p>    以下是我经过测试搭建的教程，有些有些仍有问题，但是总体功能用起来没有问题。主要的是他能很好的在服务器上跑起来了：）</p><h2 id="安装nginx和php"><a href="#安装nginx和php" class="headerlink" title="安装nginx和php"></a>安装nginx和php</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update &amp;&amp; sudo apt upgrade -y# 安装nginxsudo apt install nginx -y# 检测nginx的状态，可以按ctrl+c退出systemctl status nginx# 安装必须的依赖sudo apt-get install ca-certificates apt-transport-https software-properties-common wget curl lsb-release -y# 导入并安装GPG密钥和存储库curl -sSL https:&#x2F;&#x2F;packages.sury.org&#x2F;php&#x2F;README.txt | sudo bash -x# 刷新APT存储库列表sudo apt update# 更新软件包sudo apt upgrade -y# 安装php7.4与其插件sudo apt install php7.4 php7.4-curl php7.4-common php7.4-cli php7.4-mysql php7.4-mbstring php7.4-fpm php7.4-xml php7.4-zip php7.4-bcmath  php7.4-sqlite3 php7.4-gd php7.4-intl php7.4-exif -y</code></pre></div></figure><h2 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install mariadb-server -y# 检查版本号mysql -V# 会让你设置数据库的密码和其他一些列进阶的操作。看自己的需求，默认选是即可。mysql_secure_installation# 登录数据库mysql -u root -p# 创建数据库CREATE DATABASE prod_vuefilemanager;# 授权，其中mysecret是数据库的密码GRANT ALL ON prod_vuefilemanager.* to &#39;prod_vuefilemanager&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mysecret&#39;;# 刷新权限FLUSH PRIVILEGES;# 退出quit;</code></pre></div></figure><p>    以上部分在到不会与程序运行相关，只有到程序配置时才会用到，所以在页面未出现时，只可能是nginx和php配置出现问题。与数据库这部分不会有相关。</p><h2 id="部署与配置"><a href="#部署与配置" class="headerlink" title="部署与配置"></a>部署与配置</h2><p>将云盘程序文件上传到<code>/var/www</code>文件夹中，并将文件重命名为<code>vueFileManager</code>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 给文件权限sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;storage &amp;&amp;sudo chmod -R 755 &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;storage &amp;&amp;sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;bootstrap&#x2F;cache &amp;&amp;sudo chmod -R 755 &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;bootstrap&#x2F;cache &amp;&amp;sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;storage &amp;&amp;sudo chmod -R 755 &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;.env### 以上给文件755权限后，在运行程序后，还是出现了权限不足的问题，### 因此给了一个777的权限sudo chmod -R ugo+rw &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;storagesudo chmod -R ugo+rw &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;.env### 刚开始以为是用户的问题，所以先改将文件的用户和用户组改回了root### 个人觉得不改也没关系，因为nginx的用户中就有www-datasudo chown -R root:root &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;storagesudo chown -R root:root &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;.env# 修改php配置nano &#x2F;etc&#x2F;php&#x2F;7.4&#x2F;fpm&#x2F;php.ini# 修改的部分memory_limit &#x3D; 256Mupload_max_filesize &#x3D; 128Mpost_max_size &#x3D; 128Mmax_file_uploads &#x3D; 50max_execution_time &#x3D; 3600# 服务重启service php7.4-fpm reload# 配置nginx，位置在&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。在http部分最底下添加以下 client_max_body_size 1024M;http &#123;    ...    client_max_body_size 1024M;&#125;# 重启nginxsystemctl reload nginx</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建vuefilemanager的nginx配置文件nano &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vuefilemanager.conf# 配置信息server &#123;    listen 80;    listen [::]:80;    # Log files for Debugging    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;laravel-access.log;    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;laravel-error.log; # Webroot Directory for Laravel project    root &#x2F;var&#x2F;www&#x2F;vueFileManager&#x2F;public;    index index.php index.html index.htm;    # Your Domain Name    server_name example.com;    location &#x2F; &#123;        try_files $uri $uri&#x2F; &#x2F;index.php?$query_string;    &#125;# PHP-FPM Configuration Nginx    location ~ \.php$ &#123;        try_files $uri &#x3D;404;        fastcgi_split_path_info ^(.+\.php)(&#x2F;.+)$;        fastcgi_pass unix:&#x2F;run&#x2F;php&#x2F;php7.4-fpm.sock;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    &#125;&#125;</code></pre></div></figure><p>    记得修改成自己的域名。如果没有域名，想要访问ip就访问到该云盘程序，那么就得把默认配置文件删除。用该配置文件进行代替即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 软连接ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vuefilemanager.conf &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;# 测试配置文件nginx -t# 重启配置nginxsystemctl restart nginx</code></pre></div></figure><h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">crontab -e# 添加以下信息* * * * *  cd &#x2F;var&#x2F;www&#x2F;vueFileManager&amp;&amp; php artisan schedule:run &gt;&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</code></pre></div></figure><hr><p>后面就会有指导程序界面了，可能会需要用到以下一些资料与命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在数据库终端中输入以下命令，获取数据库的端口号SHOW GLOBAL VARIABLES LIKE &#39;PORT&#39;;# 在数据库终端中输入以下命令，获得数据库的用户和hostselect user, host from mysql.user;</code></pre></div></figure><p>邮箱填写方式：</p><blockquote><p><a href="https://stackoverflow.com/questions/32515245/how-to-to-send-mail-using-gmail-in-laravel">php - How to to send mail using gmail in Laravel? - Stack Overflow</a></p><p><a href="https://service.mail.qq.com/cgi-bin/help?id=28&no=167&subtype=1">QQ邮箱的POP3与SMTP服务器是什么？_QQ邮箱帮助中心</a></p></blockquote><p>若是想切换php的版本:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">update-alternatives --config php</code></pre></div></figure><p>查看php7.4-fpm的状态:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status php7.5-fpm</code></pre></div></figure><p>查看larval版本:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 该命令进入程序文件件中php artisan --version</code></pre></div></figure><p>参考链接：</p><blockquote><p><a href="https://medium.com/vuefilemanager/how-to-set-up-vuefilemanager-laravel-application-on-vps-with-debian-10-64676a3ff4d7">How to Set Up VueFileManager v2 on VPS with Debian 10 – 2022 Update | by Peter Papp | vuefilemanager | Medium</a></p><p><a href="https://blog.51cto.com/u_15077541/3861508">MySQL数据库用户管理以及数据库用户授权_mb5ff590f157b0e的技术博客_51CTO博客</a></p><p><a href="https://www.digitalocean.com/community/questions/conflicting-server-name-mydomain-com-on-0-0-0-0-80-ignored-nginx-error-log-ubuntu-20-04">Conflicting server name “mydomain.com” on 0.0.0.0:80, ignored NGINX error log Ubuntu 20.04 | DigitalOcean</a></p><p><a href="https://www.linuxcapable.com/how-to-install-nginx-with-lets-encrypt-tls-ssl-on-debian-11-bullseye/#Secure_Nginx_with_Lets_Encrypt_SSL_Free_Certificate">How to Install Nginx with Let’s Encrypt TLS&#x2F;SSL on Debian 11 Bullseye - LinuxCapable</a></p><p><a href="https://stackoverflow.com/questions/70245146/php-deprecated-issue-when-running-artisan-command">composer php - PHP Deprecated issue when running artisan command - Stack Overflow</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    看到大佬发的一个云盘，看起来很nice，心动就行动。其实搭建云盘还有一个目的就是为了收集材料方便。以前尝试在校园网在windows上搭建ftp服务器，在收集材料方面上确实方便了不少。但是因为中文字符，有些材料收集不上来。其实这个搭建得还是比较麻烦的，完全可以去找一些步骤更简单的云盘来搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="self-hosted" scheme="https://brraida.github.io/categories/self-hosted/"/>
    
    
    <category term="pan" scheme="https://brraida.github.io/tags/pan/"/>
    
  </entry>
  
  <entry>
    <title>便捷删除host的文件</title>
    <link href="https://brraida.github.io/posts/efb2d1d2/"/>
    <id>https://brraida.github.io/posts/efb2d1d2/</id>
    <published>2022-05-27T04:50:00.000Z</published>
    <updated>2022-06-09T01:25:28.057Z</updated>
    
    <content type="html"><![CDATA[<p>    清除冲突的hosts文件。</p><span id="more"></span><p>    最近将树莓派的系统给换了一个新的，但是路由器这边记住了树莓派的mac地址，所以在重新进行ssh的时候，报错了。</p><p><img src="/img/article/%E4%BE%BF%E6%8D%B7%E5%88%A0%E9%99%A4host%E7%9A%84%E6%96%87%E4%BB%B6/%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png"></p><p>    一种方法就是去该目录删除host文件，但若是有其他的hosts记录，那么会一并删除。也可以进入该文件，找到对应记录进行删除，但是也很麻烦。</p><p>    所以推荐以下这个方法，在登录失败时，会进行上图提醒。那么只要执行：<code>ssh-keygen -R HOSTNAME</code>,上图的就是<code>ssh-keygen -R 192.168.123.55</code>。</p><p>参考链接:</p><blockquote><p><a href="https://www.rit.edu/researchcomputing/instructions/Clearing-the-known_hosts-SSH-File">Clearing the known_hosts SSH File | Research Computing | RIT</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    清除冲突的hosts文件。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="ssh" scheme="https://brraida.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>反弹Shell</title>
    <link href="https://brraida.github.io/posts/eea02d15/"/>
    <id>https://brraida.github.io/posts/eea02d15/</id>
    <published>2022-05-20T03:08:24.000Z</published>
    <updated>2022-06-09T01:30:20.086Z</updated>
    
    <content type="html"><![CDATA[<p>    你有一台公网ip服务器，而想要利用服务器远程登录某一内网的机器。虽然可以利用内网穿透来实现这一目标，但是绝大部分的内网是dhcp服务器，也就是说内网中的机器的ip的是动态的。这就可能需要修改内网穿透的一些相关配置了。</p><p>    而反弹shell是反过来的，公网服务器开一个监听端口，内网的机器连上该端口。那么在公网服务器中即可远程登录内网的机器。</p><span id="more"></span><p><strong>例子</strong></p><p>    公网服务器A，内网机器B</p><p>在A上打开监听端口：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nc -lvp 22222</code></pre></div></figure><p>在B上连接A</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;服务器A的ip&#x2F;A的监听端口 0&gt;&amp;1</code></pre></div></figure><p>    然后就可以在A中控制B了。</p><p>很多详细信息可以参考</p><blockquote><p><a href="https://cuiqingcai.com/36056.html">什么是反弹 Shell？ | 静觅 (cuiqingcai.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    你有一台公网ip服务器，而想要利用服务器远程登录某一内网的机器。虽然可以利用内网穿透来实现这一目标，但是绝大部分的内网是dhcp服务器，也就是说内网中的机器的ip的是动态的。这就可能需要修改内网穿透的一些相关配置了。&lt;/p&gt;
&lt;p&gt;    而反弹shell是反过来的，公网服务器开一个监听端口，内网的机器连上该端口。那么在公网服务器中即可远程登录内网的机器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="shell" scheme="https://brraida.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>自动登录校园网</title>
    <link href="https://brraida.github.io/posts/bb01f2a2/"/>
    <id>https://brraida.github.io/posts/bb01f2a2/</id>
    <published>2022-05-06T03:40:34.000Z</published>
    <updated>2022-06-09T01:35:18.927Z</updated>
    
    <content type="html"><![CDATA[<p>    优化自动登录校园网的代码。</p><span id="more"></span><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>    学校不是通宵供电，会断电，这导致每天早上都需要进行路由器的账号登录。为解决这个问题，写一个shell脚本。</p><p>    完成自动登录这个目标，可以看出是两块，一块是自动，一块是登录。路由器刷的是老毛子固件，该固件有自己的后台管理界面，在管理界面加自动化就行（更一般的方法，可以考虑linux中的crontab）；登录这边将使用<strong>curl</strong>。</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>首先是用edge直接获取curl（bash）的代码。   </p><ol><li>按f12，在<strong>Network</strong>中勾选Preserve log，然后按下记录按钮。</li></ol><p><img src="/img/article/autoLoginCampusNetwork/2022-05-06-14-27-16-image.png"></p><ol start="2"><li><p>输入账号密码，获得Get请求。</p><p><img src="/img/article/autoLoginCampusNetwork/2022-05-06-14-29-21-image.png"></p><p><img src="/img/article/autoLoginCampusNetwork/2022-05-06-14-34-23-image.png"></p></li><li><p>在上图红线处右键，选<strong>copy</strong>，在选择**copy as cURL(bash)**。</p></li></ol><p>其次编写shell script，如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# Program:#            auto login school nerwork by writing shell scripts in router# History:# 2022&#x2F;05&#x2F;06        brraida        First release#PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin#export PATHmaxTry&#x3D;3        # 尝试最大次数currentTry&#x3D;0    # 目前正在尝试的次数httpUrl&#x3D;&#39;&#39;      # get请求的urlresponse&#x3D;404    # 初始化最开始的响应为404# 获取url的状态码function getStatus()&#123;    response&#x3D;$(curl -o &#x2F;dev&#x2F;null -s -w &quot;%&#123;http_code&#125;\n&quot; $httpUrl)&#125;# 当目前的尝试次数为最大次数时，则停止尝试，并且在日志中打印失败信息while [ $currentTry -ne $maxTry ]do    getStatus;    # 200状态码为请求成功状态码，若为此，则成功跳出    if [ $response -eq 200 ]; then        logger &quot;connection success&quot;        break    else        currentTry&#x3D;$(($currentTry+1))        logger &quot;retry $currentTry&quot;    fidoneif [ $currentTry -eq $maxTry ]; then    logger &quot;try max, fail&quot;fi</code></pre></div></figure><p>    其中<strong>httpUrl</strong>填写的内容为在第一步中获取的get请求的url，可以将其他curl参数抛弃（如-H）。</p><p>    日志文件在<code>/tmp/syslog.log</code></p><p>    将该文件保存在<code>/etc/storage/</code>目录下</p><hr><p>最后在后端界面加上该文件地址即可。</p><p>【自定义设置】–&gt;【脚本】–&gt;【在路由器启动后运行】在最后添加：</p><p><code>/etc/storage/autoLoginCompusNetwork</code></p><p>    其实以上shell脚本也可以直接写在这里，就是不是更适用的选择。</p><p>参考链接：</p><blockquote><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://www.right.com.cn/forum/thread-256244-1-1.html">老毛子固件的完整日志文件在什么位置？因为只能看到最近的日志文件 、-恩山无线论坛 (right.com.cn)</a></p><p><a href="https://stackoverflow.com/questions/38906626/curl-to-return-http-status-code-along-with-the-response">shell - Curl to return http status code along with the response - Stack Overflow</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    优化自动登录校园网的代码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="campusNetwork" scheme="https://brraida.github.io/tags/campusNetwork/"/>
    
  </entry>
  
  <entry>
    <title>学习与记录bash</title>
    <link href="https://brraida.github.io/posts/bbd13e89/"/>
    <id>https://brraida.github.io/posts/bbd13e89/</id>
    <published>2022-05-04T02:22:20.000Z</published>
    <updated>2022-06-09T01:36:15.858Z</updated>
    
    <content type="html"><![CDATA[<p>    shell翻译为壳程序，只要能操作应用程序的软件都能够成为壳程序。壳程序的功能只是提供用户操作系统的一个界面。bash（Bourne Again Shell）就是一个壳程序。</p><p>    shell有很多，比如C shell、bash、sh。</p><p>    在&#x2F;etc&#x2F;shells可查看。</p><span id="more"></span><p>在bash命令行中操作时，有时需要快速删除命令。以下为终端下的快捷键。</p><table><thead><tr><th align="center">组合键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">ctrl+u</td><td align="center">从光标处向前删除命令行串</td></tr><tr><td align="center">ctrl+k</td><td align="center">从光标处向后删除命令行串</td></tr><tr><td align="center">ctrl+a</td><td align="center">将光标移动到最前面</td></tr><tr><td align="center">ctrl+e</td><td align="center">将光标移动到最后面</td></tr></tbody></table><h2 id="变量用法"><a href="#变量用法" class="headerlink" title="变量用法"></a>变量用法</h2><p>设置工作目录，比如我经常要进某个目录（如&#x2F;home&#x2F;pi&#x2F;appdaemon&#x2F;conf&#x2F;apps&#x2F;)写东西。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">work&#x3D;&quot;&#x2F;home&#x2F;pi&#x2F;appdeamon&#x2F;conf&#x2F;apps&#x2F;&quot;#进入工作目录指令为cd $work#取消该变量unset work</code></pre></div></figure><hr><p>查看环境变量：<code>env</code>、<code>export</code></p><p>查看所有变量：<code>set</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># $为这个shell的进程号，即PID# ?表示关于上一个执行命令的返回值，最命令无误，返回值为0# 查看返回值，并且可以根据返回值来查找原因echo $?</code></pre></div></figure><p><a href="https://lvii.github.io/soft/2019-01-16-curl-get-error-return-code-with-slient-mode/">使用 curl -sS 请求失败时返回失败的返回值 | 小马过河 (lvii.github.io)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;    shell翻译为壳程序，只要能操作应用程序的软件都能够成为壳程序。壳程序的功能只是提供用户操作系统的一个界面。bash（Bourne Again Shell）就是一个壳程序。&lt;/p&gt;
&lt;p&gt;    shell有很多，比如C shell、bash、sh。&lt;/p&gt;
&lt;p&gt;    在&amp;#x2F;etc&amp;#x2F;shells可查看。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="bash" scheme="https://brraida.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>rpiCamera</title>
    <link href="https://brraida.github.io/posts/7502dcb/"/>
    <id>https://brraida.github.io/posts/7502dcb/</id>
    <published>2022-04-22T01:39:25.000Z</published>
    <updated>2022-06-09T01:42:22.257Z</updated>
    
    <content type="html"><![CDATA[<p>    使用树莓派的CSI针脚进行对树莓派摄像头的控制。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li><p>树莓派是3b</p></li><li><p>用的操作系统是raspbian os（bulleye）</p></li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>    使用python对树莓派摄像头进行控制，比如拍照摄影等等操作。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>    因为[官方操作系统公告](<a href="https://www.raspberrypi.com/news/bullseye-camera-system/">Bullseye camera system - Raspberry Pi</a>)（bulleye版本）中说，更新了树莓派摄像头的部分，因此使用不了<strong>picamera库</strong>，即不能利用python对摄像头进行一些操作。所以以“曲线救国”方式，利用<strong>OpenCV库</strong>进行摄像头的操作。（有点牛刀小试的感觉，不过能很好的满足我小小的需求）</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>将摄像头连接好树莓派。</p></li><li><p>在树莓派终端输入<code>sudo raspi-config</code>，选择<code>interfaces</code>，打开<code>Legacy camera</code></p></li><li><p>检查在<code>/dev/</code>下是否存在<code>video0</code></p></li><li><p>输入允许树莓派进行使用树莓派摄像头模块指令：</p><p><code>modprobe bcm2835-v4l2</code></p></li><li><p>将树莓派模块<code>bcm2835-v4l2</code>加入<code>/etc/modules</code>中</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;modules# 在该文件下填入即可，该目的是配置开机自动加载bcm2835-v4l2</code></pre></div></figure></li><li><p>重启</p></li></ol><p>以上我就可以找到video0了。因为开启了<code>Legacy camera1</code>，将不能使用树莓派官方指令来进行操作摄像头了，因为没有那个需求，也没有进行下一步的深究。</p><p>以上的操作也可以摘下sd卡，在sd中操作（我没有操作过）</p><p>修改<code>/boot/config.txt</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">start_x&#x3D;1             # essentialgpu_mem&#x3D;128           # at least, or maybe more if you wishdisable_camera_led&#x3D;1  # optional, if you don&#39;t want the led to glow</code></pre></div></figure><p>参考链接：</p><blockquote><p><a href="https://segmentfault.com/a/1190000040009665">[树莓派]aarch64系统使用CSI摄像头 - SegmentFault 思否</a></p><p><a href="https://www.raspberrypi.com/news/bullseye-camera-system/">Bullseye camera system - Raspberry Pi</a></p><p><a href="https://stackoverflow.com/questions/27777547/missing-libmmal-so-with-picamera-library">python - Missing libmmal.so with picamera library - Stack Overflow</a></p><p><a href="https://www.reddit.com/r/raspberry_pi/comments/r91l2d/dont_upgrade_to_bullseye_if_youre_using_the/">(2) Don’t upgrade to Bullseye if you’re using the PiCamera with Python! : raspberry_pi (reddit.com)</a></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="安装opencv2"><a href="#安装opencv2" class="headerlink" title="安装opencv2"></a>安装opencv2</h4><p> <code>sudo apt install python3-opencv -y</code></p><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2 as cvimport timeimport osfrom datetime import date&#39;&#39;&#39;    this function complte:    - take one picture&#39;&#39;&#39;def TakeSendPic():    # get camera device    cap &#x3D; cv.VideoCapture(&#39;&#x2F;dev&#x2F;video0&#39;, cv.CAP_V4L)    # get camera fps    fps &#x3D; cap.get(cv.CAP_PROP_FPS)    # set image resolution    cap.set(cv.CAP_PROP_FRAME_WIDTH, 800)    cap.set(cv.CAP_PROP_FRAME_HEIGHT, 400)    # initialize video argument    # argument: save file location , edcode , fps , image resolution    videoLocation &#x3D; &#39;&#x2F;home&#x2F;pi&#x2F;Videos&#x2F;video.avi&#39;    video &#x3D; cv.VideoWriter(videoLocation, cv.VideoWriter_fourcc(&#39;I&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;), fps, (800, 400))    # take picture    currentTime &#x3D; int(round(time.time()*1000))    dateTime &#x3D; time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime(currentTime&#x2F;1000))    ret, frame &#x3D; cap.read()    if ret:        imgName &#x3D; &#39;&#123;&#125;&#39;.format(dateTime)        imgPath &#x3D; &#39;&#x2F;home&#x2F;pi&#x2F;Pictures&#x2F;image-&#39; + imgName + &#39;.jpg&#39;        cv.imwrite(imgPath, frame) # make every frame to be picture        video.write(frame) # video recording    # release camera    cap.release()    # delete camera    if os.path.exists(videoLocation):        os.remove(videoLocation)    else:        print(&quot;The file does not exit&quot;)</code></pre></div></figure><p>参考链接：</p><blockquote><p><a href="https://segmentfault.com/a/1190000040009665">[树莓派]aarch64系统使用CSI摄像头 - SegmentFault 思否</a></p><p><a href="https://blog.csdn.net/weixin_43869605/article/details/119826406">OpenCV中cv2.VideoWriter_fourcc()函数和cv2.VideoWriter()函数的结合使用_浅蓝的风的博客-CSDN博客_cv2.videowriter_fourcc</a></p><p><a href="https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html">OpenCV: Getting Started with Videos</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;    使用树莓派的CSI针脚进行对树莓派摄像头的控制。&lt;/p&gt;</summary>
    
    
    
    <category term="raspberry pi" scheme="https://brraida.github.io/categories/raspberry-pi/"/>
    
    
    <category term="raspberry pi camera" scheme="https://brraida.github.io/tags/raspberry-pi-camera/"/>
    
  </entry>
  
  <entry>
    <title>修改vscode字体</title>
    <link href="https://brraida.github.io/posts/69558f85/"/>
    <id>https://brraida.github.io/posts/69558f85/</id>
    <published>2022-03-29T03:33:07.000Z</published>
    <updated>2022-06-09T01:56:12.806Z</updated>
    
    <content type="html"><![CDATA[<p>    ‘0’、‘ o’、‘ O’；‘l’、‘|’、‘1’有时候总是分不清楚（虽然编译器会提示）。最近看到一个感觉不错的字体，乘机修改一下vscode的字体。</p><span id="more"></span><blockquote><p><a href="https://github.com/JetBrains/JetBrainsMono">JetBrains&#x2F;JetBrainsMono: JetBrains Mono – the free and open-source typeface for developers (github.com)</a></p><p><a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono: A free and open source typeface for developers | JetBrains: Developer Tools for Professionals and Teams</a></p></blockquote><p>    上面链接有详细的修改方法。我就讲一下自己电脑上设备的修改。</p><p>   环境：windows10且装了chocolatey</p><p>    步骤：</p><ol><li><p>在桌面打开Powersell:<code>shift + 鼠标右键</code></p></li><li><p>提权:<code>start-process PowerShell -verb runas</code></p></li><li><p>下载字体:<code>choco install -y jetbrainsmono</code></p></li><li><p>在vscode上配置font:</p><ul><li><p><code>ctrl+,</code>或者在左下角齿轮处打开设置</p></li><li><p>在搜索配置栏中输入:<code>font family</code></p></li><li><p>将有<strong>Font Family</strong>出现过那些栏都填入<code>jetBrains Mono</code>(怕出事先把原先的配置先记录下来，我这样操作是没有出现问题过)</p></li></ul></li><li><p>如果需要连体的话，需要配置以下配置：（连体的效果图在<a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a>这个链接可以看到）</p><ul><li><p>在搜索栏输入<code>font ligatures</code></p></li><li><p>点击<strong>在settings.json中编辑</strong></p></li><li><p>在第二行键入<code>&quot;editor.fontLigatures&quot;: true,</code>（其实只要在花括号里随意位置都可以，不要忘记逗号，虽然编译器会提醒)</p></li></ul></li><li><p>重启：</p><ul><li><p><code>ctrl+shift+p</code></p></li><li><p>输入<code>reload Window</code>，回车即可</p><p>关闭重启也可以达到重启的效果。</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;    ‘0’、‘ o’、‘ O’；‘l’、‘|’、‘1’有时候总是分不清楚（虽然编译器会提示）。最近看到一个感觉不错的字体，乘机修改一下vscode的字体。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    <category term="vscode" scheme="https://brraida.github.io/categories/windows/vscode/"/>
    
    
    <category term="font" scheme="https://brraida.github.io/tags/font/"/>
    
  </entry>
  
  <entry>
    <title>vscode</title>
    <link href="https://brraida.github.io/posts/88bb77ff/"/>
    <id>https://brraida.github.io/posts/88bb77ff/</id>
    <published>2022-03-27T13:27:03.000Z</published>
    <updated>2022-07-21T23:32:58.706Z</updated>
    
    <content type="html"><![CDATA[<p>    记录与vscode相关的东西。</p><span id="more"></span><h1 id="Git相关的插件"><a href="#Git相关的插件" class="headerlink" title="Git相关的插件"></a>Git相关的插件</h1><p>    <strong>GitLens</strong>：除了它本身现在所讲的之外，还可以将rebase命令进行可视化。</p><blockquote><p>使用rebase的参考链接：<a href="https://youtu.be/FQP2Af63NAA">[ 前端新手技能樹] #4-3 Learn Git Branching - 調整提交順序 - YouTube</a></p></blockquote><p>    若要将rebase命令进行可视化，则需要进行一下配置：</p><ol><li><p>在vscode里面输入 ctrl+&#96; ,打开终端</p></li><li><p>在终端键入<code>code --help</code>，确认是否安装了code</p></li><li><p>如果是则键入<code>git config --global core.editor &quot;code --wait&quot;</code></p></li></ol><blockquote><p><a href="https://stackoverflow.com/questions/30024353/how-to-use-visual-studio-code-as-default-editor-for-git">How to use Visual Studio Code as default editor for git? - Stack Overflow</a></p></blockquote><p><strong>Git Graph</strong>:查看git的流程线，可以配合Gitlens做一些可视化操作。</p><h1 id="快捷"><a href="#快捷" class="headerlink" title="快捷"></a>快捷</h1><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">输入:#section$*5输出的结果是:  &lt;div id&#x3D;&quot;section1&quot;&gt;&lt;&#x2F;div&gt;  &lt;div id&#x3D;&quot;section2&quot;&gt;&lt;&#x2F;div&gt;  &lt;div id&#x3D;&quot;section3&quot;&gt;&lt;&#x2F;div&gt;  &lt;div id&#x3D;&quot;section4&quot;&gt;&lt;&#x2F;div&gt;  &lt;div id&#x3D;&quot;section5&quot;&gt;&lt;&#x2F;div&gt;输入:span&#123;data$&#125;*2输出:  &lt;span&gt;data1&lt;&#x2F;span&gt;&lt;span&gt;data2&lt;&#x2F;span&gt;</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;    记录与vscode相关的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    <category term="vscode" scheme="https://brraida.github.io/categories/windows/vscode/"/>
    
    
    <category term="plugins" scheme="https://brraida.github.io/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>chocolatey相关指南</title>
    <link href="https://brraida.github.io/posts/a3de2b30/"/>
    <id>https://brraida.github.io/posts/a3de2b30/</id>
    <published>2022-03-14T02:23:35.000Z</published>
    <updated>2022-06-09T02:10:26.109Z</updated>
    
    <content type="html"><![CDATA[<p>​chocolatey是windows下的一个包管理器，久闻大名。这玩意主要是方便，安装好东西后，不用再进一步的配置环境变量。</p><span id="more"></span><blockquote><p>官网：<a href="https://chocolatey.org/">Chocolatey Software | Chocolatey - The package manager for Windows</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>打开powershell</p><p>在桌面按<strong>shift+鼠标右键</strong>，然后点击<strong>在此处打开powershell窗口</strong>。</p></li><li><p>提权，以管理员运行</p><p><code>start-process PowerShell -verb runas</code></p></li><li><p>安装chocolatey</p><p><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://community.chocolatey.org/install.ps1&#39;))</code></p></li></ol><blockquote><p><a href="https://chocolatey.org/install">Chocolatey Software | Installing Chocolatey</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="修改安装默认目录"><a href="#修改安装默认目录" class="headerlink" title="修改安装默认目录"></a>修改安装默认目录</h3><p>​    按自己需求是否要修改安装的默认目录（choco的安装默认目录是C:\Program Files）。</p><p>​    默认的安装路径在注册表里进行修改。</p><ol><li><p><code>win</code>+<code>r</code>，输入<code>regedit</code></p></li><li><p>展开注册表到下面的分支[HKEY＿LOCAL＿MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion]，在右侧窗口中找到名为“ProgramFilesDir”的字符串，双击把数值“C:\Program Files”修改为<code>你想要的路径</code>，确定退出后即可。</p></li></ol><blockquote><p><a href="https://www.jianshu.com/p/abaa0e8c261f">Windows下的包管理器 Chocolatey 的使用 - 简书 (jianshu.com)</a></p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure><div class="code-wrapper"><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">choco search &lt;keyword&gt;    搜索软件choco install &lt;package1 package2 package3...&gt;  安装软件choco install &lt;packagename&gt;  -version *** 安装指定版本choco  uninstall &lt;packagename&gt; 卸载软件choco version &lt;packagename&gt;  查看安装包的版本情况choco  upgrade &lt;packagename&gt;   更新某个软件 choco list -lo       查看本地安装包</code></pre></div></figure><p>更多命令可以使用choco help查看。</p><p><strong>note</strong>:要在administrator下运行命令，不然会提示权限不够。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	chocolatey是windows下的一个包管理器，久闻大名。这玩意主要是方便，安装好东西后，不用再进一步的配置环境变量。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    <category term="tools" scheme="https://brraida.github.io/categories/windows/tools/"/>
    
    
    <category term="chocolatey" scheme="https://brraida.github.io/tags/chocolatey/"/>
    
  </entry>
  
  <entry>
    <title>使用ssh将本地仓库上传到github</title>
    <link href="https://brraida.github.io/posts/33f781e7/"/>
    <id>https://brraida.github.io/posts/33f781e7/</id>
    <published>2022-03-06T14:56:41.000Z</published>
    <updated>2022-06-09T02:16:30.973Z</updated>
    
    <content type="html"><![CDATA[<p>​    使用hexo部署到github时，发生了time out。网上有方法使用的是代理。但是代理时行时不行，所以我尝试使用ssh的方式解决这个问题。</p><span id="more"></span><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>Failed to connect to github.com port 443: Timed out</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="使用git-bash创建密钥"><a href="#使用git-bash创建密钥" class="headerlink" title="使用git bash创建密钥"></a>使用git bash创建密钥</h3><p>①打开Git Bash</p><p>②输入下面的文本，将your_email改成你自己的邮箱</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code></pre></div></figure><p>③一直按确定即可</p><h3 id="将SSH密钥添加到ssh-agent"><a href="#将SSH密钥添加到ssh-agent" class="headerlink" title="将SSH密钥添加到ssh-agent"></a>将SSH密钥添加到ssh-agent</h3><div class="note note-primary">            <p>ssh-agent是一个密钥管理器，用来管理一个多个密钥，并为其他ssh key的程序提供代理。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/126117538">ssh agent详解 - 知乎 (zhihu.com)</a></p></blockquote>          </div><p>①确保ssh-agent正在运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eval &quot;$(ssh-agent -s)&quot;</code></pre></div></figure><p>②将ssh私钥添加到ssh-agent</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-add ~&#x2F;.ssh&#x2F;id_ed25519</code></pre></div></figure><h3 id="将SSH密钥添加到github的账号上"><a href="#将SSH密钥添加到github的账号上" class="headerlink" title="将SSH密钥添加到github的账号上"></a>将SSH密钥添加到github的账号上</h3><p>详细的图文步骤：<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">新增 SSH 密钥到 GitHub 帐户 - GitHub Docs</a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -T git@github.com</code></pre></div></figure><p><img src="/img/article/ssh-github.assets/image-20220307115327959.png" alt="image-20220307115327959"></p><p>成功的话，会有如上提示。</p><p>​    但是可能会发生<code>git-ssh: connect to host github.com port 22: Connection timed out</code>错误。</p><p>​    解决方法：</p><p>​    编辑config文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.ssh&#x2F;config# add contentHost github.comHostname ssh.github.comPort 443</code></pre></div></figure><p>再测试。</p><blockquote><p>[<a href="https://www.jianshu.com/p/c3aac5024877">解决]git-ssh: connect to host github.com port 22: Connection timed out - 简书 (jianshu.com)</a></p></blockquote><h3 id="修改hexo的配置文件（-config-yml"><a href="#修改hexo的配置文件（-config-yml" class="headerlink" title="修改hexo的配置文件（_config.yml)"></a>修改hexo的配置文件（_config.yml)</h3><p><img src="/img/article/ssh-github.assets/code.png" alt="修改hexo配置文件"></p><p>之后在进行deploy操作的时候，现在为止，暂时没有感到任何问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    使用hexo部署到github时，发生了time out。网上有方法使用的是代理。但是代理时行时不行，所以我尝试使用ssh的方式解决这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://brraida.github.io/categories/hexo/"/>
    
    
    <category term="ssh" scheme="https://brraida.github.io/tags/ssh/"/>
    
    <category term="github" scheme="https://brraida.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>利用docker部署freshrss</title>
    <link href="https://brraida.github.io/posts/ce00252e/"/>
    <id>https://brraida.github.io/posts/ce00252e/</id>
    <published>2022-02-28T11:59:23.000Z</published>
    <updated>2022-06-09T02:58:28.566Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><p>​    因为<strong>freshrss</strong>的颜值更高，所以选择了<strong>freshrss</strong>作为<strong>rss</strong>的阅读器。</p><p>​    <span id="more"></span></p><div class="note note-primary">            <p>​    以普通用户账户进行部署<strong>freshrss</strong></p>          </div><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建freshrss目录mkdir freshrsscd freshrssvim docker-compose.yml</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># docker-compose.yml里的内容version: &quot;3&quot;services:  freshrss-db:    image: postgres:latest    container_name: freshrss-db    hostname: freshrss-db    restart: unless-stopped    volumes:      - freshrss-db:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data    environment:        # 数据库默认配置，建议修改      POSTGRES_USER: freshrss      POSTGRES_PASSWORD: freshrss      POSTGRES_DB: freshrss  freshrss-app:    image: freshrss&#x2F;freshrss:latest    container_name: freshrss-app    hostname: freshrss-app    restart: unless-stopped    ports:      - &quot;8080:80&quot;    # 建议修改8080端口，注意若防火墙开启，要记得将端口打开    depends_on:      - freshrss-db    volumes:      - .&#x2F;data:&#x2F;var&#x2F;www&#x2F;FreshRSS&#x2F;data      - .&#x2F;extensions:&#x2F;var&#x2F;www&#x2F;FreshRSS&#x2F;extensions    environment:      CRON_MIN: &#39;*&#x2F;45&#39; # rss的刷新周期，单位为分钟，此为45分钟刷新一次      TZ: Asia&#x2F;Shanghai  # 时区volumes:  freshrss-db:</code></pre></div></figure><p>复制后最好将中文注释给删除。</p><p><code>:wq</code>保存后退出。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo docker-compose up -d # 后台运行</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo docker-compose down # 用这个命令关停容器</code></pre></div></figure><h1 id="freshrss配置"><a href="#freshrss配置" class="headerlink" title="freshrss配置"></a>freshrss配置</h1><p>​    访问<code>ip:port</code></p><h2 id="数据库的配置"><a href="#数据库的配置" class="headerlink" title="数据库的配置"></a>数据库的配置</h2><table><thead><tr><th align="center">数据库配置</th><th align="left"></th><th align="center">上表的信息</th></tr></thead><tbody><tr><td align="center">主机</td><td align="left">是docker中该容器的ip地址，下方会告诉怎么操作获得ip地址</td><td align="center"></td></tr><tr><td align="center">用户名</td><td align="left">配置文件中的POSTGRES_USER</td><td align="center">freshrss</td></tr><tr><td align="center">密码</td><td align="left">配置文件中的POSTGRES_PASSWORD</td><td align="center">freshrss</td></tr><tr><td align="center">数据库</td><td align="left">配置文件中的POSTGRES_DB</td><td align="center">freshrss</td></tr><tr><td align="center">表前缀</td><td align="left">随意填</td><td align="center"></td></tr></tbody></table><p>OK，讲一下主机的ip地址的获取方式。</p><p>首先用的是postgres数据库，所以查的是postgres数据库，而不是freshrss的ip地址。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 获取正在运行的容器的一些信息，主要目的是为了获取postgres的idsudo docker ps# 获取指定容器的详细信息sudo docker inspect &lt;container id&gt;</code></pre></div></figure><p><img src="/img/article/freshrss/image-20220228204503597.png" alt="运行docker ps获得id"></p><p><img src="/img/article/freshrss/image-20220228204939760.png" alt="运行docker inspect id获ip的地址"></p><p>以上即为主机地址。</p><hr><p>方法一：服务器重启后，数据库的ip可能会发生变化，这时候只需要去修改<code>.data/config.php</code>文件中数据库的ip地址即可。</p><p>方法二：若是每回重启去修改也不是个好办法，那么为什么不给数据库一个静态的地址呢。</p><ul><li><p>可以利用portainer来进行设置</p><p><img src="/img/article/freshrss/2022-05-30-10-37-57-image.png" alt="利用portainer设置"></p></li></ul><p>    然后点击<code>部署容器</code>按钮即可重新部署。</p><ul><li><p>利用docker命令重新部署</p><figure><div class="code-wrapper"><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"># 查看容器sudo docker ps# 根据容器id&#x2F;容器名关闭容器sudo docker stop CONTAINERID# 删除容器sudo docker rm containerId# 查看子网划分sudo docker network ls# 查看容器的ip地址sudo docker inspect CONTAINERID# 如果没有子网，创建子网sudo docker network create --subnet&#x3D;172.20.0.0&#x2F;16 # 重新部署sudo docker run --net CUSTOMNETWORK --ip 172.20.0.5 -d IMAGENAME</code></pre></div></figure></li></ul><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h2 id="http配置"><a href="#http配置" class="headerlink" title="http配置"></a>http配置</h2><p>​    如果有自己的域名，可以使用反向代理。我用的是<strong>nginx proxy manager</strong>（开源项目，感兴趣的可以在github上搜索一下）进行代理。</p><p><img src="/img/article/freshrss/image-20220228205442096.png" alt="image-20220228205442096"></p><p><img src="/img/article/freshrss/image-20220228205951154.png" alt="image-20220228205951154"></p><p>这样的配置就可以进行80端口反向代理访问（即http访问）。</p><h2 id="https设置"><a href="#https设置" class="headerlink" title="https设置"></a>https设置</h2><p>​    加个锁也很方便。</p><p>​    <img src="/img/article/freshrss/image-20220228210313366.png" alt="image-20220228210313366"></p><p><img src="/img/article/freshrss/image-20220228210359316.png" alt="image-20220228210359316"></p><p>OK，这样就反向代理成功了。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>​    如果你要用APP看（比如feedme之类的软件），那么freshrss的api是这么调出来的。</p><ol><li><p>设置–&gt;管理–&gt;认证允许API访问</p></li><li><p>设置–&gt;用户账户</p><p>在此处即可看到api</p></li><li><p>比如在feedme中登录</p><p>输入的网址就为<code>https://域名/api/greader.php</code>。（别忘记greader.php这个）。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.ichr.me/post/docker-freshrss-setup/">使用 Docker 部署 FreshRSS 自建专属 RSS 服务 | ChrAlpha’s Blog (ichr.me)</a></li><li><a href="https://github.com/FreshRSS/FreshRSS/tree/edge/Docker">FreshRSS&#x2F;Docker at edge · FreshRSS&#x2F;FreshRSS (github.com)</a></li><li><a href="https://shownotes.opensourceisawesome.com/snapdrop-an-open-source-airdrop-for-everyone/">SnapDrop: An Open Source AirDrop for Everyone (opensourceisawesome.com)</a></li><li><a href="https://github.com/seazon/FeedMe/blob/master/doc/en/rss_authentication_guide.md">FeedMe&#x2F;rss_authentication_guide.md at master · seazon&#x2F;FeedMe (github.com)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;​    因为&lt;strong&gt;freshrss&lt;/strong&gt;的颜值更高，所以选择了&lt;strong&gt;freshrss&lt;/strong&gt;作为&lt;strong&gt;rss&lt;/strong&gt;的阅读器。&lt;/p&gt;
&lt;p&gt;​</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="freshrss" scheme="https://brraida.github.io/tags/freshrss/"/>
    
    <category term="rss" scheme="https://brraida.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>在heroku上安装umami</title>
    <link href="https://brraida.github.io/posts/58a2658f/"/>
    <id>https://brraida.github.io/posts/58a2658f/</id>
    <published>2022-02-25T13:26:32.000Z</published>
    <updated>2022-06-09T03:00:02.709Z</updated>
    
    <content type="html"><![CDATA[<p>​    在heroku上建立<strong>umami</strong>用于网站的信息收集。</p><span id="more"></span><ol><li><p>注册Heroku账号</p></li><li><p>点击链接<a href="https://umami.is/docs/running-on-heroku">install_umami_on_heroku</a>，然后在点击自动部署模板。</p></li><li><p>在模板填appName，然后就可以点击deploy。</p></li><li><p>跟着<a href="https://umami.is/docs">umami_instructor</a>，进行登录、添加网站即可（网站不要加前缀，比如https:&#x2F;&#x2F;，加这个成功不了）。</p></li></ol><hr><p>​    要将脚本加入网站中，而我用的是hexo搭建的博客。所以使用injector将脚本进行注入。</p><p>​    在<strong>blog</strong>目录下，创建<strong>scripts</strong>文件夹，再在<strong>scripts</strong>文件夹下创建一个js文件（我创建的是index.js）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;-- 编辑javascript文件--!&gt;hexo.extend.injector.register(&#39;head_end&#39;,&#39;&lt;script async defer data-website-id&#x3D;&quot;&quot; src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt;&#39;,&#39;default&#39;);</code></pre></div></figure><p>参数信息参考：</p><p><a href="https://hexo.io/zh-cn/api/injector.html">注入器（Injector） | Hexo</a></p><p>参考链接：</p><ol><li><p><a href="https://hexo.fluid-dev.com/posts/hexo-injector/">通过 Hexo 5 注入器为主题添加新功能 - Hexo Theme Fluid (fluid-dev.com)</a></p></li><li><p><a href="https://umami.is/">umami</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    在heroku上建立&lt;strong&gt;umami&lt;/strong&gt;用于网站的信息收集。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://brraida.github.io/categories/hexo/"/>
    
    
    <category term="heroku" scheme="https://brraida.github.io/tags/heroku/"/>
    
    <category term="umami" scheme="https://brraida.github.io/tags/umami/"/>
    
    <category term="hexo_injector" scheme="https://brraida.github.io/tags/hexo-injector/"/>
    
  </entry>
  
  <entry>
    <title>在docker中创建portainer</title>
    <link href="https://brraida.github.io/posts/e531a5f8/"/>
    <id>https://brraida.github.io/posts/e531a5f8/</id>
    <published>2022-02-21T06:02:00.000Z</published>
    <updated>2022-06-09T05:11:34.547Z</updated>
    
    <content type="html"><![CDATA[<p>​    发现一个好的工具，可视化的容器管理工具。操作容器不是简单了一点半点。  </p><span id="more"></span><blockquote><p>官网：</p><p><a href="https://www.portainer.io/">Container Management | Kubernetes GUI | Docker Swarm GUI | Portainer</a></p></blockquote><p>​    个人版是免费的，官网有教程。但是鉴于自己英语不是非常好，并且想尽可能尝试这个项目，因此装一个汉化版的。</p><p>​    一切安装命令都是以root用户进行的。</p><ol><li><p>创建缓存</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker volume create portainer_data # 用于存储之后初始化的账号信息</code></pre></div></figure></li><li><p>创建目录下载资源</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;data&#x2F;portainer&#x2F;data # 创建目录cd &#x2F;data&#x2F;portainerwget https:&#x2F;&#x2F;imnks.com&#x2F;usr&#x2F;uploads&#x2F;2022&#x2F;02&#x2F;portainer-ce-2.9.3-public-cn-20211213.zip # 下载汉化资源unzip portainer-ce-2.9.3-public-cn-20211213.zip -d public #解压 </code></pre></div></figure></li><li><p>配置、拉取、运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 9000:9000 --name portainer \    --restart&#x3D;always \    -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \    -v portainer_data:&#x2F;data \    -v &#x2F;data&#x2F;portainer&#x2F;public:&#x2F;public \    portainer&#x2F;portainer-ce:2.11.1    # 运行，开放9000端口，用于http访问（官网的是https）;最后数字2.11.1去掉，会默认下载最新版本</code></pre></div></figure></li><li><p>访问ip:9090</p></li></ol><p>​    如果你想加一个反向代理，推荐一个好的工具<a href="https://nginxproxymanager.com/">Nginx Proxy Manager</a>。</p><p>​    </p><p><strong>参考链接：</strong></p><p><a href="https://cloud.tencent.com/developer/article/1621103">Portainer中文汉化 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://imnks.com/3406.html">Docker管理面板Portainer中文完美汉化2021 新增CE汉化 - 我不是矿神 (imnks.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    发现一个好的工具，可视化的容器管理工具。操作容器不是简单了一点半点。  &lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="tools" scheme="https://brraida.github.io/categories/linux/tools/"/>
    
    
    <category term="portainer" scheme="https://brraida.github.io/tags/portainer/"/>
    
  </entry>
  
  <entry>
    <title>在腾讯云上创建普通用户</title>
    <link href="https://brraida.github.io/posts/d6cb9e1e/"/>
    <id>https://brraida.github.io/posts/d6cb9e1e/</id>
    <published>2022-02-03T12:47:14.000Z</published>
    <updated>2022-06-09T13:08:51.038Z</updated>
    
    <content type="html"><![CDATA[<p>​创建普通用户和使用密钥进行登录。</p><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    某个项目推荐使用非root用户进行部署,在这个过程中谈谈对<strong>新用户的建立</strong>,<strong>使用ssh的密钥对方式进行登录</strong>,其中遇到的一些问题和一些见解。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>​    使用的是腾讯云服务器,系统用的是<strong>Debian10.2</strong>；</p><p>​    两对密钥,一对是用于root,一对是用于测试普通用户；</p><p>​    Xshell客户端进行ssh登录。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-在腾讯云的控制台上获取密钥对-下载密钥到本地-并绑定实例。"><a href="#1-在腾讯云的控制台上获取密钥对-下载密钥到本地-并绑定实例。" class="headerlink" title="1.在腾讯云的控制台上获取密钥对,下载密钥到本地,并绑定实例。"></a>1.在腾讯云的控制台上获取密钥对,下载密钥到本地,并绑定实例。</h2><p><strong>note：如果是在腾讯云控制台上获取密钥对,会直接将公钥放入系统相应位置(~&#x2F;.ssh&#x2F;authorized_keys)中；绑定实例后将不能在腾讯云控制台上直接登录。</strong></p><blockquote><p>细节操作：</p><p><a href="https://cloud.tencent.com/document/product/1207/44573?from=copy">轻量应用服务器 管理密钥 - 操作指南 - 文档中心 - 腾讯云</a></p></blockquote><h2 id="2-用root账户在Xshell客户端进行登录。"><a href="#2-用root账户在Xshell客户端进行登录。" class="headerlink" title="2.用root账户在Xshell客户端进行登录。"></a>2.用root账户在Xshell客户端进行登录。</h2><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212038017.png" alt="image-20220204212038017"></p><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212156456.png" alt="image-20220204212156456"></p><p>​    <strong>note：第一次填的时候,需要填root(因为此时只有root账号是开放的)。</strong></p><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212541938.png" alt="image-20220204212541938"></p><h2 id="3-创建新用户-复制公钥到新用户的根目录下-并修改文件的属性使新用户可用。"><a href="#3-创建新用户-复制公钥到新用户的根目录下-并修改文件的属性使新用户可用。" class="headerlink" title="3.创建新用户,复制公钥到新用户的根目录下,并修改文件的属性使新用户可用。"></a>3.创建新用户,复制公钥到新用户的根目录下,并修改文件的属性使新用户可用。</h2><p>谈谈：Debian系统对比centos在某些方面对新手不是很友好,它在使用<code>useradd</code>命令时,是默认没有主目录和shell的。</p><hr><p>更新：</p><p> 可以使用bash命令<code>adduser</code>来创建用户，会友好许多。</p><hr><h3 id="3-1创建新用户"><a href="#3-1创建新用户" class="headerlink" title="3.1创建新用户"></a>3.1创建新用户</h3><ul><li><code>useradd</code>命令格式</li></ul><p>useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号</p><p>(useradd是可以查看与修改的,查看命令<code>useradd -D</code>;修改的路径<code>/etc/default/useradd</code>。)</p><ul><li><p>我修改的默认配置（鉴于以后可能会创建多个用户，省力）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SHELL&#x3D;&#x2F;bin&#x2F;bash # 默认的shellGROUP&#x3D;100    # 默认的用户组HOME&#x3D;&#x2F;home    # 默认的家目录所在的目录INACTIVE&#x3D;-1 # 密码失效日期EXPIRE&#x3D;        # 账号失效日期SKEL&#x3D;&#x2F;etc&#x2F;skel # 使用者家目录的内容数据参考目录CREATE_MAIL_SPOOL&#x3D;yes # 是否主动帮助使用者建立邮箱</code></pre></div></figure><p>还要修改<code>/etc/login.defs</code>文件的内容，在这个文件中任意位置添加<code>CREATE_HOME    yes</code>，其作用是主动建立使用者的家目录。</p><hr><p>若是嫌麻烦，先添新组<code>groupadd -g 1790 groupName</code>;再使用<code>useradd -u 1790 -g groupName -m -s /bin/bash userName</code>添加新用户。</p></li><li><p>可以使用<code>id username</code>查看用户的一些相关参数。</p></li></ul><h3 id="3-2root用户复制公钥到新用户的根目录下-并修改文件的属性使新用户可用"><a href="#3-2root用户复制公钥到新用户的根目录下-并修改文件的属性使新用户可用" class="headerlink" title="3.2root用户复制公钥到新用户的根目录下,并修改文件的属性使新用户可用"></a>3.2root用户复制公钥到新用户的根目录下,并修改文件的属性使新用户可用</h3><ul><li><p>在root用户终端界面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp -pr ~&#x2F;.ssh &#x2F;home&#x2F;username # 将公钥都复制过去，其实只要复制密钥对应的公钥即可chown -R username:groupname &#x2F;home&#x2F;username&#x2F;.ssh # 修改.ssh目录为新用户可操作文件chmod 700 &#x2F;home&#x2F;username&#x2F;.ssh # 以防万一，你也可以输入ls -al 查看目录权限是否为700chmod 600 &#x2F;home&#x2F;username&#x2F;.ssh&#x2F;authorized_keys # 同理</code></pre></div></figure></li><li><p>在username用户终端界面</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -al #查看权限是否修改正确</code></pre></div></figure></li></ul><h2 id="用新用户账号在Xshell客户端进行登录。"><a href="#用新用户账号在Xshell客户端进行登录。" class="headerlink" title="用新用户账号在Xshell客户端进行登录。"></a>用新用户账号在Xshell客户端进行登录。</h2><p>​    与用root登录同理，不同的是账号名和密钥选取。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li><p>我发现Debian10.2 的vim无法使用鼠标右键进行复制。</p><p>解决方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vim81&#x2F;defaults.vim# 差不多在79行位置set mouse&#x3D;a 修改为 set mouse-&#x3D;a# 保存即可</code></pre></div></figure></li><li><p>文件没有颜色</p><p>解决办法：修改 .bashrc 文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.bashrc</code></pre></div></figure><p>去掉默认某些注释</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LS_OPTIONS&#x3D;&#39;--color&#x3D;auto&#39;eval &quot;&#96;dircolors&#96;&quot;alias ls&#x3D;&#39;ls $LS_OPTIONS&#39;alias ll&#x3D;&#39;ls $LS_OPTIONS -l&#39; # 使ll有效</code></pre></div></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	创建普通用户和使用密钥进行登录。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="ssh" scheme="https://brraida.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>禁止华为的智能搜索</title>
    <link href="https://brraida.github.io/posts/94ca0eb1/"/>
    <id>https://brraida.github.io/posts/94ca0eb1/</id>
    <published>2022-01-29T07:05:01.000Z</published>
    <updated>2022-06-09T13:17:55.928Z</updated>
    
    <content type="html"><![CDATA[<p>​    有被华为的智能搜索“冒犯”到。所以想办法解决一下。</p><span id="more"></span><blockquote><p>转载:</p><p><a href="https://www.zhihu.com/question/343737292">如何关闭华为的智慧搜索?就是下图的这个，好烦？ - 知乎 (zhihu.com)</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>电脑</li><li>数据线</li><li>ADB工具</li></ol><blockquote><p>ADB工具下载地址：</p><p><a href="https://brraida.lanzouy.com/b030ol6yj">https://brraida.lanzouy.com/b030ol6yj</a><br>密码:8f7e</p></blockquote><p><strong>note：</strong></p><p>​    ADB文件夹最好放置于无中文字符。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-打开手机USB调试"><a href="#1-打开手机USB调试" class="headerlink" title="1.打开手机USB调试"></a>1.打开手机USB调试</h3><p>​    1.1 打开开发者选项：设置-&gt;关于手机-&gt;版本号，连续点击，直至提示已处于开发者模式（手机如果设置密码和隐私密码，则会输入密码）。</p><p>​    1.2 打开USB调试：设置-&gt;系统更新-&gt;开发人员选项-&gt;USB调试，打开后会提示是否允许USB调试，点击确定。</p><p>​    1.3 将手机通过数据线连接到电脑。</p><p><strong>note：</strong></p><p>​    部分手机可能需要在手机上将USB连接方式改为传输文件。（我的Nova7就需要这样）</p><h3 id="2-电脑端打开ADB工具"><a href="#2-电脑端打开ADB工具" class="headerlink" title="2.电脑端打开ADB工具"></a>2.电脑端打开ADB工具</h3><p>​    2.1 进入ADB文件夹，双击<code>打开CMD命令行.bat</code></p><p>​    2.2 在CMD里输入：<code>adb devices</code>（第一次连接需要在手机上点击确认，连接成功会有提示和设备显示）</p><p>​        若没有显示，可以拔插多试几次。</p><h3 id="3-通过命令行停用-x2F-删除系统文件"><a href="#3-通过命令行停用-x2F-删除系统文件" class="headerlink" title="3.通过命令行停用&#x2F;删除系统文件"></a>3.通过命令行停用&#x2F;删除系统文件</h3><p>​    在电脑端之前打开的CMD窗口输入命令即可。</p><p>​    停用命令(推荐）:<code>adb shell pm diable-user com.huawei.search</code></p><p>​    恢复命令:<code>adb shell pm enable com.huawei.search</code></p><p>​    删除命令:<code>adb shell pm uninstall --user 0 com.huawei.search</code></p><p><strong>note：</strong></p><p>​    删除系统软件后无法恢复，使用时候请谨慎操作。</p><h3 id="4-完成后，关闭手机开发者模式"><a href="#4-完成后，关闭手机开发者模式" class="headerlink" title="4.完成后，关闭手机开发者模式"></a>4.完成后，关闭手机开发者模式</h3><p>​    设置-&gt;系统更新-&gt;开发人员选项</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    有被华为的智能搜索“冒犯”到。所以想办法解决一下。&lt;/p&gt;</summary>
    
    
    
    <category term="phone" scheme="https://brraida.github.io/categories/phone/"/>
    
    
    <category term="HuaWei" scheme="https://brraida.github.io/tags/HuaWei/"/>
    
  </entry>
  
  <entry>
    <title>cfw_SpecialTricks</title>
    <link href="https://brraida.github.io/posts/13fbfbd4/"/>
    <id>https://brraida.github.io/posts/13fbfbd4/</id>
    <published>2022-01-29T04:42:43.000Z</published>
    <updated>2022-06-09T13:22:11.768Z</updated>
    
    <content type="html"><![CDATA[<p>​    cfw版本用的是0.19.7。如果偶尔科学上网，不配置也没问题。日常使用，如果使用全局代理的话，就不能访问国内的一些网站。所以使用规则代理。</p><span id="more"></span><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><blockquote><p>项目地址：<a href="https://github.com/Loyalsoldier/clash-rules">Loyalsoldier&#x2F;clash-rules: 🦄️ 🎃 👻 Clash Premium 规则集(RULE-SET)，兼容 ClashX Pro、Clash for Windows 客户端。 (github.com)</a></p></blockquote><p>​    有可能是第一次需求，不知道从何下手，所以我就进行简单的、较为完整的叙述。</p><ol><li>点击下图中<code>Home Directory</code>栏的<code>Open Folder</code></li></ol><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129124944723.png" alt="image-20220129124944723"></p><ol start="2"><li><p>用记事本或是vscode打开<code>config.yaml</code></p></li><li><p>复制如下代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rule-providers:  reject:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;reject.txt&quot;    path: .&#x2F;ruleset&#x2F;reject.yaml    interval: 86400  icloud:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;icloud.txt&quot;    path: .&#x2F;ruleset&#x2F;icloud.yaml    interval: 86400  apple:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;apple.txt&quot;    path: .&#x2F;ruleset&#x2F;apple.yaml    interval: 86400  google:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;google.txt&quot;    path: .&#x2F;ruleset&#x2F;google.yaml    interval: 86400  proxy:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;proxy.txt&quot;    path: .&#x2F;ruleset&#x2F;proxy.yaml    interval: 86400  direct:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;direct.txt&quot;    path: .&#x2F;ruleset&#x2F;direct.yaml    interval: 86400  private:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;private.txt&quot;    path: .&#x2F;ruleset&#x2F;private.yaml    interval: 86400  gfw:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;gfw.txt&quot;    path: .&#x2F;ruleset&#x2F;gfw.yaml    interval: 86400  greatfire:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;greatfire.txt&quot;    path: .&#x2F;ruleset&#x2F;greatfire.yaml    interval: 86400  tld-not-cn:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;tld-not-cn.txt&quot;    path: .&#x2F;ruleset&#x2F;tld-not-cn.yaml    interval: 86400  telegramcidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;telegramcidr.txt&quot;    path: .&#x2F;ruleset&#x2F;telegramcidr.yaml    interval: 86400  cncidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;cncidr.txt&quot;    path: .&#x2F;ruleset&#x2F;cncidr.yaml    interval: 86400  lancidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;lancidr.txt&quot;    path: .&#x2F;ruleset&#x2F;lancidr.yaml    interval: 86400  applications:    type: http    behavior: classical    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;applications.txt&quot;    path: .&#x2F;ruleset&#x2F;applications.yaml    interval: 86400</code></pre></div></figure><p>添加到config.yaml文件末尾</p><hr><p>复制如下代码(白名单模式)</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rules:  - RULE-SET,applications,DIRECT  - DOMAIN,clash.razord.top,DIRECT  - DOMAIN,yacd.haishan.me,DIRECT  - RULE-SET,private,DIRECT  - RULE-SET,reject,REJECT  - RULE-SET,icloud,DIRECT  - RULE-SET,apple,DIRECT  - RULE-SET,google,DIRECT  - RULE-SET,proxy,PROXY  - RULE-SET,direct,DIRECT  - RULE-SET,lancidr,DIRECT  - RULE-SET,cncidr,DIRECT  - RULE-SET,telegramcidr,PROXY  - GEOIP,,DIRECT  - GEOIP,CN,DIRECT  - MATCH,PROXY</code></pre></div></figure><p>将原本文件中的<code>rules</code>取代</p></li><li><p>重启cfw，软件将会自动配置生成一个<code>ruleset</code>的新文件夹。可能会提醒出错（忘记截图了），选<code>repair</code>，然后<code>confirm</code>即会帮你自动修复。</p></li></ol><p>附上配置规则成功后的截图：</p><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129140754975.png" alt="image-20220129140754975"></p><h2 id="allow-lan"><a href="#allow-lan" class="headerlink" title="allow lan"></a>allow lan</h2><p>​    说说cfw的这个选项是干嘛的。简单的说，就是他可以实现局域网下其他设备科学上网。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​    <strong>电脑端</strong></p><p>​    开启后会得到如下信息：</p><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129141231761.png" alt="image-20220129141231761"></p><p>​    <strong>Ipad端</strong>(我测试的是)</p><p>​        <img src="/img/article/cfw-SpecialTricks.assets/B17EDD0A35EC9BCB380B55FAE0E7AD68.png" alt="iPad设置"></p><p>然后就可以科学上网了。</p><p>（完）</p><blockquote><p><a href="https://docs.cfw.lbyczf.com/contents/parser.html#%E7%89%88%E6%9C%AC%E8%A6%81%E6%B1%82">配置文件预处理 | Clash for Windows (lbyczf.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    cfw版本用的是0.19.7。如果偶尔科学上网，不配置也没问题。日常使用，如果使用全局代理的话，就不能访问国内的一些网站。所以使用规则代理。&lt;/p&gt;</summary>
    
    
    
    <category term="scienceNet" scheme="https://brraida.github.io/categories/scienceNet/"/>
    
    
    <category term="rules" scheme="https://brraida.github.io/tags/rules/"/>
    
    <category term="clash" scheme="https://brraida.github.io/tags/clash/"/>
    
  </entry>
  
  <entry>
    <title>liunx的一些基础知识</title>
    <link href="https://brraida.github.io/posts/fdfafe7c/"/>
    <id>https://brraida.github.io/posts/fdfafe7c/</id>
    <published>2022-01-25T13:15:28.000Z</published>
    <updated>2022-06-09T13:32:36.077Z</updated>
    
    <content type="html"><![CDATA[<p>​记录一些linux的不懂且常见的知识。</p><span id="more"></span><h2 id="linux之颜色"><a href="#linux之颜色" class="headerlink" title="linux之颜色"></a>linux之颜色</h2><p>linux中文件颜色所代表的含义：</p><ol><li><strong>绿色</strong>文件：可执行文件、可执行程序</li><li><strong>红色</strong>文件：压缩文件或者包文件</li><li><strong>蓝色</strong>文件：目录</li><li><strong>白色</strong>文件：一般性文件，如文本文件，配置文件，源码文件</li><li><strong>浅蓝色</strong>文件：链接文件，主要是使用ln命令建立的文件</li><li><strong>红色闪烁</strong>：表示链接文件有问题</li><li><strong>黄色</strong>：表示设备文件</li><li><strong>灰色</strong>：表示其他文件</li></ol><p>主要比较一下浅蓝色和蓝色区别</p><p><img src="/img/article/LinuxBasicKnowledge.assets/image-20220125212209692.png" alt="image-20220125212209692"></p><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><h3 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">具体用法是：ln -s 源文件 目标文件。源：实际存放文件的位置</code></pre></div></figure><p>​当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>-s 是代号（symbolic）的意思</p><p><strong>注意</strong></p><p>​    ln的链接又软链接 和硬链接两种</p><ul><li><p><strong>软链接</strong><code>ln -s ** **</code>,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间</p></li><li><p><strong>硬链接</strong><code>ln ** **</code>, 没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件</p><p>无论是软链接还是硬链接，文件都保持同步变化</p></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#比如我的文件在 &#x2F;opt&#x2F;cs 下面，我想在 &#x2F;opt&#x2F;var&#x2F;cs 这个路径下面也能访问到，那么应该这样来做ln -s  &#x2F;opt&#x2F;cs   &#x2F;opt&#x2F;var     # &#x2F;opt&#x2F;var下面不用创建cs这个目录，会自动创建</code></pre></div></figure><h3 id="查看建立的软链接"><a href="#查看建立的软链接" class="headerlink" title="查看建立的软链接"></a>查看建立的软链接</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -il</code></pre></div></figure><h3 id="删除软链接"><a href="#删除软链接" class="headerlink" title="删除软链接"></a>删除软链接</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf file</code></pre></div></figure><p>正确的删除方式（删除软链接，但不删除实际数据）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf .&#x2F;test_chk_ln</code></pre></div></figure><blockquote><p>转载</p><p><a href="https://www.cnblogs.com/lfxiao/p/9569339.html">https://www.cnblogs.com/lfxiao/p/9569339.html</a></p></blockquote><hr><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><ul><li>修改文件名或目录名</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv oldFileName(oldDirectoryName) newFileName(newDirectoryName)</code></pre></div></figure><ul><li>查看端口</li></ul><blockquote><p><a href="https://blog.csdn.net/qq_41675254/article/details/85208057">Linux查看端口使用状态、关闭端口及配置端口方法 详细_会发抖的秒表的博客-CSDN博客_linux 端口</a></p></blockquote><p>​    lsof -i:端口号</p><p>​    losf -i        #查看全部</p><ul><li><p>vim查找</p><p><strong>:&#x2F;关键词</strong> 回车开始查找，按n查找下一个</p><p><strong>:数字</strong> 回车到某行</p></li><li><p>查看已开放端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --list-all</code></pre></div></figure></li><li><p>防火墙开放端口（开放端口后需要重载防火墙）</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanentfirewall-cmd --reload</code></pre></div></figure></li><li><p>修改密码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">passwd &lt;usrname&gt;</code></pre></div></figure></li><li><p>修改主机名</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hostnamectl set-hostname &lt;newhostname&gt;</code></pre></div></figure></li></ul><hr><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>​挂载是指有操作系统使一个存储设备（诸如硬盘、CD-ROM或共享资源）上的电脑文件和目录可供用户通过电脑的文件系统访问的一个过程。</p><blockquote><p><a href="https://zh.m.wikipedia.org/zh-sg/%E6%8C%82%E8%BD%BD">挂载 - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	记录一些linux的不懂且常见的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>通过源码安装git</title>
    <link href="https://brraida.github.io/posts/ca44ae47/"/>
    <id>https://brraida.github.io/posts/ca44ae47/</id>
    <published>2022-01-25T12:30:50.000Z</published>
    <updated>2022-06-09T13:34:33.334Z</updated>
    
    <content type="html"><![CDATA[<p>​尝试使用源码的方式安装git应用。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>腾讯云、centos7</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>​    可能你为了某种需求（比如必须更好地管理文件）而要卸载git，重新安装git。</p><p><strong>一、</strong> </p><p>​    若通过yum安装git，那么只需要执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum remove git #卸载gitwhich git#或者whereis git #查询git残留</code></pre></div></figure><p><strong>二、</strong></p><p>​    若通过源码安装git</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">which git#或者whereis git #查询git位置#去相应位置删除git相关文件rm -rf git</code></pre></div></figure><p>​    最好可以备份一下，那么就可以大胆一下去删除了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    回归正题。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.9.5.tar.gz</code></pre></div></figure><p>P.S. 可以在<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">这里</a>查找最新版本的git下载，然后替换一下git的版本数字就行。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</code></pre></div></figure><p>​    有些依赖安装git时候不会提示，比如没有<strong>curl-devel、expat-devel</strong>将会发生<strong>git:’remote-https’ is not a git command</strong>。</p><h3 id="解压git安装包"><a href="#解压git安装包" class="headerlink" title="解压git安装包"></a>解压git安装包</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf git-2.9.5.tar.gz -C &#x2F;root #将文件解压到root文件夹下</code></pre></div></figure><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;root&#x2F;git-2.9.5.configure -prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git&#x2F; #将资源文件集中到一个位置，便于管理</code></pre></div></figure><h3 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make &amp;&amp; make install</code></pre></div></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;profile.d&#x2F;git.sh    #不在profile中配置，在这里配置是为了便于管理（不同用户有不同的路径需求，在这里配置能够更加清晰明了）#下方为git.sh文件内容GIT_HOME&#x3D;usr&#x2F;local&#x2F;git #这样做是为了使用echo查看单环境变量，大可将下方GIT_HOME取代export PATH&#x3D;$PATH:GIT_HOME&#x2F;binexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;libexe&#x2F;git-core#### wq!source &#x2F;etc&#x2F;profile #环境变量生效echo $GIT_HOME #查看环境变量</code></pre></div></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --verison</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	尝试使用源码的方式安装git应用。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="git" scheme="https://brraida.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>源码安装过程</title>
    <link href="https://brraida.github.io/posts/855ab908/"/>
    <id>https://brraida.github.io/posts/855ab908/</id>
    <published>2022-01-25T07:37:45.000Z</published>
    <updated>2022-06-09T13:39:48.703Z</updated>
    
    <content type="html"><![CDATA[<p>​源码安装就会与<code>make</code>命令搭上关系，记录点make的相关知识。</p><span id="more"></span><p><strong>源码的安装</strong>一般由这三个步骤组成：</p><ol><li>配置（configure）</li><li>编译（make）</li><li>安装（make install）</li></ol><p>​    其中<strong>prefix</strong>选项就是配置安装的路径，如果不配置该选项，安装后可执行文件默认在&#x2F;usr&#x2F;local&#x2F;bin，库文件默认放在&#x2F;usr&#x2F;local&#x2F;lib，配置文件默认放在&#x2F;usr&#x2F;local&#x2F;etc，其他资源放在&#x2F;usr&#x2F;local&#x2F;share，比较分散。</p><p>​    为了便于集中管理某个软件的各种文件，可以配置-prefix。比如，配置一个Git的文件：</p><p>​    <code>./configure -prefix=/usr/local/git/</code></p><p>可以把所有资源文件放在&#x2F;usr&#x2F;local&#x2F;git的路径中，这样将会更有层次。进行一些更新卸载操作都会比较简单。</p><blockquote><p>转载：</p><p><a href="https://blog.csdn.net/u014042372/article/details/80705408">configure –prefix 的用法_wuzhan的专栏-CSDN博客_prefix</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	源码安装就会与&lt;code&gt;make&lt;/code&gt;命令搭上关系，记录点make的相关知识。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="make" scheme="https://brraida.github.io/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>centos出现依赖问题</title>
    <link href="https://brraida.github.io/posts/3f0af65b/"/>
    <id>https://brraida.github.io/posts/3f0af65b/</id>
    <published>2022-01-25T06:56:39.000Z</published>
    <updated>2022-06-09T13:44:05.765Z</updated>
    
    <content type="html"><![CDATA[<p><strong>One of the configured repositories failed…</strong></p><span id="more"></span><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>安装依赖的时候出现了奇怪的问题。</p><p><img src="/img/article/linux-problem-dependency.assets/image-20220125150041905.png" alt="image-20220125150041905"></p><p><img src="/img/article/linux-problem-dependency.assets/image-20220125150000581.png" alt="image-20220125150000581"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>​删除原本的，更新后重新安装一遍。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum remove epel-releaseyum updateyum install epel-release</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;One of the configured repositories failed…&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>rpm数据库损坏</title>
    <link href="https://brraida.github.io/posts/b177cd12/"/>
    <id>https://brraida.github.io/posts/b177cd12/</id>
    <published>2022-01-25T02:01:48.000Z</published>
    <updated>2022-06-09T13:53:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>​rpmdb:BDB0113错误</p><span id="more"></span><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="/img/article/yumProblem-1.assets/image-20220125100614292.png" alt="image-20220125100614292"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>rpm数据库损坏</p><h2 id="解决办法（重新构建rpm数据库）"><a href="#解决办法（重新构建rpm数据库）" class="headerlink" title="解决办法（重新构建rpm数据库）"></a>解决办法（重新构建rpm数据库）</h2><p><img src="/img/article/yumProblem-1.assets/image-20220125100813204.png" alt="image-20220125100813204"></p><ul><li>cd &#x2F;var&#x2F;lib&#x2F;rpm</li><li>rm -rf __db*</li><li>rpm –rebuilddb</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	rpmdb:BDB0113错误&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="yum" scheme="https://brraida.github.io/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>给手机换字体</title>
    <link href="https://brraida.github.io/posts/99020374/"/>
    <id>https://brraida.github.io/posts/99020374/</id>
    <published>2022-01-19T13:16:41.000Z</published>
    <updated>2022-06-09T13:57:51.394Z</updated>
    
    <content type="html"><![CDATA[<p>​    有时候就是想换个壁纸、换个头像来替换一下心情。而这回我想换个<strong>字体</strong>。</p><p>​    我用的是华为手机Novo7，鸿蒙系统。不使用第三方工具，使用一套“偷梁换柱”将字体换成你想要的字体。</p><span id="more"></span><hr><p>​    看到一款开源字体，感觉不错。</p><blockquote><p><strong>霞鹜文楷</strong></p><p><a href="https://github.com/lxgw/LxgwWenKai">https://github.com/lxgw/LxgwWenKai</a></p></blockquote><p>​    </p><ol><li>打开华为的<strong>主题APP</strong>，选择字体，以<strong>免费</strong>为关键字搜索。</li><li>下载任意一款免费字体。</li><li>再下载你自己想要的一款开源或是某些渠道得到的字体。</li><li>打开<strong>文件管理APP</strong>，将步骤3中所下载的字体解压，得到后缀为ttf的字体文件，将其复制或者移动到步骤2的文件夹（所在位置一般为&#x2F;Huawei&#x2F;Themes&#x2F;HWFonts）中。</li><li>记录步骤2下载的字体文件名字，删除该文件；将步骤3中所下载的文件的文件名替换成步骤2文件的文件名。</li><li>在<strong>主题APP</strong>中<strong>应用</strong>步骤2中下载的字体，从而达到偷梁换柱的目的。</li></ol><hr><p> 我现所遇到的问题，用一些APP的时候会偶尔的闪退。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    有时候就是想换个壁纸、换个头像来替换一下心情。而这回我想换个&lt;strong&gt;字体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​    我用的是华为手机Novo7，鸿蒙系统。不使用第三方工具，使用一套“偷梁换柱”将字体换成你想要的字体。&lt;/p&gt;</summary>
    
    
    
    <category term="phone" scheme="https://brraida.github.io/categories/phone/"/>
    
    
    <category term="font" scheme="https://brraida.github.io/tags/font/"/>
    
  </entry>
  
  <entry>
    <title>电脑最大支持内存</title>
    <link href="https://brraida.github.io/posts/1f0fc3c4/"/>
    <id>https://brraida.github.io/posts/1f0fc3c4/</id>
    <published>2021-12-10T05:24:27.000Z</published>
    <updated>2022-06-09T14:01:45.535Z</updated>
    
    <content type="html"><![CDATA[<p>​影响内存的主要因素为主板。</p><span id="more"></span><blockquote><p><a href="https://www.zhihu.com/question/25013395/answer/145545591?utm_source=qq&utm_medium=social&utm_oi=798595818130112512">怎样选购笔记本内存条？ - 知乎 (zhihu.com)</a></p></blockquote><p>​    以前在选购内存条时，参考了此信息。现在对里面的内存最大容量（电脑最大支持内存）感到疑惑，不知道他的影响因素是什么。</p><p>​    经过查阅，原来是CPU和主板同时决定内存条的最大容量，并且遵循的是短板原理（然而绝大部分情况是不考虑CPU的，因为一般来说CPU支持的最大内存&gt;主板支持的最大内存）。比如CPU支持最大的内存是32G，而主板支持的最大内存是16G，那么内存的最大容量就是16G。但是，倘若插两条16G内存条也没关系（网友说的，没有实践过），就是享受不到32G的内存。</p><hr><p>​    查询电脑最大支持内存大小（我已知的几种方法）：</p><ol><li><p>如上文链接说的一样，在中关村<a href="http://www.zol.com.cn/%E6%9F%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%B5%E8%84%91%E5%9E%8B%E5%8F%B7-&gt;%E5%8F%82%E6%95%B0-&gt;%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%EF%BC%8C%E9%82%A3%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%9C%80%E5%A4%A7%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E3%80%82">www.zol.com.cn/查自己的电脑型号-&gt;参数-&gt;存储设备，那里可以获得最大存储容量。</a></p></li><li><p>在cmd窗口运行<code>wmic memphysical get maxcapacity,MemoryDevices</code>，将获得两个参数，一个是单个卡槽的最大内存支持（MaxCapcity，单位是kb），一个是卡槽数量（MemoryDevices）。</p><p><img src="/img/article/%E7%94%B5%E8%84%91%E6%94%AF%E6%8C%81%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98/order_example.png" alt="order_example"></p><p>上图单个卡槽最大内存支持为67108864&#x2F;1024&#x2F;1024&#x2F;8&#x3D;8GB</p><p>所以该电脑最大支持内存为32GB。</p><p>但是有人说这个命令不合适，有些瑕疵。</p><blockquote><p><a href="https://blog.csdn.net/Vudno/article/details/104801961">wmic memphysical get maxcapacity存疑_Vudno的博客-CSDN博客</a></p></blockquote></li><li><p>使用aida64</p><p><strong>计算机</strong>-&gt;<strong>DMI</strong>-&gt;<strong>内存矩阵</strong>-&gt;<strong>系统内存</strong>进行查看。</p><p>附上aida64的破解版：</p><blockquote><p><a href="https://www.52pojie.cn/thread-1405758-1-1.html">功能强大的硬件检测利器 AIDA64 （工程师版 &amp; 商业版） 6.33.5700 中文绿色稳定版 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	影响内存的主要因素为主板。&lt;/p&gt;</summary>
    
    
    
    <category term="computer knowledge" scheme="https://brraida.github.io/categories/computer-knowledge/"/>
    
    
    <category term="memory bank" scheme="https://brraida.github.io/tags/memory-bank/"/>
    
  </entry>
  
  <entry>
    <title>vim_config</title>
    <link href="https://brraida.github.io/posts/132608bd/"/>
    <id>https://brraida.github.io/posts/132608bd/</id>
    <published>2021-10-05T09:12:01.000Z</published>
    <updated>2022-06-09T14:12:31.233Z</updated>
    
    <content type="html"><![CDATA[<p>​    vim的一些相关配置。</p><span id="more"></span><h2 id="vim缩进修改"><a href="#vim缩进修改" class="headerlink" title="vim缩进修改"></a>vim缩进修改</h2><p>​    最近在写编译原理的课设，我直接使用vim打代码，而vim的缩进让我的队友看不下去。所以修改一下vim的配置文件。</p><ol><li><p>创建.vimrc配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.vimrc</code></pre></div></figure></li><li><p>修改配置文件</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set numberset tabstop&#x3D;2set softtabstop&#x3D;2set shiftwidth&#x3D;2set noexpandtabset autoindent</code></pre></div></figure><p>配置说明如下：</p><p>set number：表示打开文件自动显示行号</p><p>set tabstop&#x3D;2：表示一个Tab键显示出来多少个空格的长度，默认是8，这里设置为2</p><p>set softtabstop&#x3D;2：表示在编辑模式下按退格键时候退回缩进的长度，设置为2</p><p>set shiftwidth&#x3D;2：表示每一级缩进的长度，一般设置成和softtabstop长度一样</p><p>set noexpandtab：当设置成expantab时表示缩进用空格来表示，noexpandtab则用制表符表示一个缩进</p><p>set autoindent：表示自动缩进</p></li><li><p>保存退出</p><p>下一次使用vim的时候即是配置文件的状态。</p></li></ol><p>参考链接：</p><blockquote><p><a href="https://www.cnblogs.com/Cqlismy/p/11358259.html">vim设定Tab缩进长度 - Cqlismy - 博客园 (cnblogs.com)</a></p></blockquote><hr><h2 id="配置vim复制"><a href="#配置vim复制" class="headerlink" title="配置vim复制"></a>配置vim复制</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vim81&#x2F;defaults.vim# 找到第79行左右# 将set mouse&#x3D;改成set mouse&#x3D;v</code></pre></div></figure><p><strong>note：</strong> vim81会可能因为更新改变数字，所以找不到defaults.vim文件时，看看上一级目录带数字的vim文件夹(vim8X)。</p><hr><h2 id="vim一般的基础配置"><a href="#vim一般的基础配置" class="headerlink" title="vim一般的基础配置"></a>vim一般的基础配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 只会影响到当前用户vim ~&#x2F;.vimrc# 全局配置vim &#x2F;etc&#x2F;vim&#x2F;vimrc</code></pre></div></figure><p>我一般的配置。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set nocompatibleset numberset guioptions-&#x3D;r set guioptions-&#x3D;Lset guioptions-&#x3D;bset showtabline&#x3D;0set guifont&#x3D;Monaco:h13         syntax onset background&#x3D;dark    set nowrap  set fileformat&#x3D;unix set cindent     set tabstop&#x3D;4   set shiftwidth&#x3D;4        set showmatch  set scrolloff&#x3D;5     set laststatus&#x3D;2   set fenc&#x3D;utf-8      set backspace&#x3D;2   set selection&#x3D;exclusiveset selectmode&#x3D;mouse,keyset matchtime&#x3D;5set ignorecase     set incsearchset hlsearch        set noexpandtab     set whichwrap+&#x3D;&lt;,&gt;,h,lset autoreadset cursorline     set cursorcolumn        </code></pre></div></figure><p>参考:</p><blockquote><p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://juejin.cn/post/6844903646879023111">教你一步一步在vim中配置史上最难安装的You Complete Me - 掘金</a></p><p><a href="https://juejin.cn/post/6844903542558310407">把vim配置成顺手的python轻量级IDE（一） - 掘金</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    vim的一些相关配置。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="vim" scheme="https://brraida.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>二级域名、nginx反向代理的一些理解</title>
    <link href="https://brraida.github.io/posts/aed070af/"/>
    <id>https://brraida.github.io/posts/aed070af/</id>
    <published>2021-09-14T08:34:29.000Z</published>
    <updated>2022-06-09T14:18:37.147Z</updated>
    
    <content type="html"><![CDATA[<p>​小白刚接触域名。  </p><span id="more"></span> <p>​首先，一个域名对应一个服务。我以为买来的主域名只能用一次，即只能对应一个服务。但不是，买来的是主域名，还可以创建二级域名，然后用二级域名对应其他的服务，根本就不需要另外买。</p><h2 id="二级域名设置"><a href="#二级域名设置" class="headerlink" title="二级域名设置"></a>二级域名设置</h2><p><img src="/img/article/nginx-2/%E5%9B%BE1-1.png" alt="图1-1"></p><p><img src="/img/article/nginx-2/%E5%9B%BE1-2.png" alt="图1-2"></p><p>二级域名就搞定了。如果要搞SSL证书，去申请，部署。我下面就是个部署例子。</p><p><a href="https://cloud.tencent.com/document/product/400/35244">SSL 证书 Nginx 服务器 SSL 证书安装部署 - 证书安装 - 文档中心 - 腾讯云 (tencent.com)</a></p><hr><h2 id="nginx反向代理理解"><a href="#nginx反向代理理解" class="headerlink" title="nginx反向代理理解"></a>nginx反向代理理解</h2><p>​    之前理解不了nginx反向代理，个人觉得端口和服务是一一对应的（这是对的），他凭什么可以80&#x2F;443端口转发到不同服务中。现在也理解了。</p><p>​    我举个我自己弄的例子。</p><p><img src="/img/article/nginx-2/%E5%9B%BE2-1.png" alt="图2-1"></p><p>​    如图，当你以<code>https://cloudreve.bao.com</code>访问时，会被443端口监听到，nginx配置中有cloudreve.bao.com上游，所以会转到5212端口，进行相应的cloudreve服务；同理，以<code>https://ttrss.bao.com</code>访问时，会被443端口监听到，nginx配置中有ttrss.bao.com上游，所以会转到181端口，进行相应的ttrss服务。</p><p>​    nginx配置如下:</p><p><img src="/img/article/nginx-2/%E5%9B%BE2-2.png" alt="图2-2"></p><p>server_name就是上游。location就是转到相应的端口进行相应的服务。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	小白刚接触域名。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
    <category term="域名" scheme="https://brraida.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>校园邮箱</title>
    <link href="https://brraida.github.io/posts/90da9727/"/>
    <id>https://brraida.github.io/posts/90da9727/</id>
    <published>2021-09-11T10:46:28.000Z</published>
    <updated>2022-06-09T14:25:07.819Z</updated>
    
    <content type="html"><![CDATA[<figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">  校园邮箱是个好东西，他可以让你白嫖许多东西。本文介绍如何登录校园邮箱的客户端。</code></pre></div></figure><span id="more"></span> <p>​记录一下原本几分钟的事情，被愚蠢的我硬生生搞了个把小时。</p><p>​    我有一个<strong>网易校园邮箱</strong>，想要登录到手机自带的电子邮件客户端，然后需要填写smtp和imp一些信息。愚蠢的我按着网上的教程进行，怎么也不行，之后发现网易官网是有教程的。</p><blockquote><p><a href="https://qiye.163.com/help/l-12.html">https://qiye.163.com/help/l-12.html</a></p></blockquote><hr><p>​    我说一下大致过程（我用的是IMAP协议）</p><ol><li>在网页版登录账号，在【设置】-&gt;【客户端设置】-&gt;【设置客户端授权密码】点击开启，生成授权密码（密码会以短信形式发送，不记录也没关系）</li><li>点击<a href="https://qiye.163.com/help/l-12.html">客户端设置</a>，选择<strong>手机&#x2F;平板应用设置</strong>，填入账号，之后按建议的填入就行了。</li></ol>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;  校园邮箱是个好东西，他可以让你白嫖许多东西。本文介绍如何登录校园邮箱的客户端。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="email" scheme="https://brraida.github.io/tags/email/"/>
    
  </entry>
  
  <entry>
    <title>递归问题1</title>
    <link href="https://brraida.github.io/posts/d1c9f41/"/>
    <id>https://brraida.github.io/posts/d1c9f41/</id>
    <published>2021-09-07T12:36:45.000Z</published>
    <updated>2022-06-09T14:27:53.588Z</updated>
    
    <content type="html"><![CDATA[<p>​    第一次遇到概率论的问题与编程的递归思维结合的题目，除了新奇的感觉之外，还感受到了数学与代码之间细微的美妙。</p><span id="more"></span><p>​    <img src="/img/article/funAlgorithm/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%92%E5%BD%92%E6%80%9D%E7%BB%B4%E7%BB%93%E5%90%88%E7%9A%84%E9%A2%98%E7%9B%AE.png" alt="题目"></p><p>​    解决这个题目有几个要点，一是定球的位置数量要从大到小；二是定球的位置数量最多的那种情况和次多的情况是一样的，所以不要考虑次多的情况。</p><p>​    有空或是无聊的时候再来补充这个题目的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    第一次遇到概率论的问题与编程的递归思维结合的题目，除了新奇的感觉之外，还感受到了数学与代码之间细微的美妙。&lt;/p&gt;</summary>
    
    
    
    <category term="log" scheme="https://brraida.github.io/categories/log/"/>
    
    
    <category term="algorithm" scheme="https://brraida.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>临时邮箱</title>
    <link href="https://brraida.github.io/posts/b891a459/"/>
    <id>https://brraida.github.io/posts/b891a459/</id>
    <published>2021-09-07T02:03:42.000Z</published>
    <updated>2022-06-09T14:31:08.463Z</updated>
    
    <content type="html"><![CDATA[<p>​有时候只是当时需要获取某网站的信息，但是该网站需要登录邮箱，而选择登录自己的邮箱，一是泄漏了不必要泄漏的信息，二是可能之后会被广告炮轰。所以使用临时邮箱，就有了必要性和实用性。</p><span id="more"></span><blockquote><p>github项目:</p><p><a href="https://github.com/sdushantha/tmpmail">sdushantha&#x2F;tmpmail: A temporary email right from your terminal written in POSIX sh (github.com)</a></p></blockquote><h2 id="centos7安装tmpmail"><a href="#centos7安装tmpmail" class="headerlink" title="centos7安装tmpmail"></a>centos7安装tmpmail</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y w3m curl jq</code></pre></div></figure><h3 id="安装tmpmail"><a href="#安装tmpmail" class="headerlink" title="安装tmpmail"></a>安装tmpmail</h3><p>安装github教程安装</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Download the tmpmail file and make it executablecurl -L &quot;https:&#x2F;&#x2F;git.io&#x2F;tmpmail&quot; &gt; tmpmail &amp;&amp; chmod +x tmpmail# Then move it somewhere in your $PATH. Here is an example:mv tmpmail ~&#x2F;bin&#x2F;</code></pre></div></figure><p>可能和我一样，莫名其妙下载不了，那么可以</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建tmpmail文件并编辑vim tmpmail</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将以下代码复制进入文件#!&#x2F;usr&#x2F;bin&#x2F;env sh# by Siddharth Dushantha 2020## Dependencies: jq, curl, w3m#version&#x3D;1.1.9# By default &#39;tmpmail&#39; uses &#39;w3m&#39; as it&#39;s web browser to render# the HTML of the emailbrowser&#x3D;&quot;w3m&quot;# If the value is set to &#39;true&#39; tmpmail will convert the HTML email# to raw text and send that to stdoutraw_text&#x3D;false# Everything related to &#39;tmpmail&#39; will be stored in &#x2F;tmp&#x2F;tmpmail# so that the old emails and email addresses get cleared after# restarting the computertmpmail_dir&#x3D;&quot;&#x2F;tmp&#x2F;tmpmail&quot;# tmpmail_email_address is where we store the temporary email address# that gets generated. This prevents the user from providing# the email address everytime they run tmpmailtmpmail_email_address&#x3D;&quot;$tmpmail_dir&#x2F;email_address&quot;# tmpmail.html is where the email gets stored.# Even though the file ends with a .html extension, the raw text version of# the email will also be stored in this file so that w3m and other browsers# are able to open this filetmpmail_html_email&#x3D;&quot;$tmpmail_dir&#x2F;tmpmail.html&quot;# Default 1secmail API URLtmpmail_api_url&#x3D;&quot;https:&#x2F;&#x2F;www.1secmail.com&#x2F;api&#x2F;v1&#x2F;&quot;usage() &#123;    # Using &#39;cat &lt;&lt; EOF&#39; we can easily output a multiline text. This is much    # better than using &#39;echo&#39; for each line or using &#39;\n&#39; to create a new line.    cat &lt;&lt;EOFtmpmailtmpmail -h | --versiontmpmail -g [ADDRESS]tmpmail [-t | -b BROWSER] -r | IDWhen called with no option and no argument, tmpmail lists the messages inthe inbox and their numeric IDs.  When called with one argument, tmpmailshows the email message with specified ID.-b, --browser BROWSER        Specify BROWSER (default: w3m) that is used to render the HTML of        the email-g, --generate [ADDRESS]        Generate a new email address, either the specified ADDRESS, or        randomly create one-h, --help        Show help-r, --recent        View the most recent email message-t, --text        View the email as raw text, where all the HTML tags are removed.        Without this option, HTML is used.--version        Show versionEOF&#125;generate_email_address() &#123;    # There are 2 ways which this function is called in this script.    #  [1] The user wants to generate a new email and runs &#39;tmpmail --generate&#39;    #  [2] The user runs &#39;tmpmail&#39; to check the inbox , but &#x2F;tmp&#x2F;tmpmail&#x2F;email_address    #      is empty or nonexistant. Therefore a new email gets automatically    #      generated before showing the inbox. But of course the inbox will    #      be empty as the newly generated email address has not been    #      sent any emails.    #    # When the function &#39;generate_email_address()&#39; is called with the arguement    # &#39;true&#39;, it means that the function was called because the user    # ran &#39;tmpmail --generate&#39;.    #    # We need this variable so we can know whether or not we need to show the user    # what the email was. &lt;-- More about this can be found further down in this function.    externally&#x3D;$&#123;1:-false&#125;    # This variable lets generate_email_address know if the user has provided a custom    # email address which they want to use. custom is set to false if $2 has no value.    custom&#x3D;$&#123;2:-false&#125;    # Generate a random email address.    # This function is called whenever the user wants to generate a new email    # address by running &#39;tmpmail --generate&#39; or when the user runs &#39;tmpmail&#39;    # but &#x2F;tmp&#x2F;tmpmail&#x2F;email_address is empty or nonexistent.    #    # We create a random username by taking the first 10 lines from &#x2F;dev&#x2F;random    # and delete all the characters which are *not* lower case letters from A to Z.    # So charcters such as dashes, periods, underscore, and numbers are all deleted,    # giving us a text which only contains lower case letters form A to Z. We then take    # the first 10 characters, which will be the username of the email address    username&#x3D;$(head &#x2F;dev&#x2F;urandom | LC_ALL&#x3D;C tr -dc &quot;[:alnum:]&quot; | cut -c1-11 | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;)    valid_email_address_regex&#x3D;&quot;[a-z0-9]+@(1secmail\.(com|net|org)|esiix.co|wwjmp.com|xojxe.com|yoggm.com)&quot;    username_black_list_regex&#x3D;&quot;(abuse|webmaster|contact|postmaster|hostmaster|admin)&quot;    username_black_list&#x3D;&quot;- abuse\n- webmaster\n- contact\n- postmaster\n- hostmaster\n- admin&quot;    domains&#x3D;&quot;1secmail.com 1secmail.net 1secmail.org esiix.com wwjmp.com xojxe.com yoggm.com&quot;     # Randomly pick one of the domains mentiond above.    domain&#x3D;$(printf &quot;%b&quot; &quot;$domains&quot; | tr &quot; &quot; &quot;\n&quot; | randomize | tail -1)    email_address&#x3D;&quot;$username@$domain&quot;    # If the user provided a custom email address then use that email address    if [ &quot;$custom&quot; !&#x3D; false ]; then        email_address&#x3D;$custom        # Check if the user is using username in the email address which appears        # in the black list.        if printf %b &quot;$email_address&quot; | grep -Eq &quot;$username_black_list_regex&quot;; then            print_error &quot;For security reasons, that username cannot be used. Here are the blacklisted usernames:\n$username_black_list&quot;        fi        # Do a regex check to see if the email address provided by the user is a        # valid email address        if ! printf %b &quot;$email_address&quot; | grep -Eq &quot;$valid_email_address_regex&quot;; then            print_error &quot;Provided email is invalid. Must match $valid_email_address_regex&quot;        fi    fi    # Save the generated email address to the $tmpmail_email_address file    # so that it can be whenever &#39;tmpmail&#39; is run    printf %s &quot;$email_address&quot; &gt;&quot;$tmpmail_email_address&quot;    # If this function was called because the user wanted to generate a new    # email address, show them the email address    [ &quot;$externally&quot; &#x3D; true ] &amp;&amp; cat &quot;$tmpmail_email_address&quot; &amp;&amp; printf &quot;\n&quot;&#125;get_email_address() &#123;    # This function is only called once and that is when this script    # get executed. The output of this function gets stored in $email_address    #    # If the file that contains the email address is empty,    # that means we do not have an email address, so generate one.    [ ! -s &quot;$tmpmail_email_address&quot; ] &amp;&amp; generate_email_address    # Output the email address by getting the first line of $tmpmail_email    head -n 1 &quot;$tmpmail_email_address&quot;&#125;list_emails() &#123;    # List all the received emails in a nicely formatted order    #    # Fetch the email data using 1secmail&#39;s API    data&#x3D;$(curl -sL &quot;$tmpmail_api_url?action&#x3D;getMessages&amp;login&#x3D;$username&amp;domain&#x3D;$domain&quot;)    # Using &#39;jq&#39; we get the length of the JSON data. From this we can determine whether or not    # the email address has gotten any emails    data_length&#x3D;$(printf %s &quot;$data&quot; | jq length)    # We are showing what email address is currently being used    # in case the user has forgotten what the email address was.    printf &quot;[ Inbox for %s ]\n\n&quot; &quot;$email_address&quot;    # If the length of the data we got is 0, that means the email address    # has not received any emails yet.    [ &quot;$data_length&quot; -eq 0 ] &amp;&amp; echo &quot;No new mail&quot; &amp;&amp; exit    # This is where we store all of our emails, which is then    # displayed using &#39;column&#39;    inbox&#x3D;&quot;&quot;    # Go through each mail that has been received    index&#x3D;1    while [ $index -le &quot;$&#123;data_length&#125;&quot; ]; do        # Since arrays in JSON data start at 0, we must subtract        # the value of $index by 1 so that we dont miss one of the        # emails in the array        mail_data&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.[$index-1]&quot;)        id&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.id&quot;)        from&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.from&quot;)        subject&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.subject&quot;)        # The &#39;||&#39; are used as a divideder for &#39;column&#39;. &#39;column&#39; will use this divider as        # a point of reference to create the division. By default &#39;column&#39; uses a blank space        # but that would not work in our case as the email subject could have multiple white spaces        # and &#39;column&#39; would split the words that are seperated by white space, in different columns.        inbox&#x3D;&quot;$inbox$id ||$from ||$subject\n&quot;        index&#x3D;$((index + 1))    done    # Show the emails cleanly    printf &quot;%b&quot; &quot;$inbox&quot; | column -t -s &quot;||&quot;&#125;randomize() &#123;    # We could use &#39;shuf&#39; and &#39;sort -R&#39; but they are not a part of POSIX    awk &#39;BEGIN &#123;srand();&#125; &#123;print rand(), $0&#125;&#39; | \        sort -n -k1 | cut -d&#39; &#39; -f2&#125;view_email() &#123;    # View an email by providing it&#39;s ID    #    # The first argument provided to this function will be the ID of the email    # that has been received    email_id&#x3D;&quot;$1&quot;    data&#x3D;$(curl -sL &quot;$tmpmail_api_url?action&#x3D;readMessage&amp;login&#x3D;$username&amp;domain&#x3D;$domain&amp;id&#x3D;$email_id&quot;)    # After the data is retrieved using the API, we have to check if we got any emails.    # Luckly 1secmail&#39;s API is not complicated and returns &#39;Message not found&#39; as plain text    # if our email address as not received any emails.    # If we received the error message from the API just quit because there is nothing to do    [ &quot;$data&quot; &#x3D; &quot;Message not found&quot; ] &amp;&amp; print_error &quot;Message not found&quot;    # We pass the $data to &#39;jq&#39; which extracts the values    from&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.from&quot;)    subject&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.subject&quot;)    html_body&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.htmlBody&quot;)    attachments&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.attachments | length&quot;)        # If you get an email that is in pure text, the .htmlBody field will be empty and    # we will need to get the content from .textBody instead    [ -z &quot;$html_body&quot; ] &amp;&amp; html_body&#x3D;&quot;&lt;pre&gt;$(printf %s &quot;$data&quot; | jq -r &quot;.textBody&quot;)&lt;&#x2F;pre&gt;&quot;    # Create the HTML with all the information that is relevant and then    # assigning that HTML to the variable html_mail. This is the best method    # to create a multiline variable    html_mail&#x3D;$(cat &lt;&lt;EOF&lt;pre&gt;&lt;b&gt;To: &lt;&#x2F;b&gt;$email_address&lt;b&gt;From: &lt;&#x2F;b&gt;$from&lt;b&gt;Subject: &lt;&#x2F;b&gt;$subject&lt;&#x2F;pre&gt;$html_bodyEOF)        if [ ! &quot;$attachments&quot; &#x3D; &quot;0&quot; ]; then        html_mail&#x3D;&quot;$html_mail&lt;br&gt;&lt;b&gt;[Attachments]&lt;&#x2F;b&gt;&lt;br&gt;&quot;        index&#x3D;1        while [ &quot;$index&quot; -le &quot;$attachments&quot; ]; do            filename&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.attachments | .[$index-1] | .filename&quot;)            link&#x3D;&quot;$tmpmail_api_url?action&#x3D;download&amp;login&#x3D;$username&amp;domain&#x3D;$domain&amp;id&#x3D;$email_id&amp;file&#x3D;$filename&quot;            html_link&#x3D;&quot;&lt;a href&#x3D;$link download&#x3D;$filename&gt;$filename&lt;&#x2F;a&gt;&lt;br&gt;&quot;            if [ &quot;$raw_text&quot; &#x3D; true ]; then                # The actual url is way too long and does not look so nice in STDOUT.                # Therefore we will shortening it using is.gd so that it looks nicer.                link&#x3D;$(curl -s -F&quot;url&#x3D;$link&quot; &quot;https:&#x2F;&#x2F;is.gd&#x2F;create.php?format&#x3D;simple&quot;)                html_mail&#x3D;&quot;$html_mail$link  [$filename]&lt;br&gt;&quot;            else                html_mail&#x3D;&quot;$html_mail$html_link&quot;            fi            index&#x3D;$((index + 1))        done    fi    # Save the $html_mail into $tmpmail_html_email    printf %s &quot;$html_mail&quot; &gt;&quot;$tmpmail_html_email&quot;    # If the &#39;--text&#39; flag is used, then use &#39;w3m&#39; to convert the HTML of    # the email to pure text by removing all the HTML tags    [ &quot;$raw_text&quot; &#x3D; true ] &amp;&amp; w3m -dump &quot;$tmpmail_html_email&quot; &amp;&amp; exit    # Open up the HTML file using $browser. By default,    # this will be &#39;w3m&#39;.    $browser &quot;$tmpmail_html_email&quot;&#125;view_recent_email() &#123;    # View the most recent email.    #    # This is done by listing all the received email like you    # normally see on the terminal when running &#39;tmpmail&#39;.    # We then grab the ID of the most recent    # email, which the first line.    mail_id&#x3D;$(list_emails | head -3 | tail -1 | cut -d&#39; &#39; -f 1)    view_email &quot;$mail_id&quot;&#125;print_error() &#123;    # Print error message    #    # The first argument provided to this function will be the error message.    # Script will exit after printing the error message.    printf &quot;%b\n&quot; &quot;Error: $1&quot; &gt;&amp;2    exit 1&#125;main() &#123;    # Iterate of the array of dependencies and check if the user has them installed.    # We are checking if $browser is installed instead of checking for &#39;w3m&#39;. By doing    # this, it allows the user to not have to install &#39;w3m&#39; if they are using another    # browser to view the HTML    for dependency in jq $browser curl; do        if ! command -v &quot;$dependency&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1; then            print_error &quot;Could not find &#39;$dependency&#39;, is it installed?&quot;        fi    done    # Create the $tmpmail_dir directory and dont throw any errors    # if it already exists    mkdir -p &quot;$tmpmail_dir&quot;    # Get the email address and save the value to the email_address variable    email_address&#x3D;&quot;$(get_email_address)&quot;    # $&#123;VAR#PATTERN&#125; Removes shortest match of pattern from start of a string.    # In this case, it takes the email_address and removed everything after    # the &#39;@&#39; symbol which gives us the username.    username&#x3D;$&#123;email_address%@*&#125;    # $&#123;VAR%PATTERN&#125; Remove shortest match of pattern from end of a string.    # In this case, it takes the email_address and removes everything until the    # period &#39;.&#39; which gives us the domain    domain&#x3D;$&#123;email_address#*@&#125;    # If no arguments are provided just the emails    [ $# -eq 0 ] &amp;&amp; list_emails &amp;&amp; exit    while [ &quot;$1&quot; ]; do        case &quot;$1&quot; in            --help | -h) usage &amp;&amp; exit ;;            --generate | -g) generate_email_address true &quot;$2&quot; &amp;&amp; exit ;;            --browser | -b) browser&#x3D;&quot;$2&quot; ;;            --text | -t) raw_text&#x3D;true ;;            --version) echo &quot;$version&quot; &amp;&amp; exit ;;            --recent | -r) view_recent_email &amp;&amp; exit ;;            *[0-9]*)                # If the user provides number as an argument,                # assume its the ID of an email and try getting                # the email that belongs to the ID                view_email &quot;$1&quot; &amp;&amp; exit                ;;            -*) print_error &quot;option &#39;$1&#39; does not exist&quot; ;;        esac        shift    done&#125;main &quot;$@&quot;</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将文件变成可执行文件chmod +x tmpmail# 移动文件到系统或是用户的路径下(&#x2F;usr&#x2F;bin 或 &#x2F;usr&#x2F;local&#x2F;bin)mv tmpmail &#x2F;usr&#x2F;local&#x2F;bin</code></pre></div></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 生成邮箱tmpmail# 重新生成邮箱tmpmail --generate# 查看邮箱有无邮件tmpmail# 以文本显示邮件信息tmpmail -t &lt;ID&gt;</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	有时候只是当时需要获取某网站的信息，但是该网站需要登录邮箱，而选择登录自己的邮箱，一是泄漏了不必要泄漏的信息，二是可能之后会被广告炮轰。所以使用临时邮箱，就有了必要性和实用性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="tools" scheme="https://brraida.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>hexo的一些记录</title>
    <link href="https://brraida.github.io/posts/7d2eca9c/"/>
    <id>https://brraida.github.io/posts/7d2eca9c/</id>
    <published>2021-09-02T05:54:37.000Z</published>
    <updated>2022-06-10T03:58:33.270Z</updated>
    
    <content type="html"><![CDATA[<p>​    对hexo的一些记录。</p><span id="more"></span><h2 id="优化url"><a href="#优化url" class="headerlink" title="优化url"></a>优化url</h2><p>使url看得更顺眼，但要使用插件，这可能一定程度上使网页加载速度变慢。</p><p>使用<code>hexo-abbrlink</code>插件</p><blockquote><p>官方的安装与配置</p><p><a href="https://github.com/rozbo/hexo-abbrlink">rozbo&#x2F;hexo-abbrlink: create one and only link for every post for hexo (github.com)</a></p></blockquote><h2 id="去除LF与CRLF警告"><a href="#去除LF与CRLF警告" class="headerlink" title="去除LF与CRLF警告"></a>去除LF与CRLF警告</h2><p>在gitbash中输入即可<code>git config --global core.autocrlf false</code>。</p><blockquote><p><a href="https://xfdj.github.io/2019/02/09/%E4%BC%98%E5%8C%96%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9Awarning-LF-will-be-replaced-by-CRLF%E7%9A%84%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95/">优化博客（十一）：warning: LF will be replaced by CRLF 的去除方法 | 兴趣使然的博客 (xfdj.github.io)</a></p></blockquote><h2 id="更新hexo"><a href="#更新hexo" class="headerlink" title="更新hexo"></a>更新hexo</h2><ul><li><p>在<a href="https://github.com/hexojs/hexo/releases">Releases </a>中找所需要的版本</p></li><li><p><code>npm i hexo@6.2.0</code>（在管理员模式下）</p></li></ul><h2 id="快"><a href="#快" class="headerlink" title="快"></a>快</h2><p><a href="http://www.julydate.com/post/60859300/">hexo博客访问优化-CND选用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    对hexo的一些记录。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://brraida.github.io/categories/hexo/"/>
    
    
    <category term="optimize" scheme="https://brraida.github.io/tags/optimize/"/>
    
  </entry>
  
  <entry>
    <title>制作hexo博客的rss源</title>
    <link href="https://brraida.github.io/posts/d56f63a7/"/>
    <id>https://brraida.github.io/posts/d56f63a7/</id>
    <published>2021-09-02T03:49:52.000Z</published>
    <updated>2022-06-09T14:39:04.129Z</updated>
    
    <content type="html"><![CDATA[<p>为自己的hexo博客制作rss源。</p><span id="more"></span><p>使用的是hexo的<code>hexo-generator-feed</code>插件。</p><blockquote><p>官方文档与相关配置信息链接:</p><p><a href="https://github.com/hexojs/hexo-generator-feed">hexojs&#x2F;hexo-generator-feed: Feed generator for Hexo. (github.com)</a></p></blockquote><p>在_config.yml文件中,在Extensions中添加配置（便于管理）。</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Feed Atomfeed:  enable: true  type: atom  path: atom.xml  limit: false  hub:  content: true  content_limit:   content_limit_delim:   order_by: -date  icon:   autodiscovery: true  template:</code></pre></div></figure><p>​    运行<code>hexo clean &amp;&amp; hexo g</code>，即可在根目录下看到public文件夹，在public文件夹下有atom.xml则制作成功。    </p><p>​在自己的博客主页地址后面加**&#x2F;atom.xml**，即可看源信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为自己的hexo博客制作rss源。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://brraida.github.io/categories/hexo/"/>
    
    
    <category term="rss" scheme="https://brraida.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>右键新建Markdown文件</title>
    <link href="https://brraida.github.io/posts/dedab3/"/>
    <id>https://brraida.github.io/posts/dedab3/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2022-06-09T14:47:11.677Z</updated>
    
    <content type="html"><![CDATA[<p>​为了使用markdown更顺手些，创建一个右键快捷键。</p><span id="more"></span><p>新建一个<code>txt</code>文本，写入:</p><figure><div class="code-wrapper"><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\.md]@&#x3D;&quot;Typora.md&quot;&quot;Content Type&quot;&#x3D;&quot;text&#x2F;markdown&quot;&quot;PerceivedType&quot;&#x3D;&quot;text&quot;[HKEY_CLASSES_ROOT\.md\ShellNew]&quot;NullFile&quot;&#x3D;&quot;&quot;</code></pre></div></figure><p>然后修改<code>.txt</code>后缀为  <code>.reg</code>的注册表文件。</p><p>双击运行。</p><p>参考链接:</p><blockquote><p><a href="https://www.cnblogs.com/zhoujiayingvana/p/12357812.html">Typora添加右键新建Markdown文件 - 墨莲玦 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	为了使用markdown更顺手些，创建一个右键快捷键。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    
    <category term="Markdown" scheme="https://brraida.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>使用docker建立ttrss</title>
    <link href="https://brraida.github.io/posts/b4463054/"/>
    <id>https://brraida.github.io/posts/b4463054/</id>
    <published>2021-08-02T01:05:54.000Z</published>
    <updated>2022-06-09T14:49:11.994Z</updated>
    
    <content type="html"><![CDATA[<p>​    第一次部署ttrss可能没有那么简单，需要耐点心。</p><span id="more"></span><p>​    我不用宝塔面板，环境都是自己搭的，所以会需要很多时间。用宝塔面板会比较简单(本来之后想搞宝塔面板的，但是我已经尝试安装许多环境，而宝塔面板的官方文档说要“干净”的操作系统，由此作罢。)</p><blockquote><p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html">宝塔Linux面板安装教程 - 2021年6月4日更新 - 7.6.0正式版 - Linux面板 - 宝塔面板论坛 (bt.cn)</a></p></blockquote><p>这位大佬就是用宝塔面板搞定的，还有<strong>视频教程</strong>，很nice。</p><blockquote><p><a href="https://blog.laoda.de/archives/tinytinyrss">【服务器能干什么】二十分钟搭建一个属于自己的RSS服务 - 二十五画生 (laoda.de)</a></p></blockquote><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><p>一台服务器 (我用的是腾讯云)</p></li><li><p>一个已经能解析的域名 (在这里用于隐藏端口和上ssl证书)</p></li><li><p>nginx (用于反向代理)</p></li><li><p>docker (下载镜像)</p></li><li><p>docker-compose (用于执行一堆docker指令)</p></li></ul><hr><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>  我也没有搞得很清楚，就谈谈我已知的。首先说明一点，可以不用域名，直接使用 <strong>IP:port</strong> 来进行访问，但是我记得ttrss有说，信息传输是不安全的，推荐上ssl。然后也看到诸多大佬教程都进行了https的配置。</p><p>  OK，言归正传。根据</p><blockquote><p><a href="https://cloud.tencent.com/document/product/243/19630#.E6.98.AF.E5.90.A6.E9.9C.80.E8.A6.81.E5.A4.87.E6.A1.88.E7.9A.84.E5.88.A4.E6.96.AD.E6.9D.A1.E4.BB.B6.E6.98.AF.E5.9F.9F.E5.90.8D.E8.BF.98.E6.98.AF-80-.E7.AB.AF.E5.8F.A3.EF.BC.9F">网站备案 是否需要备案 - 常见问题 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><p>中的<img src="/img/article/ttrss/%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88.png">这些信息，可知内陆服务器要进行web服务是需要备案的。所以我觉得如果搞个人网站的话，推荐香港服务器。</p><blockquote><p><a href="https://cloud.tencent.com/document/product/243/19633">网站备案 备案流程 - 常见问题 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><hr><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>官网安装教程:</p><blockquote><p><a href="https://nginx.org/en/linux_packages.html#RHEL-CentOS">nginx: Linux packages</a></p></blockquote><hr><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker安装教程</p><blockquote><p><a href="https://cloud.tencent.com/document/product/213/46000">云服务器 搭建 Docker - 最佳实践 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><hr><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>docker-compose安装教程</p><blockquote><p><a href="https://docs.docker.com/compose/install/">Install Docker Compose | Docker Documentation</a></p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>ttrss官网教程</p><p><a href="https://ttrss.henry.wang/zh/">🐋 Awesome TTRSS | 🐋 Awesome TTRSS (henry.wang)</a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载[docker-compose.yml](<a href="https://github.com/HenryQW/Awesome-TTRSS/blob/main/docker-compose.yml">Awesome-TTRSS&#x2F;docker-compose.yml at main · HenryQW&#x2F;Awesome-TTRSS (github.com)</a>)到一目录下。</p><p>用网上教程命令不行，我也不懂git命令。然后就粗暴的在根目录下创建了ttrss文件夹，命令如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir ttrsscd ttrss</code></pre></div></figure><p>然后在Windows下创建一个docker-compose.yml ,将代码复制进去，然后使用<strong>xftp 7</strong>上传文件到linux的ttrss目录下。(解释一下为什么不直接在ttrss下创建docker-compose.yml，然后复制代码到docker-compose.yml中。首先yaml文件是对空格敏感的；其次，我复制的时候，shell自动将最后后面几行自动注释了。启动配置就失败了，改空格又麻烦，所以就直接用xftp 7了。)</p><p>docker-compose.yml文件配置:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version: &quot;3&quot;services:  service.rss:    image: wangqiru&#x2F;ttrss:latest    container_name: ttrss    ports:      - 181:80    environment:      - SELF_URL_PATH&#x3D;http:&#x2F;&#x2F;localhost:181&#x2F; # please change to your own domain      - DB_PASS&#x3D;ttrss # use the same password defined in &#96;database.postgres&#96;      - PUID&#x3D;1000      - PGID&#x3D;1000    volumes:      - feed-icons:&#x2F;var&#x2F;www&#x2F;feed-icons&#x2F;    networks:      - public_access      - service_only      - database_only    stdin_open: true    tty: true    restart: always  service.mercury: # set Mercury Parser API endpoint to &#96;service.mercury:3000&#96; on TTRSS plugin setting page    image: wangqiru&#x2F;mercury-parser-api:latest    container_name: mercury    networks:      - public_access      - service_only    restart: always  service.opencc: # set OpenCC API endpoint to &#96;service.opencc:3000&#96; on TTRSS plugin setting page    image: wangqiru&#x2F;opencc-api-server:latest    container_name: opencc    environment:      - NODE_ENV&#x3D;production    networks:      - service_only    restart: always  database.postgres:    image: postgres:13-alpine    container_name: postgres    environment:      - POSTGRES_PASSWORD&#x3D;ttrss # feel free to change the password    volumes:      - ~&#x2F;postgres&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data # persist postgres data to ~&#x2F;postgres&#x2F;data&#x2F; on the host    networks:      - database_only    restart: always  # utility.watchtower:  #   container_name: watchtower  #   image: containrrr&#x2F;watchtower:latest  #   volumes:  #     - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  #   environment:  #     - WATCHTOWER_CLEANUP&#x3D;true  #     - WATCHTOWER_POLL_INTERVAL&#x3D;86400  #   restart: alwaysvolumes:  feed-icons:networks:  public_access: # Provide the access for ttrss UI  service_only: # Provide the communication network between services only    internal: true  database_only: # Provide the communication between ttrss and database only    internal: true</code></pre></div></figure><p>主要修改的地方是第九行,将localhost改成ip地址，其他可以先不动。先激动的试试行不行。</p></li><li><p>启动</p><p>在ttrss目录下执行如下命令:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose up -d</code></pre></div></figure><p>第一次会下载一些镜像，花费时间就一点。</p></li><li><p>查看</p><p>查看启动的镜像</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker ps</code></pre></div></figure><p><img src="/img/article/ttrss/ttrss.png"></p><p>访问端口ip:181，可以就说明没什么问题了。</p><p>P.S. 为了安全，改一下第10行和第44行的密码，并且密码要一致。</p><p>重载docker-compose.yml，得先停、再编写、最后重启</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compse down #stopvim docker-compose.yml #writedocker-compose up -d #start</code></pre></div></figure></li></ol><hr><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p>​    ok,以上就搞定了可以使用ip加端口部署ttrss。</p><p>​    下面介绍的是nginx反向代理和上ssl锁。</p><p>​    我用的是腾讯云的域名，然后可以直接申请一个免费的ssl证书。</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>如果你是安装nginx官网安装的话，nginx的配置文件在&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。(想说一点，官网配置中，location块是分开的，和网上教程不太一样，目的是便于管理。不知道也无所谓。)</p><p>参考文档:</p><blockquote><p><a href="https://cloud.tencent.com/document/product/400/35244">SSL 证书 Nginx 服务器 SSL 证书安装部署 - 证书安装 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><p>因为是分开的，所以以上文档成了参考文档(不过，也差不多)。</p><ol><li><p>nginx.conf配置</p><p>在hhtp块下加上以下代码(也可以选择替换# Settings for a TLS enabled server.这注释下面的代码。)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;    listen 443 ssl;    server_name sisilly.club;    ssl_certificate 1_sisilly.club_bundle.crt;    ssl_certificate_key 2_sisilly.club.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;#    location &#x2F; &#123;#        root html; #        index  index.html index.htm;#    &#125;&#125;</code></pre></div></figure></li><li><p>location块配置</p><p>在default.d目录下创建一个ttrss.conf</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;ttrss.conf# bashlocation &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;127.0.0.1:181&#x2F;;    rewrite ^&#x2F;(.*)$ &#x2F;$1 break;    proxy_redirect off;    proxy_set_header Host $host;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Upgrade-Insecure-Requests 1;    proxy_set_header X-Forwarded-Proto https;  &#125;</code></pre></div></figure></li><li><p>测试、启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -tservice nginx start</code></pre></div></figure><p>可能会报警告，只要在nginx.conf中的http块下加</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_headers_hash_max_size 51200;proxy_headers_hash_bucket_size 6400;</code></pre></div></figure></li></ol><h3 id="ttrss的docker-compose-yml配置"><a href="#ttrss的docker-compose-yml配置" class="headerlink" title="ttrss的docker-compose.yml配置"></a>ttrss的docker-compose.yml配置</h3><p>​    将 第九行- SELF_URL_PATH&#x3D;<a href="http://localhost:181/%EF%BC%8C%E6%94%B9%E6%88%90-">http://localhost:181/，改成-</a> SELF_URL_PATH&#x3D;https:&#x2F;&#x2F;域名&#x2F;</p><p>  至此，结束。后面就是ttrss的配置了。可以看大佬文章。<a href="https://blog.laoda.de/archives/tinytinyrss">【服务器能干什么】二十分钟搭建一个属于自己的RSS服务 - 二十五画生 (laoda.de)</a></p><p>你可能需要:</p><blockquote><p>[Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx配置文件详解</a>. Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为 全局块、events块和http块 。. 在http块中，又包含http全局块、多个server块。.,每个server块中，可以包含server全局块和多个location块。. 在同一配置块中嵌套的配置块，各个之间不存在次序关系。. 配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。. 同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。. 如果某个指令在两个不同层级的块中同时出现，则采用”就近原则”，即以较低层级块中的配置为准。.)</p></blockquote><hr><p>2021-08-21</p><p>​    实践之后进行理论填充。之前搭建的ttrss是没有开启防火墙的情况下，看了一些书籍之后，感受到了安全的重要性。所以进行防火墙的补充、遇到问题的解决办法和懒人脚本补充。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status firewalld # 防火墙状态systemctl stop firewalld   # 防火墙关闭systemctl start firewalld  # 防火墙开启firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent # 打开80端口firewall-cmd --list-all    # 查看防火墙开启的端口</code></pre></div></figure><p>问题：PostgreSQL: Could not connect to server: TCP&#x2F;IP connections on port 5432</p><p>​    ttrss用的是PostgreSQL，所以别忘记开5432端口。开启后，运行<code>docker-compose down</code>，将容器停下来，然后运行<code>service docker restart</code>，不然可能遇到<strong>ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule</strong>，然后就可以运行<code>docker-compose up -d</code>了。</p><p>​    大佬做好的一键安装脚本，容我膜拜一下。</p><blockquote><p><a href="https://www.ioiox.com/archives/139.html">https://www.ioiox.com/archives/139.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    第一次部署ttrss可能没有那么简单，需要耐点心。&lt;/p&gt;</summary>
    
    
    
    
    <category term="rss" scheme="https://brraida.github.io/tags/rss/"/>
    
    <category term="ttrss" scheme="https://brraida.github.io/tags/ttrss/"/>
    
  </entry>
  
  <entry>
    <title>安装-redis</title>
    <link href="https://brraida.github.io/posts/6bcf3639/"/>
    <id>https://brraida.github.io/posts/6bcf3639/</id>
    <published>2021-07-22T11:05:58.000Z</published>
    <updated>2022-06-09T15:07:39.440Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>该博客写于2021年7月22号</p>          </div><span id="more"></span><p>腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>按官网的来就OK了。</p><p><a href="http://www.redis.cn/download.html">redis 6.0.6 下载 – Redis中国用户组（CRUG）</a></p><ol><li>下载、解压、编译</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.6.tar.gztar xzf redis-6.0.6.tar.gz -C &#x2F;usr&#x2F;localcd &#x2F;usr&#x2F;local&#x2F;redis-6.0.6make</code></pre></div></figure><ol start="2"><li>启动redis</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;src&#x2F;redis-server</code></pre></div></figure><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>​    主要是想讲这个，害，刚开始的时候，嫌麻烦，没弄。然后就被6379这个端口给搞了。</p><p>​    配置文件为redis.conf。</p><ol><li><p>更改端口</p><p>将port 6379改成其他端口号</p></li><li><p>以后台进程方式启动</p><p>修改daemonize no 为 daemonize yes</p><ol start="3"><li>设置redis远程连接、</li></ol><ul><li><p>如果选择不关闭防火墙，先放行端口</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --zone&#x3D;public --add-port&#x3D;8888&#x2F;tcp --permanentfire-cmd --reload</code></pre></div></figure></li><li><p>如果用的是云服务器，你还需要放行安全组防火墙端口。</p></li><li><p>注释掉bind 127.0.0.1</p></li><li><p>设置redis远程连接密码:在requirepass foobard改成requirepass <your password></p></li></ul></li><li><p>启动redis,若redis已经启动，则先关闭。</p><p>查找redis的进程号:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -aux | grep redis</code></pre></div></figure><p>杀死进程:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kill -9 &lt;PID&gt;</code></pre></div></figure><p>启动新配置的redis:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;src&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;redis.conf</code></pre></div></figure></li></ol><p><a href="https://baijiahao.baidu.com/s?id=1667197295239073048&wfr=spider&for=pc">（史上最详细）CentOS7环境下Redis安装部署 (baidu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note note-warning&quot;&gt;
            &lt;p&gt;该博客写于2021年7月22号&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="redis" scheme="https://brraida.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>进程挂起不占内存</title>
    <link href="https://brraida.github.io/posts/c4a439f8/"/>
    <id>https://brraida.github.io/posts/c4a439f8/</id>
    <published>2021-07-08T01:22:18.000Z</published>
    <updated>2022-06-09T15:12:05.449Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天我想一个进程挂起，cpu要监督，所以简单的就想这个进程肯定有一部分是要占用内存的。其实，不然，cpu和内存是不能等价的。</p><p>​    进程挂起的结果是从内存转移到外存，所以<strong>挂起不占内存</strong>的。</p><span id="more"></span><blockquote><p><a href="https://blog.csdn.net/weixin_37641832/article/details/83217104">操作系统——CPU和内存、挂起和阻塞_My Blogs-CSDN博客_挂起不释放cpu</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    今天我想一个进程挂起，cpu要监督，所以简单的就想这个进程肯定有一部分是要占用内存的。其实，不然，cpu和内存是不能等价的。&lt;/p&gt;
&lt;p&gt;​    进程挂起的结果是从内存转移到外存，所以&lt;strong&gt;挂起不占内存&lt;/strong&gt;的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="os" scheme="https://brraida.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>hadoop&amp;spark安装</title>
    <link href="https://brraida.github.io/posts/1426aaf4/"/>
    <id>https://brraida.github.io/posts/1426aaf4/</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2022-06-09T15:19:23.402Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>该博文写于2021-6-21</p>          </div><p><strong>环境：腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</strong></p><h1 id="1-jdk下载与安装"><a href="#1-jdk下载与安装" class="headerlink" title="1.jdk下载与安装"></a>1.jdk下载与安装</h1><h2 id="1-1选择jdk"><a href="#1-1选择jdk" class="headerlink" title="1.1选择jdk"></a>1.1选择jdk</h2><p><img src="/img/article/hadoop&spark/Hadoop-%E9%80%89%E6%8B%A9jdk.png">                         </p><p>由Hadoop官方文档可知，最好下载java8。</p><p>下载： </p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;java&#x2F;jdk&#x2F;8u181-b13&#x2F;jdk-8u181-linux-x64.tar.gz</code></pre></div></figure><h2 id="1-2解压"><a href="#1-2解压" class="headerlink" title="1.2解压"></a>1.2解压</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar zxvf jdk-8u181-linux-x64.tar.gz &#x2F;usr&#x2F;local  #安装软件最好这个位置，便于管理</code></pre></div></figure><h2 id="1-3重命名"><a href="#1-3重命名" class="headerlink" title="1.3重命名"></a>1.3重命名</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv jdk-8u181-linux-x64.tar.gz jdk8 </code></pre></div></figure><h2 id="1-4环境配置"><a href="#1-4环境配置" class="headerlink" title="1.4环境配置"></a>1.4环境配置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> vim ~&#x2F;.bashrc #默认你下了vim了# java environmentexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libexport PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH# :wq保存退出</code></pre></div></figure><h2 id="1-5环境变量生效"><a href="#1-5环境变量生效" class="headerlink" title="1.5环境变量生效"></a>1.5环境变量生效</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source ~.&#x2F;bashrc</code></pre></div></figure><h2 id="1-6验证"><a href="#1-6验证" class="headerlink" title="1.6验证"></a>1.6验证</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -version</code></pre></div></figure><p>  PS：</p><p>​    1.如果之前安装过jdk，然后查询的java版本与下载的不一样，可能在”&#x2F;etc&#x2F;profile”设置了永久生效的环境变量。只要编辑”&#x2F;etc&#x2F;profile”中的相关内容就行了。</p><p>​    2.java8就是java1.8.x系列。</p><hr><h1 id="2-Hadoop作用、安装与配置"><a href="#2-Hadoop作用、安装与配置" class="headerlink" title="2.Hadoop作用、安装与配置"></a>2.Hadoop作用、安装与配置</h1><p>  <strong>是一个能够对大量数据进行分布式处理的软件框架。</strong></p><h2 id="2-1-Hadoop下载"><a href="#2-1-Hadoop下载" class="headerlink" title="2.1 Hadoop下载"></a>2.1 Hadoop下载</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;mirrors.bfsu.edu.cn&#x2F;apache&#x2F;hadoop&#x2F;common&#x2F;stable&#x2F;hadoop-3.3.0.tar.gz</code></pre></div></figure><h2 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar zxvf hadoop-3.3.0.tar.gz &#x2F;usr&#x2F;local</code></pre></div></figure><h2 id="2-3-重命名"><a href="#2-3-重命名" class="headerlink" title="2.3 重命名"></a>2.3 重命名</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv hadoop-3.3.0 hadoop</code></pre></div></figure><h2 id="2-4-环境变量设置"><a href="#2-4-环境变量设置" class="headerlink" title="2.4 环境变量设置"></a>2.4 环境变量设置</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~.&#x2F;bashrc# hadoop environmentexport HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoopexport HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;nativeexport PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbinexport JAVA_LIBRAY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;lib&#x2F;native# :wq 保存退出</code></pre></div></figure><h2 id="2-5-环境变量生效"><a href="#2-5-环境变量生效" class="headerlink" title="2.5 环境变量生效"></a>2.5 环境变量生效</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source ~.&#x2F;bashrc</code></pre></div></figure><h2 id="2-6-验证"><a href="#2-6-验证" class="headerlink" title="2.6 验证"></a>2.6 验证</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hadoop version</code></pre></div></figure><hr><h1 id="3-Hadoop伪分布式模式配置"><a href="#3-Hadoop伪分布式模式配置" class="headerlink" title="3.Hadoop伪分布式模式配置"></a>3.Hadoop伪分布式模式配置</h1><h2 id="3-1-Hadoop目录结构"><a href="#3-1-Hadoop目录结构" class="headerlink" title="3.1 Hadoop目录结构:"></a>3.1 Hadoop目录结构:</h2><ol><li><p>bin(工具程序目录) </p></li><li><p>etc&#x2F;hadoop(配置文件目录)</p></li><li><p>sbin(服务程序目录，主要为服务启停脚本)</p></li><li><p>…(其他暂时用不到)</p></li></ol><h2 id="3-2-修改各种配置文件-etc-x2F-hadoop"><a href="#3-2-修改各种配置文件-etc-x2F-hadoop" class="headerlink" title="3.2 修改各种配置文件(etc&#x2F;hadoop)"></a>3.2 修改各种配置文件(etc&#x2F;hadoop)</h2><ul><li>修改hadoop-env.sh</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8# 解决Unable to load native-hadoop library for your platform...export HADOOP_OPTS&#x3D;&quot;-Djava.library.path&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;lib&#x2F;native&quot;</code></pre></div></figure><ul><li>修改core-site.xml</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;configuration&gt;     &lt;property&gt;       &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;       &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;       &lt;description&gt;Abase for other temporary directories.&lt;&#x2F;description&gt;     &lt;&#x2F;property&gt;     &lt;property&gt;       &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;       &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;      &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div></figure><ul><li>修改hdfs-site.xml</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;configuration&gt;    &lt;property&gt;       &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;       &lt;value&gt;1&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div></figure><h2 id="3-3-测试HDFS"><a href="#3-3-测试HDFS" class="headerlink" title="3.3 测试HDFS"></a>3.3 测试HDFS</h2><ul><li>NameNode格式化</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin&#x2F;hdfs namenode –format</code></pre></div></figure><ul><li>启动ssh</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service sshd start</code></pre></div></figure><ul><li>启动dfs</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-dfs.shjps</code></pre></div></figure><p>​    以上是正确结果，在启动过程中可能会遇到:</p><ul><li>问题1：Error: Attempting to operate on hdfs namenode as root…</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%981.png"></p><p>​    原因：</p><blockquote><p>hadoop install for different user and you start yarn service for different user. OR in hadoop config’s hadoop-env.sh specified HDFS_NAMENODE_USER and HDFS_DATANODE_USER  user is something else.</p></blockquote><p>​    解决方法:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;etc&#x2F;profile#在profile中填加以下内容export HDFS_NAMENODE_USER&#x3D;rootexport HDFS_DATANODE_USER&#x3D;rootexport HDFS_SECONDARYNAMENODE_USER&#x3D;rootexport YARN_RESOURCEMANAGER_USER&#x3D;rootexport YARN_NODEMANAGER_USER&#x3D;root#:wq 保存#生效source &#x2F;etc&#x2F;profile</code></pre></div></figure><p>​    参考链接：</p><p><a href="https://blog.csdn.net/weixin_49736959/article/details/108897129">两种解决ERROR: Attempting to operate on hdfs namenode as root的方法_世幻水的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ystyaoshengting/article/details/103026872">ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation._ystyaoshengting的专栏-CSDN博客</a></p><ul><li>问题2：Permission denied…</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%982.png"></p><p>​    原因：</p><p>​    ssh下的文件有访问权限</p><p>​    解决方法:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 进行免密协议设置:cd ~&#x2F;.ssh&#x2F;           # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa       # 会有提示，都按回车就可以cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权chmod 600 .&#x2F;authorized_keys  # 修改文件权限chmod 600 .&#x2F;id_rsachmod 644 id_rsa.pubchmod 644 .&#x2F;known_hosts #我第一次修改的时候有这个文件夹，第二次就没有。不过对后面配置不影响。# 修改sshd_config文件HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_keyRSAAuthentication yes  #这句没有，找的地方加上就行PubkeyAuthentication yesAuthorizedKeysFile .ssh&#x2F;authorized_keys# :wq保存# 命令行输入service sshd restart</code></pre></div></figure><ul><li>问题3：无NameNode</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%983.png"></p><p>​    原因：查阅说是多次初始化造成的。</p><p>​    解决方法:</p><ol><li><p>首先</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;stop-all.sh</code></pre></div></figure></li><li><p>删除原先创建的目录，即core-site.xml下配置的<name>hadoop.tmp.dir</name>所指向的目录。（我这里就是tmp目录）删除后要重新建立tmp空白目录。</p></li><li><p>格式化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin&#x2F;hadoop namenode -format</code></pre></div></figure></li><li><p>启动</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-all.sh</code></pre></div></figure></li><li><p>用jsp查询时，就能看到NameNode进程</p><p><img src="/img/article/hadoop&spark/%E6%AD%A3%E7%A1%AE%E7%BB%93%E6%9E%9C.png"></p></li></ol><h2 id="3-4-查看hadoop页面"><a href="#3-4-查看hadoop页面" class="headerlink" title="3.4 查看hadoop页面"></a>3.4 查看hadoop页面</h2><p>​    浏览器输入: 公网ip地址:9870(如果是本地: <a href="http://localhost:9870/">http://localhost:9870</a>)</p><p>​    用云服务器还要记得开9870端口</p><p><img src="/img/article/hadoop&spark/hadoop%E9%A1%B5%E9%9D%A2.png"></p><p>​    可得如上图即Hadoop部署成功一大半</p><h2 id="3-5-YARN单机配置（配置文件也在etc-x2F-hadoop中）"><a href="#3-5-YARN单机配置（配置文件也在etc-x2F-hadoop中）" class="headerlink" title="3.5 YARN单机配置（配置文件也在etc&#x2F;hadoop中）"></a>3.5 YARN单机配置（配置文件也在etc&#x2F;hadoop中）</h2><ul><li>修改mapred-site.xml</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">   &lt;configuration&gt;     &lt;property&gt;       &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;       &lt;value&gt;yarn&lt;&#x2F;value&gt;      &lt;&#x2F;property&gt;     &lt;property&gt;         &lt;name&gt;yarn.app.mapreduce.am.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;       &lt;&#x2F;property&gt;       &lt;property&gt;        &lt;name&gt;mapreduce.map.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;       &lt;&#x2F;property&gt;       &lt;property&gt;        &lt;name&gt;mapreduce.reduce.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;     &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div></figure><ul><li>修改yarn-site.xml</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> &lt;configuration&gt;    &lt;property&gt;       &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;       &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div></figure><h2 id="3-6-查看资源管理页面"><a href="#3-6-查看资源管理页面" class="headerlink" title="3.6 查看资源管理页面"></a>3.6 查看资源管理页面</h2><p>   运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-all.sh</code></pre></div></figure><p>​    打开网址:</p><p>​    公网ip地址:8080（记得开8080端口）</p><p><img src="/img/article/hadoop&spark/spark-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.png"></p><p>​    自此，Hadoop配置完成</p><h1 id="4-Scala安装与配置"><a href="#4-Scala安装与配置" class="headerlink" title="4.Scala安装与配置"></a>4.Scala安装与配置</h1><p><img src="/img/article/hadoop&spark/spark-scala%E9%80%89%E6%8B%A9.png"> </p><p>可以看出安装spark之前还要安装一个Scala。</p><h2 id="4-1-下载-在-x2F-usr-x2F-local目录下下载，推荐"><a href="#4-1-下载-在-x2F-usr-x2F-local目录下下载，推荐" class="headerlink" title="4.1 下载(在&#x2F;usr&#x2F;local目录下下载，推荐)"></a>4.1 下载(在&#x2F;usr&#x2F;local目录下下载，推荐)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;downloads.lightbend.com&#x2F;scala&#x2F;2.12.12&#x2F;scala-2.12.12.tgz</code></pre></div></figure><h2 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar zxvf scala-2.12.12.tgzvim &#x2F;etc&#x2F;profile  #scala environmentexport SCALA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;scala-2.12.12&quot;export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$SCALA_HOME&#x2F;bin#wq</code></pre></div></figure><h2 id="4-3-环境有效"><a href="#4-3-环境有效" class="headerlink" title="4.3 环境有效"></a>4.3 环境有效</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;etc&#x2F;profile</code></pre></div></figure><h2 id="4-6-验证"><a href="#4-6-验证" class="headerlink" title="4.6 验证"></a>4.6 验证</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scala -version</code></pre></div></figure><h1 id="5-spark安装与配置"><a href="#5-spark安装与配置" class="headerlink" title="5. spark安装与配置"></a>5. spark安装与配置</h1><p>​    Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。Spark是UC Berkeley AMP lab (加州大学伯克利分校的AMP实验室)所开源的类Hadoop MapReduce的通用并行框架，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</p><h2 id="5-1-下载-在-x2F-usr-x2F-local目录下下载，推荐"><a href="#5-1-下载-在-x2F-usr-x2F-local目录下下载，推荐" class="headerlink" title="5.1 下载(在&#x2F;usr&#x2F;local目录下下载，推荐)"></a>5.1 下载(在&#x2F;usr&#x2F;local目录下下载，推荐)</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;spark&#x2F;spark-3.1.2&#x2F;spark-3.1.2-bin-hadoop3.2.tgz </code></pre></div></figure><h2 id="5-2-解压"><a href="#5-2-解压" class="headerlink" title="5.2 解压"></a>5.2 解压</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar xzvf spark-3.1.2-bin-hadoop3.2 spark</code></pre></div></figure><h2 id="5-3-重命名"><a href="#5-3-重命名" class="headerlink" title="5.3 重命名"></a>5.3 重命名</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv  spark-3.1.2-bin-hadoop3.2 spark</code></pre></div></figure><h2 id="5-4-配置环境变量"><a href="#5-4-配置环境变量" class="headerlink" title="5.4 配置环境变量"></a>5.4 配置环境变量</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> vim ~&#x2F;.bashrcexport SPARK_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;sparkexport PATH&#x3D;$PATH: $&#123;SPARK_HOME&#125;&#x2F;bin</code></pre></div></figure><h2 id="5-5-环境生效"><a href="#5-5-环境生效" class="headerlink" title="5.5 环境生效"></a>5.5 环境生效</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;.bashrc</code></pre></div></figure><h2 id="5-6-配置spark（spark-x2F-conf）"><a href="#5-6-配置spark（spark-x2F-conf）" class="headerlink" title="5.6 配置spark（spark&#x2F;conf）"></a>5.6 配置spark（spark&#x2F;conf）</h2><p>​    修改spark-env.sh(原本没有，但是有spark-env.sh.template,可以选择复制或是重建)</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim spark-env.shexport LD_LIBRARY_PATH&#x3D;$JAVA_LIBRARY_PATHexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8export SPARK_MASTER_IP&#x3D;localhostexport SPARK_WORKER_MEMORY&#x3D;4g</code></pre></div></figure><h2 id="5-7启动spark"><a href="#5-7启动spark" class="headerlink" title="5.7启动spark"></a>5.7启动spark</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;local&#x2F;spark&#x2F;sbin&#x2F;start-all.shjps</code></pre></div></figure><p><img src="/img/article/hadoop&spark/spark-%E9%BB%91%E7%9B%92%E5%AD%90%E6%98%BE%E7%A4%BA.png"></p><p>​    结果如上。</p><p>​    打开网址: 公网ip地址:8080(记得开8080端口)</p><p><img src="/img/article/hadoop&spark/spark-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA.png"></p><p>配置成功，自此结束</p><h2 id="5-8-启动pyspark"><a href="#5-8-启动pyspark" class="headerlink" title="5.8 启动pyspark"></a>5.8 启动pyspark</h2><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pyspark --master local[2]</code></pre></div></figure><p>参考链接：</p><p>[WSL搭建Hadoop与Spark环境_文艺圈不知名刘先生-CSDN博客](<a href="https://blog.csdn.net/huiruwei">https://blog.csdn.net/huiruwei</a>    1020&#x2F;article&#x2F;details&#x2F;115033974)</p><h1 id="6．测试spark"><a href="#6．测试spark" class="headerlink" title="6．测试spark"></a>6．测试spark</h1><p>博主也是刚玩，不会同时测试两个。所以就测试一下spark的并行运算能力。  博主会一点点python，所以选择pyspark。也可以使用scala或java。</p><p>  pi.py文件代码为(蒙特卡洛方法):</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyspark import SparkContextimport random1sc&#x3D;SparkContext(&quot;local&quot;,&quot;firstapp&quot;)def inside(p):     x, y &#x3D; random.random(), random.random()     return x*x + y*y &lt; 1NUM_SAMPLES&#x3D;10000count &#x3D; sc.parallelize(range(0, NUM_SAMPLES)) &#x2F;          .filter(inside).count()print(&quot;Pi is roughly %f&quot; % (4.0 * count &#x2F; NUM_SAMPLES))</code></pre></div></figure><p>  命令行执行spark-submit pi.py</p><p>参考链接：</p><p><a href="http://spark.apache.org/examples.html">Examples | Apache Spark</a></p><p><a href="https://www.jianshu.com/p/5a42fe0eed4d">大数据入门与实战-PySpark的使用教程 - 简书 (jianshu.com)</a>    </p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="hadoop" scheme="https://brraida.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>py-lambda</title>
    <link href="https://brraida.github.io/posts/69805bbd/"/>
    <id>https://brraida.github.io/posts/69805bbd/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2022-06-09T15:21:33.469Z</updated>
    
    <content type="html"><![CDATA[<p>​今天复习到了定积分，重新学了定积分的概念。迫不及待的使用python的lambda来实验实验。</p><span id="more"></span><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%861.jpg"></p><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%862.jpg"></p><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%863.jpg"></p><blockquote><p>lambda[arg1[,arg2,arg3…argn]]:expression</p><p>返回的是一个方法</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getResult(a, b, n):    fx &#x3D; lambda x: x**2    gap &#x3D; (b - a) &#x2F; n    res &#x3D; 0    for i in range(n):        res +&#x3D; fx(a + i * gap + gap &#x2F; 2) * gap    return resprint(getResult(1, 2, 1000))</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	今天复习到了定积分，重新学了定积分的概念。迫不及待的使用python的lambda来实验实验。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows快捷键</title>
    <link href="https://brraida.github.io/posts/459f9e41/"/>
    <id>https://brraida.github.io/posts/459f9e41/</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2022-06-09T15:27:50.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="打开管理员命令行"><a href="#打开管理员命令行" class="headerlink" title="打开管理员命令行"></a>打开管理员命令行</h2><ol><li><p><code>windows+r</code></p></li><li><p>输入cmd</p></li><li><p>按<code>ctrl+shift+enter</code></p></li></ol><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p><code>alt+tab</code> 快速切换窗口，松开就切换</p><p><code>windows+tab</code> 切换窗口</p><p><code>alt+ctrl+tab</code> 切换窗口，可以停留</p><p><code>ctrl+shift</code> 切换键盘</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    
    <category term="instruct" scheme="https://brraida.github.io/tags/instruct/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记</title>
    <link href="https://brraida.github.io/posts/a29203f1/"/>
    <id>https://brraida.github.io/posts/a29203f1/</id>
    <published>2021-06-06T16:00:00.000Z</published>
    <updated>2022-06-09T15:31:16.906Z</updated>
    
    <content type="html"><![CDATA[<p>​关于python的学习笔记。</p><span id="more"></span><div class="note note-primary">            <p>6月7号:sunny:</p>          </div><h2 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承(inheritance)"></a>继承(inheritance)</h2><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>​@staticmethod</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>​@classmethod</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>​类方法的第一个参数必须是指向本身的引用，而静态方法可以没有任何参数。</p><hr><h4 id="受保护变量和方法-protected"><a href="#受保护变量和方法-protected" class="headerlink" title="受保护变量和方法(protected)"></a>受保护变量和方法(protected)</h4><p>​单下划线</p><ol><li>受保护的变量能在本类和子类里被使用</li><li>受保护的方法不能在非子类中调用</li></ol><p>​</p><h4 id="私有变量和方法-private"><a href="#私有变量和方法-private" class="headerlink" title="私有变量和方法(private)"></a>私有变量和方法(private)</h4><p>​双下划线</p><hr><h2 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h2><p>​定义：实现同一个功能的方法可以有不同的表现形态。</p><p>​note：</p><ol><li>方法同名但参数类型不同，或者同一个方法能适应于不同类型的调式场景。</li><li>不允许两个方法同名但参数个数不同。（java是允许的）</li></ol><hr><h2 id="import-amp-amp-module"><a href="#import-amp-amp-module" class="headerlink" title="import &amp;&amp; module"></a>import &amp;&amp; module</h2><p>​<strong>modules</strong>: </p><ol><li>自定义模块</li><li>内置标准模块</li><li>开源模块      <a href="https://pypi.org/">PyPI · The Python Package Index</a></li></ol><h3 id="导入现有模块"><a href="#导入现有模块" class="headerlink" title="导入现有模块"></a>导入现有模块</h3><p>​<strong>使用方式</strong></p><ol><li><p>import moduleName as elseName</p><p>e.g import numpy as np</p></li><li><p>from moduleName import className(methodName&#x2F;propertyName)</p><p>e.g from numpy import sin</p></li></ol><h3 id="导入包中模块"><a href="#导入包中模块" class="headerlink" title="导入包中模块"></a>导入包中模块</h3><p>​如果<strong>以模块的形式复用代码</strong>出现了模块冲突的情况，则无法导入<strong>实现功能不同但是名字相同</strong>的模块，为了解决这个问题，可以用<strong>包的形式</strong>来复用现有功能。</p><p>可以导入整个模块也可以精确导入某个模块的某个方法，速度和范围的差别。</p><hr><h2 id="isinstance-amp-amp-type"><a href="#isinstance-amp-amp-type" class="headerlink" title="isinstance() &amp;&amp; type()"></a>isinstance() &amp;&amp; type()</h2><blockquote><p>用法：</p><p>isinstance(object,classinfo)</p></blockquote><blockquote><p>用法：</p><p>type(object)</p></blockquote><blockquote><p>isinstance() 与 type() 区别：</p><ul><li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p></li><li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li></ul><p><strong>如果要判断两个类型是否相同推荐使用 isinstance()。</strong></p></blockquote><hr><blockquote><p>6月8号:sunny:</p></blockquote><h2 id="异常-exception"><a href="#异常-exception" class="headerlink" title="异常(exception)"></a>异常(exception)</h2><p>​处理原则:出现异常不要紧，但要把异常影响范围限制到最小。</p><p>​实现要点：</p><ol><li>正确的提示异常信息。</li><li>合理监控和设置监控范围和异常处理的措施。</li><li>使用finally从句回收系统资源。</li></ol><h3 id="常用的异常处理类（被动）"><a href="#常用的异常处理类（被动）" class="headerlink" title="常用的异常处理类（被动）"></a>常用的异常处理类（被动）</h3><table><thead><tr><th>异常处理类名</th><th align="left">触发场景</th></tr></thead><tbody><tr><td>IndexError</td><td align="left">索引出错触发</td></tr><tr><td>ValueError</td><td align="left">类型参数正确，但返回值不符合预期是会触发</td></tr><tr><td>TypeError</td><td align="left">函数参数类型不正确时会触发</td></tr><tr><td>ZeroDivisionError</td><td align="left">除零出错</td></tr><tr><td>AttributeError</td><td align="left">引用属性错误触发</td></tr><tr><td>OSError</td><td align="left">无法完成操作系统级的任务时，会触发该类异常。(无法打开文件)</td></tr><tr><td>FloatingPointError</td><td align="left">浮点类计算错误</td></tr><tr><td>OverflowError</td><td align="left">数值运算时超过此种类数值的最大范围</td></tr><tr><td>UnicodeTranslateErrror</td><td align="left">Unicode转换时出错</td></tr></tbody></table><h3 id="Raise（主动）"><a href="#Raise（主动）" class="headerlink" title="Raise（主动）"></a>Raise（主动）</h3><p>​自定义的异常描述信息会更具有操作性。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def divide(x, y):    if y &#x3D;&#x3D; 0:        raise Exception(&#39;divisor is 0&#39;)    try:        return x &#x2F; y    except TypeError:        raise Exception(&#39;parameters Type error&#39;)try:    divide(1, 0)except Exception as e:    print(e)try:    divide(1, &#39;1&#39;)except Exception as e:    print(e)</code></pre></div></figure><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><blockquote><p>Python 垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。</p></blockquote><p>​作用：资源回收(比如关闭文件、数据库连接等这些的工作)</p><p>​功能：无论try块是否发生异常，最终都要进入finally语句，并执行其中的代码块。</p><p>参考链接：<a href="http://c.biancheng.net/view/2316.html">Python try except finally：资源回收 (biancheng.net)</a></p><p>​有点意思的地方</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def funcWithFinally():    try:        print(&quot;in try&quot;)        return &quot;try end&quot;    finally:        print(&quot;in finally&quot;)        return &quot;finally end&quot;print(funcWithFinally())</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">输出结果:in tryin finallyfinally end</code></pre></div></figure><p>​说明第七行比第四行提前执行了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def funcWithFinally():    try:        print(&quot;in try&quot;)        return &quot;try end&quot;    finally:        print(&quot;in finally&quot;)print(funcWithFinally())</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">输出结果:in tryin finallytry end</code></pre></div></figure><p>​会回到第四行执行。</p><blockquote><p>6月9号:sun_behind_large_cloud:</p></blockquote><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读取模式</td></tr><tr><td>w</td><td>写入模式。若文件不存在，则创建一个文件，写入；若文件存在，则清空再写入。</td></tr><tr><td>r+</td><td>读写模式。从文件头开始写，保留原文件中没有被覆盖的内容。</td></tr><tr><td>w+</td><td>读写模式。若文件不存在，则创建一个文件，写入；若文件存在，则清空再写入。</td></tr><tr><td>a</td><td>附加写模式(不可读)。若文件不存在，则创建一个文件；若文件存在，写入的数据会被加到文件末尾，即文件原来的内容会被保留。</td></tr><tr><td>a+</td><td>附加读写模式。若文件不存在，则创建一个文件；若文件存在，写入的数据会被加到文件末尾，即文件原来的内容会被保留。</td></tr><tr><td>b</td><td>二进制模式，非文本模式</td></tr></tbody></table><h3 id="复制和移动文件"><a href="#复制和移动文件" class="headerlink" title="复制和移动文件"></a>复制和移动文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import os, shutildef moveFile(src, dest):    if not os.path.isfile(src):        print(&#39;file not exist!&#39; + src)    else:        fpath &#x3D; os.path.split(dest)[0]        if not os.path.exists(fpath):            os.makedirs(fpath)        shutil.move(src, dest)        print(&#39;finished moving&#39;)def copyFile(src, dest):    if not os.path.isfile(src):        print(&#39;file not exist!&#39; + src)    else:        fpath &#x3D; os.path.split(dest)[0]        if not os.path.exists(fpath):            os.makedirs(fpath)        shutil.copyfile(src, dest)    print(&#39;finished copy&#39;)srcForCopy &#x3D; &#39;D:\\3\\2.jpg&#39;destForCopy &#x3D; &#39;D:\\3\\22.jpg&#39;srcForMove &#x3D; &#39;D:\\3\\python1.txt&#39;destForMove &#x3D; &#39;D:\\3\\python3.txt&#39;copyFile(srcForCopy, destForCopy)# moveFile(srcForMove, destForMove)</code></pre></div></figure><p>​<strong>GET</strong></p><p>​makedirs()#递归创建目录</p><p>​mkdir()#创建一级目录</p><p>​path.os.split(path) #返回一个数组，第一个元素是路径，第二个是文件名。</p><p>参考链接:</p><p>​<a href="https://www.runoob.com/python/python-os-path.html">Python os.path() 模块 | 菜鸟教程 (runoob.com)</a></p><p>​<a href="https://www.runoob.com/python/os-makedirs.html">Python os.makedirs() 方法 | 菜鸟教程 (runoob.com)</a></p><hr><blockquote><p>2021-6-13 </p></blockquote><h2 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h2><h3 id="urlopen方法"><a href="#urlopen方法" class="headerlink" title="urlopen方法"></a>urlopen方法</h3><blockquote><p>urllib.request.urlopen(url)#GET</p><p>urllib.request.urlopen(url,data&#x3D;None,[timeout]) #POST</p></blockquote><p>​直接用urllib.request模块的urlopen（）获取页面，page的数据格式为bytes类型，需要decode（）解码，转换成str类型。反过来也就是说，在使用post这种方式的时候，data就要以字节形式做参传入。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import urllib.requeststockCode &#x3D; &#39;600895&#39;url &#x3D; &#39;http:&#x2F;&#x2F;quotes.money.163.com&#x2F;service&#x2F;chddata.html&#39;param &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;code&#39;: &#39;0&#39; + stockCode,                                      &#39;start&#39;: &#39;20210602&#39;,                                      &#39;end&#39;: &#39;20210602&#39;,                                      &#39;fields&#39;: &#39;TCLOSE;HIGH;LOW;TOPEN;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER&#39;&#125;),              encoding&#x3D;&#39;utf-8&#39;)response &#x3D; urllib.request.urlopen(url, data&#x3D;param, timeout&#x3D;10)print(response.read().decode(&#39;gbk&#39;))response.close()</code></pre></div></figure><p>参考链接:</p><p><a href="https://blog.csdn.net/qq_41856814/article/details/99658108">Python3中urlopen()详解</a></p><h3 id="urlretrieve方法"><a href="#urlretrieve方法" class="headerlink" title="urlretrieve方法"></a>urlretrieve方法</h3><blockquote><p>urllib.request.urlretrieve(url,filename,data)#取己所需，所以参考链接的更完整详细</p></blockquote><p>返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import urllib.requestdef getAndSaveStock(stockCodeList, path):    for stockCode in stockCodeList:        url &#x3D; &#39;http:&#x2F;&#x2F;quotes.money.163.com&#x2F;service&#x2F;chddata.html&#39;        param &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;code&#39;: &#39;0&#39; + stockCode,                                              &#39;start&#39;: &#39;20210602&#39;,                                              &#39;end&#39;: &#39;202106012&#39;,                                              &#39;fields&#39;: &#39;TCLOSE;HIGH;LOW;TOPEN;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER&#39;&#125;)                      , encoding&#x3D;&#39;utf8&#39;)        urllib.request.urlretrieve(url, path + stockCode + &#39;.csv&#39;, data&#x3D;param)stockCodeList &#x3D; []stockCodeList.append(&#39;600895&#39;)stockCodeList.append(&#39;600007&#39;)getAndSaveStock(stockCodeList, &#39;D:\\3\\&#39;)</code></pre></div></figure><p>​发现如果将第12行的’.csv’改成’.txt’也是可以的。真方便啊！记得我学csv的时候，还要用它的相关库，一行行写入。</p><p>参考链接:</p><p><a href="https://cloud.tencent.com/developer/article/1406358">urllib.request.urlretrieve()函数</a></p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p>​作用：一般用来搜索和替换符合特定规则的文本。</p><blockquote><p>2021-6-14 :sunny:</p></blockquote><h4 id="常用正则字符"><a href="#常用正则字符" class="headerlink" title="常用正则字符"></a>常用正则字符</h4><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>开始标记</td></tr><tr><td>$</td><td>结束标记</td></tr><tr><td>+</td><td>匹配一次或多次</td></tr><tr><td>*</td><td>匹配零次或多次</td></tr><tr><td>[]</td><td>表示一个字符集</td></tr><tr><td>a-z</td><td>表示小写字母</td></tr><tr><td>|</td><td>表示“或”</td></tr><tr><td>{}</td><td>匹配指定字符n次</td></tr><tr><td>.</td><td>任意字符</td></tr><tr><td>？</td><td>非贪心</td></tr><tr><td>\w</td><td>匹配任何字母、数字和下划线</td></tr><tr><td>\d</td><td>匹配任何数字</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符</td></tr><tr><td>()</td><td>将位于()内的内容作为整体对待</td></tr></tbody></table><p><strong>匹配字符串一般用法：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">myStr&#x3D;&#39;balaba&#39;myPattern&#x3D;&#39;\w+&#39;if re.match(myPattern,myStr):print(&#39;get&#39;)</code></pre></div></figure><h4 id="正则表达式截取字符串"><a href="#正则表达式截取字符串" class="headerlink" title="正则表达式截取字符串"></a>正则表达式截取字符串</h4><p>​绝了，发现自己以前根本不会截取字符串而是匹配字符串…</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import reprint(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;))print(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;)[0])print(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;)[1])str &#x3D; &#39;content&#x3D;code:(6000),price:(20)&#39;pattern &#x3D; re.compile(r&#39;[(](.*?)[)]&#39;#这个操作可以获取全部()内容，不包括()!print(re.findall(pattern, str))print(re.findall(r&#39;\((.*?)\)&#39;, str))#这个同理，就是用了转义字符rule &#x3D; r&#39;&lt;(.*?)&gt;&#39;print(re.findall(rule, &#39;&lt;vcontent&gt;&#x3D;&lt;ok?&gt;&#39;))#获取全部&lt;&gt;之间内容，不包括&lt;&gt;!print(re.findall(rule, &#39;&lt;vcontent&#x3D;&lt;ok?&gt;&#39;))print(re.findall(r&#39;a(.*?)a&#39;, &#39;acontenta &#x3D;&lt;ok?&gt;&#39;))#获取aa之间内容，不包括a!rule &#x3D; r&#39;&quot;(.*?)&quot;&#39;print(re.findall(rule, &#39;&quot;vcontent&quot;&#x3D;&lt;ok?&gt;&#39;))#获取“”之间内容str &#x3D; &#39;60001,10,12,15&#39;print(re.split(&#39;,&#39;, str))#split也可以用于re,见识短浅，以前以为只可用于strprint(str.split(&#39;,&#39;))</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	关于python的学习笔记。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>node.js安装</title>
    <link href="https://brraida.github.io/posts/63a2d85/"/>
    <id>https://brraida.github.io/posts/63a2d85/</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2022-06-09T15:36:55.715Z</updated>
    
    <content type="html"><![CDATA[<p>​    我终于知道为什么要下载安装包，而不是直接用yum源了。因为yum源里的版本可能会比较旧，去官网下载就不一样了，可以获取最新的、更好的版本。</p><span id="more"></span><div class="note note-warning">            <p>该博客写于2021年6月2号</p>          </div><p>​    腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><p>​    嫌yum源太旧，去官网<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a>下载。</p><ol><li><p>下载</p><p>去官网看最新的或是最稳定的版本号，将下列语句的版本号（v14.17.0）改一下，执行。</p></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v14.17.0&#x2F;node-v14.17.0-linux-x64.tar.xz</code></pre></div></figure><ol start="2"><li>解压</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar zxvf node-v14.17.0-linux-x64.tar.xz</code></pre></div></figure><ol start="3"><li><p>移动</p><p>一般都是将软件放在&#x2F;usr&#x2F;local路径下（也可以自定义）</p></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv node-v14.17.0-linux-x64 &#x2F;usr&#x2F;local&#x2F;node-v14</code></pre></div></figure><ol start="4"><li><p>软链接</p><p>就是快捷键一个意思</p></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -s &#x2F;usr&#x2F;local&#x2F;node-v14&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node # 添加软链</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node # 删除软链(如果不小心软链错了，先删除软链，再重新添加)</code></pre></div></figure><ol start="5"><li>查看</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node -vnpm -v</code></pre></div></figure><ol start="6"><li><p>配置npm环境变量</p><p>将 <strong>&#x2F;usr&#x2F;local&#x2F;node-v14&#x2F;bin</strong> 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具</p></li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v14&#x2F;bin:$PATH&#39; &gt;&gt; &#x2F;etc&#x2F;profile</code></pre></div></figure><ol start="7"><li>生效环境变量</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;etc&#x2F;profile</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    我终于知道为什么要下载安装包，而不是直接用yum源了。因为yum源里的版本可能会比较旧，去官网下载就不一样了，可以获取最新的、更好的版本。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="node.js" scheme="https://brraida.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装</title>
    <link href="https://brraida.github.io/posts/16fe430b/"/>
    <id>https://brraida.github.io/posts/16fe430b/</id>
    <published>2021-06-01T02:04:46.000Z</published>
    <updated>2022-06-09T15:40:56.216Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>该博文写于2021.6.1</p>          </div><span id="more"></span><p>​    腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><p>​    尝试了几种方法，在失败与成功之中，选出与这种配置最快最适合的方法。愿你早日顺利入坑。</p><ul><li><p>升级yum源</p><blockquote><p>yum -y update  &#x2F;&#x2F;升级所有包的同时，也升级软件和系统内核</p></blockquote></li></ul><p>我是将镜像重置后，上来就升级，忘记快照了。不过也无所谓啦。</p><ul><li><p>安装nginx（别名：engine X）</p><blockquote><p>yum -y install nginx</p></blockquote></li></ul><p>没想到就安装成功了，不需要换源不需要balabala，不放心可以去查看版本和配置文件</p><ol><li><p>查看nginx版本</p><blockquote><p>nginx -v</p></blockquote></li><li><p>配置文件路径</p><blockquote><p>默认的网站目录为： &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>默认的配置文件为：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>自定义配置文件目录为: &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</p></blockquote></li><li><p>查找linux文件</p></li></ol><p>​        which ngixn   &#x2F;&#x2F;会在环境变量$PATH设置的目录里查找符合条件的文件</p><p>​        whereis nginx &#x2F;&#x2F;会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件;只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><p>​        先关闭防火墙<strong>systemctl stop firewalld</strong>,然后启动它 <strong>systemctl start nginx</strong>,再在浏览器访问主机的ip地址，类似192.168.1.1，云服务器那个公网ip。</p><p><img src="/img/article/%E5%AE%89%E8%A3%85-nginx/nginx%E6%88%90%E5%8A%9F%E7%94%BB%E9%9D%A2.png"></p><p>​    可能使用Redhat安装nginx，所以显示界面和网上某些教程说显示nginx不一样。</p><p>​        </p><ul><li><p><strong>启动nginx</strong></p><blockquote><p>systemctl start nginx</p></blockquote></li><li><p><strong>停止nginx</strong></p><blockquote><p>systemctl stop nginx</p></blockquote></li><li><p><strong>重启nginx</strong></p><blockquote><p>systemctl restart nginx</p></blockquote></li><li><p><strong>查看nginx状态</strong></p><blockquote><p>systemctl status nginx</p></blockquote></li><li><p><strong>启用开机启动nginx</strong></p><blockquote><p>systemctl enable nginx</p></blockquote></li><li><p><strong>禁止开机启动nginx</strong></p><blockquote><p>systemctl disable nginx</p></blockquote></li><li><p><strong>检查配置文件</strong></p><blockquote><p>nginx -t    &#x2F;&#x2F;要在配置好的文件的路径下运行次命令</p></blockquote></li><li><p><strong>重启nginx（更新配置文件）</strong></p><blockquote><p>service nginx reload</p></blockquote></li><li><p><strong>查看进程、PID等信息</strong></p><blockquote><p>lsof -i</p></blockquote></li><li><p><strong>查看进程占用端口号</strong></p><blockquote><p>lsof -i -P|grep nginx</p></blockquote></li><li><p><strong>使用端口号查询占用进程</strong></p><blockquote><p>losf -i</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note note-warning&quot;&gt;
            &lt;p&gt;该博文写于2021.6.1&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    <category term="centos" scheme="https://brraida.github.io/categories/linux/centos/"/>
    
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>nginx相关记录</title>
    <link href="https://brraida.github.io/posts/dbc31271/"/>
    <id>https://brraida.github.io/posts/dbc31271/</id>
    <published>2021-05-31T00:49:59.000Z</published>
    <updated>2022-06-09T15:44:12.308Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>该博文写于2021.5.31</p>          </div><h2 id="nginx安装与部署"><a href="#nginx安装与部署" class="headerlink" title="nginx安装与部署"></a>nginx安装与部署</h2><p>​        本来想写nginx的安装，但是发现nginx的中文文档写得不错，然后会持续更新（这个太重要了）。也可以结合nginx的官方文档看。</p><p>​        偷个懒，放个链接好了：</p><ul><li><p>nginx中文文档：<a href="https://www.nginx.cn/">nginx</a></p></li><li><p>nginx官方文档：<a href="http://nginx.org/en/docs/">nginx documentation</a></p></li></ul><hr><h2 id="nginx概念"><a href="#nginx概念" class="headerlink" title="nginx概念"></a>nginx概念</h2><p>​        可能你和我一样，是用某个其他东西的时候用到nginx，但是却不知道这是个什么，能干什么，其特点是什么。我也是个小白，所以不敢误导。</p><p>​        贴几个我觉得讲得不错的链接：</p><ul><li><p><a href="https://juejin.cn/post/6844904129987526663#heading-16">连前端都看得懂的《Nginx 入门指南》 (juejin.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx - 知乎 (zhihu.com)</a></p></li></ul><hr><h2 id="自己遇到的问题"><a href="#自己遇到的问题" class="headerlink" title="自己遇到的问题"></a>自己遇到的问题</h2><p>​        讲讲自己遇到的一些问题，因为之前不是按照中文文档安装的，按照网上的一些教程，然后发现自己找不到配置路径。现在懂了之后，感觉自己就挺搞的。</p><p>​        <strong>nginx.conf路径问题</strong>：</p><p>​        我用的是centos7.6。有一种方法是先安装开发库，然后yum换源，然后直接安装nginx。此时的nginx配置文件在etc目录下的nginx里。(这个最简单的方法，我没有成功，好气哦，说“没有niginx包提供”)<strong>cd &#x2F;etc</strong> 即可以进入etc目录。另一种方法是下载安装包，解压到指定目录，一般都会解压到 <strong>&#x2F;usr&#x2F;local</strong> 里，此时就在和这个目录下的nginx中的conf目录下。</p><p>​        <strong>nginx.d问题</strong></p><p>​        可能你还会遇到让你在nginx.d下创建其他的*.conf文件进行清晰明了的管理配置。但是解压安装的nginx是没有nginx.d文件夹的，需要自己创建。</p><p>​        在你的nginx.conf的http块下加一句话：</p><blockquote><p>include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</p></blockquote><p>​        这句话的意思是在关联etc下nginx下的conf.d目录文件，后面那个是配置文件。所以你可以在任意目录下建立这个conf.d目录文件，只要关联上就好了。不过，一般在etc或是解压的nginx文件下建立cong.d目录文件（个人观点。看到的各种教程都是建立在这些位置。nginx目录好理解，跟随性么，好找也好删除；之后查了etc目录作用，原来各种配置文件一般都是放在这里，那么这也就好理解了。）</p><p>​        然后只要重新加载配置文件就可以了</p><blockquote><p>service nginx reload</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>MyLog</title>
    <link href="https://brraida.github.io/posts/430d67de/"/>
    <id>https://brraida.github.io/posts/430d67de/</id>
    <published>2021-05-18T12:48:09.000Z</published>
    <updated>2022-06-09T15:47:04.333Z</updated>
    
    <content type="html"><![CDATA[<p>​看心情随便记上两笔。</p><span id="more"></span><p>2021-5-17</p><hr><ul><li>花了我100多大洋买了个服务器，搞起来！</li><li>将项目移植到其他地方，改了半天的绝对路径。突然发现绝对路径的好处。</li></ul><p>2021-6-9</p><hr><ul><li><p>YAML是一个可读性高，用来表达数据序列化的格式。</p></li><li><p>XML是一种标记电子文件使其具有结构性的标记语言。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	看心情随便记上两笔。&lt;/p&gt;</summary>
    
    
    
    <category term="log" scheme="https://brraida.github.io/categories/log/"/>
    
    
    <category term="原木" scheme="https://brraida.github.io/tags/%E5%8E%9F%E6%9C%A8/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://brraida.github.io/posts/cc129669/"/>
    <id>https://brraida.github.io/posts/cc129669/</id>
    <published>2021-05-18T12:47:30.000Z</published>
    <updated>2022-06-09T15:51:23.562Z</updated>
    
    <content type="html"><![CDATA[<p>DFA与NFA的区别    </p><ul><li><p>这两个的主要最明显的区别就是DFA经过某一路径，到达另一个状态是确定的、唯一的。而NFA不是，而是可以到达一个或是多个状态的。也就是说，DFA是NFA的一种特例。</p></li><li><p>DFA的某一路径是的值是没有空串的。（那时候不知道这一点，在NFA进行确定化的时候，经空串也进行了计算，大失败！）</p></li></ul><p>有时候吧，想对答案的地方都没有，以后将编译原理的作业整理，丢上来。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="homework" scheme="https://brraida.github.io/categories/homework/"/>
    
    
    <category term="Fundamentals of Compiling" scheme="https://brraida.github.io/tags/Fundamentals-of-Compiling/"/>
    
  </entry>
  
  <entry>
    <title>py爆破</title>
    <link href="https://brraida.github.io/posts/3cc1efd6/"/>
    <id>https://brraida.github.io/posts/3cc1efd6/</id>
    <published>2021-05-18T09:27:08.000Z</published>
    <updated>2022-06-09T15:57:17.424Z</updated>
    
    <content type="html"><![CDATA[<p>​    有时候想白嫖一些资源，但是总会有些资源是压缩加密的。就因为这个，我对爆破很感兴趣。之后有学了python，所以就兴致冲冲地写了爆破脚本。记录一下遇到的问题和解决的方法。</p><span id="more"></span><p>​    首先，学信安的小伙伴和我讲有字典就简单，代码很简单的。所以我在github在找了如下的字典库。</p><blockquote><p><a href="https://github.com/YueYongDev/Blasting_dictionary">YueYongDev&#x2F;Blasting_dictionary: 爆破字典 (github.com)</a></p></blockquote><p>​    之后cv网上代码，他用的是zipfile模块（python内置的模块）、rarfile模块(github大佬写的，接口和zipfile差不多)。然后出现问题。</p><h2 id="使用zipfile模块"><a href="#使用zipfile模块" class="headerlink" title="使用zipfile模块"></a>使用zipfile模块</h2><p>​    用zipfile不能解压不是用传统加密的文件。经过科学上网查询得到这样的解答与解决。</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/zipfile%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E7%AD%94.jpg"></p><p>​    <strong>AES</strong>：密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。</p><p>​    现在加密一般都是按这个标准。</p><h2 id="使用pyzipper模块"><a href="#使用pyzipper模块" class="headerlink" title="使用pyzipper模块"></a>使用pyzipper模块</h2><p>​    所以使用pyzipper模块代替zipfile模块。</p><p>​    给上可执行正确的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyzipperf1 &#x3D; open(&#39;D:\\1\\pwd.txt&#39;, &#39;r&#39;)with pyzipper.AESZipFile(&#39;D:\\1\\test.zip&#39;, &#39;r&#39;) as f:    for i in f1:        i &#x3D; i.rstrip(&#39;\n&#39;)        f.pwd &#x3D; str.encode(i)        try:            f.extractall(&#39;D:\\1\\2&#39;)            print(&quot;The correct password is:&quot; + i)            break        except Exception:            passf1.close()</code></pre></div></figure><h2 id="rarfile模块"><a href="#rarfile模块" class="headerlink" title="rarfile模块"></a>rarfile模块</h2><p>​    使用rarfile模块解压rar文件问题就多了。它解压其实借助的是电脑的解压软件的unrar.exe进行解压。(可以在pypi中查看此模块，可以得到此模块的相关信息与工作原理)</p><p>​    然后我嫌下载unrar太麻烦，还要配置环境变量等等操作，并且我本地用的是WinRAR，所以将WinRAR所在的路径加入环境就解决了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rarfile path1 &#x3D; &#39;D:\\1\\2.rar&#39; despath &#x3D; &#39;D:\\1\\2&#39;  rf &#x3D; rarfile.RarFile(path1)rf.extractall(path&#x3D;despath)rf.close()</code></pre></div></figure><p>​    经过测试，解压没有密码压缩的可以；解压加密的压缩包里面没有文件的可以。但是不可以解压加密的有文件的压缩包。编译错误显示下图所示：</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E6%98%BE%E7%A4%BA.png"></p><p>​    所以上rarfile这个项目查了一下，其他的使用者也遇到类似这样的问题。然后有人是这么解决的，如下图所示：</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/%E6%8F%90%E9%97%AE%E8%80%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png"></p><p>​    不过，这个14年提出来并解决的。我一个21年的，只能是借鉴参考了。看到后面，果然有个20年的朋友也有这样的问题。</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/20%E5%B9%B4%E5%90%8C%E6%8F%90%E9%97%AE%E8%80%85.png"></p><p>​    所以大胆猜测，rarfile这个模块里面确实有些问题。</p><hr><p>​    同样的代码，我室友使用rarfile在他的电脑上跑出来了。</p><p>​    我是Windows10，python3.8.3，Pycharm，压缩软件WinRAR</p><p>​    室友用的是manjaro，python3.9.4，idle，压缩软件是系统自带的</p><hr><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>​    瞅我这暴脾气，最近考试月。考试月过了，我在搞一下。</p><ol><li>Windows下，下那个unrar，搞配置尝试</li><li>1不行就去CenOs7.4服务器搭个环境尝试</li><li>2不行我也开manjaro尝试</li><li>以上都失败，就可以砸电脑了</li></ol><p>搞成功地进一步设想。</p><ol><li>zip可以了，rar可以了，怎么可以不把它们整合在一起的道理呢。</li><li>爆破怎么可以不搞多线程呢。</li><li>python怎么可以不搞封装呢。</li><li>整个界面。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    有时候想白嫖一些资源，但是总会有些资源是压缩加密的。就因为这个，我对爆破很感兴趣。之后有学了python，所以就兴致冲冲地写了爆破脚本。记录一下遇到的问题和解决的方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>py指令</title>
    <link href="https://brraida.github.io/posts/c669871/"/>
    <id>https://brraida.github.io/posts/c669871/</id>
    <published>2021-05-18T09:27:08.000Z</published>
    <updated>2022-06-09T15:55:52.418Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些python的命令。</p><span id="more"></span><ol><li><p>在cmd窗口查看python</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">python --version</code></pre></div></figure></li><li><p>查看安装模块或是库</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">pip list</code></pre></div></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些python的命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
    <category term="instruct" scheme="https://brraida.github.io/tags/instruct/"/>
    
  </entry>
  
  <entry>
    <title>word相关技巧</title>
    <link href="https://brraida.github.io/posts/a629f612/"/>
    <id>https://brraida.github.io/posts/a629f612/</id>
    <published>2021-05-12T02:03:46.000Z</published>
    <updated>2022-06-13T07:29:26.846Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近和小组合作完成os课设，每个人写的项目不一样，所以最后各自文档合并的时候就不得不进行排版。下面是我为了完成某个目的的word技巧的记录。</p><p>我用的是word版本是<strong>office 2016</strong>。</p><span id="more"></span><h1 id="一次性选择同类内容"><a href="#一次性选择同类内容" class="headerlink" title="一次性选择同类内容"></a>一次性选择同类内容</h1><p>​    大家都写了一级标题、二级标题、正文等，但是合并的时候发现一级标题、二级标题、正文字体、字号不一样。然后想要统一。若是一个个格式刷是不切实际的，效率低下。那么如何快速选择全部同类的内容呢？</p><p>可以点击如下图所示的地方，也可以快捷键<strong>ctrl+shift+alt+s</strong></p><p><img src="/img/article/office-word/%E5%9B%BE1.png"></p><p>然后右侧会出现<strong>样式</strong>工具栏，点击你想修改的类型</p><p><img src="/img/article/office-word/%E5%9B%BE2.png"></p><hr><h1 id="修改图片格式"><a href="#修改图片格式" class="headerlink" title="修改图片格式"></a>修改图片格式</h1><p>​    为了防止文档在其他电脑时图片发生错位的情况，我们一般会选择嵌入型。但是我们选择嵌入型的时候，有些图片没有露出全部，只露出了一点点。</p><p>​    这是因为段落设置的问题，主要原因是行距设定成了固定值。</p><p>​    段落设置如图所示。</p><p><img src="/img/article/office-word/%E5%9B%BE3.png"></p><p>​    然后只要将这两个值修分别修改成无和单倍行距就可以了。</p><p><img src="/img/article/office-word/%E5%9B%BE4.png"></p><hr><h1 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h1><p>​    有些页不需要页眉或是不需要横线，如何删除。</p><p>​    单纯的单页删除是很容易操作，但是我现在的情况是，后20页都需要页眉，并且页眉都已经弄好了。唯独要删除这页的页眉。如何用样式删除，那么文档的全部页眉都会被删除，这是达不到我的要求的。</p><p>​    我的解决方法如下。</p><p>​    A页为要修改的页，B为A的下一页。</p><ol><li>双击页眉部分，进入修改页眉模式。</li><li>在要修改A页的下一页（即光标在B页），取消<strong>链接到前一节</strong>选项。</li></ol><p><img src="/img/article/office-word/%E5%9B%BE5.png"></p><ol start="3"><li>回到A页，选中文字，如图操作。</li></ol><p><img src="/img/article/office-word/%E5%9B%BE6.png"></p><ol start="4"><li>删除文字，双击文章地方，退出页眉模式。</li><li>over</li></ol><h1 id="软回车"><a href="#软回车" class="headerlink" title="软回车"></a>软回车</h1><p>软回车的作用是把文字换行显示，但是并没有分段；硬回车是将文字分段。</p><p>​    有时需要将软回车（向下的箭头）改成硬件头（回车箭头），修改方法为：</p><ol><li><strong>ctrl</strong>+<strong>h</strong>，打开替换</li><li>软回车的表达式是<strong>^l</strong>(为小写的字母l)，硬回车的表达式为<strong>^p</strong>。输入，替换即可。</li></ol><h1 id="清除空白页"><a href="#清除空白页" class="headerlink" title="清除空白页"></a>清除空白页</h1><p>其中一种方法：</p><ul><li>光标到要删除的页面</li><li>ctrl + G</li><li>定位目标选择‘页’</li><li>在‘输入页号’中输入<code>\page</code></li><li>点击‘定位’然后点击‘关闭’</li><li>按<code>delete</code>按钮直到页面删除</li></ul><p>参考：</p><blockquote><p><a href="https://support.microsoft.com/en-us/office/delete-a-page-in-word-174fedd3-b4e5-42e4-a4d0-5e25127a1404">Delete a page in Word (microsoft.com)</a></p><p><a href="https://support.microsoft.com/en-us/office/delete-a-blank-page-a5efa26e-6a21-4ac8-81ce-220a46d105a8">Delete a blank page (microsoft.com)</a></p><p><a href="https://unitedtraining.com/resources/blog/how-to-delete-an-unwanted-page-in-microsoft-word">How to Delete an Unwanted Page in Microsoft Word (unitedtraining.com)</a></p></blockquote><h1 id="调整行间距"><a href="#调整行间距" class="headerlink" title="调整行间距"></a>调整行间距</h1><p>​有时候会遇到一种奇怪的情况，就是你会发现上段的行间距是这样，下段的行间距是这样，两段行间距以肉眼看是非常不一样的，但是用’段落’查看按钮查看时，发现两者参数都是一样的。我不知道原因是什么，但是可以按以下步骤将两段的行间距修改成一样的。</p><ul><li><p>选择要修改的部分或是ctrl+A选择全部</p></li><li><p>点击’开始’栏中的’段落’中的右下角的箭头</p><p><img src="/img/article/office-word/%E8%AE%BE%E7%BD%AE%E8%A1%8C%E9%97%B4%E8%B7%9D.png" alt="段落按钮位置"></p></li><li><p>在间距栏中，将段前和段后都设置为0；将行距选择为固定值，设置值为20磅（一般是20磅，可以按自己的需求）</p></li></ul><p>​以上操作就能将行间距给统一起来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近和小组合作完成os课设，每个人写的项目不一样，所以最后各自文档合并的时候就不得不进行排版。下面是我为了完成某个目的的word技巧的记录。&lt;/p&gt;
&lt;p&gt;我用的是word版本是&lt;strong&gt;office 2016&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="https://brraida.github.io/categories/windows/"/>
    
    
    <category term="word" scheme="https://brraida.github.io/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>linux用socket实现文件传输遇到的问题总结</title>
    <link href="https://brraida.github.io/posts/4f19d5af/"/>
    <id>https://brraida.github.io/posts/4f19d5af/</id>
    <published>2021-04-29T01:34:04.000Z</published>
    <updated>2022-06-09T16:08:05.551Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近在写linux作业，要求是这样的：</p><ol><li><p>实现一个网络文件传输工具，可以使用文件和目录的传输；</p></li><li><p>增加共享目录，可以增加和删除共享的目录和文件，供网络查看；</p></li><li><p>可以查看对方共享目录和文件，并选择下载；</p></li><li><p>可以向对方传送文件和目录，并且该文件和目录会自动被对方共享。</p></li></ol><span id="more"></span><p>​    然后使用socket完成了在本地上文件的传输，之后想使用不同主机尝试传输，发现不行。开始了查找原因之旅，解决了之后mark一下。</p><p><strong>我使用的linux是centos8.1.1911-x86_64</strong></p><p><strong>室友的是ubuntu20.0.4</strong>(版本记不清了)</p><h4 id="可能造成的原因"><a href="#可能造成的原因" class="headerlink" title="可能造成的原因"></a>可能造成的原因</h4><ol><li><p>校园网</p></li><li><p>防火墙</p></li><li><p>NAT、网桥</p></li></ol><hr><h4 id="校园网"><a href="#校园网" class="headerlink" title="校园网"></a>校园网</h4><p>​    这个就比较神奇了，我先扎个坑，以后有机会在解释。同学说校园网不是局域网，要同一局域网下才行。这不是局域网震惊我一整年。查了一下校园网就是局域网，他想表达的意思应该是校园网内部是一块块的，所以你可能在这一块，而室友的电脑在那一块，导致不能连接。<strong>mark！！！</strong> 我是不太信的，我之后看清楚socket和校园网、局域网再说话。</p><p>​    先按他是对的来，进行了同一路由器下实验。结果是失败的。</p><hr><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>​    这个听了就比较合理，以前做计网实验的时候，就是因为防火墙而导致ping不通另一台主机。</p><p>​    关闭防火墙出现了问题，这里记录一下。我装了<strong>火绒</strong>，然后按照百度的方法，根本就关闭不了防火墙。（不行的方法就应该早点下架。。。）</p><p>​    <strong>可行的方法:</strong></p><ol><li>打开控制面板（windows+r，然后输入control）</li><li>点击系统和安全</li><li>点击Windows Defender防火墙</li><li>点击启动或关闭Windows Defender防火墙</li><li>关闭就可以了</li></ol><p><img src="/img/article/linux%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/firewall.png"></p><p>​    这样子后，我就成功地和室友ping通了。但是文件传输还是不行。之后听另一个室友讲，可能是NAT的问题。因为弄网桥麻烦，所以我都是直接NAT的。</p><hr><h4 id="NAT、桥接"><a href="#NAT、桥接" class="headerlink" title="NAT、桥接"></a>NAT、桥接</h4><p>​    <del>以后有时间在写NAT和桥接是啥，</del></p><blockquote><p> <a href="https://www.cnblogs.com/wzzkaifa/p/6806843.html">桥接模式和NAT模式差别 - wzzkaifa - 博客园 (cnblogs.com)</a></p><p>一句话，就是桥接可以让虚拟机在网络中像一台独立的主机，拥有ip地址,即拥有了通信能力。</p></blockquote><p>现在开始配置网桥。</p><blockquote><p>​    <a href="https://blog.csdn.net/qq_47354826/article/details/114888325">2021&#x2F;3&#x2F;16 “VMware虚拟机网络配置—桥接模式”_一切因为是码农-CSDN博客</a></p></blockquote><p>​    这位博主写的很详细，大致过程都没有问题。不过在配置的时候，有一处需要更正。在进行网卡配置的时候，写的是ifcfg-ens33文件，而这个是可读文件，常规的 <strong>!wq</strong> 命令是保存不了的。这时要使用</p><blockquote><p>w ! sudo tee %</p></blockquote><p>​    命令才可以写入。</p><p>​    最后终于和室友socket成功。</p><hr><h4 id="说些其他"><a href="#说些其他" class="headerlink" title="说些其他"></a>说些其他</h4><p>​    虚拟机是桥接模式下，必须与主机的网关一样，不然后果就是连不上外网。所以如果电脑这是连校园网，配置的是校园网的网关。待会连热点，就会不能访问外网。</p><p>​    我感觉是可以自动配置的，但是现在不想捯饬了，之后对linux感兴趣了，就补一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近在写linux作业，要求是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现一个网络文件传输工具，可以使用文件和目录的传输；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加共享目录，可以增加和删除共享的目录和文件，供网络查看；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以查看对方共享目录和文件，并选择下载；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以向对方传送文件和目录，并且该文件和目录会自动被对方共享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="linux" scheme="https://brraida.github.io/categories/linux/"/>
    
    
    <category term="socket" scheme="https://brraida.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://brraida.github.io/posts/5d36ff15/"/>
    <id>https://brraida.github.io/posts/5d36ff15/</id>
    <published>2021-04-16T07:58:52.000Z</published>
    <updated>2022-06-09T16:07:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>​markdown的一些基本语法。</p><span id="more"></span><h1 id="Markdown基本常用语法"><a href="#Markdown基本常用语法" class="headerlink" title="Markdown基本常用语法"></a>Markdown基本常用语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ol><li>井号空格标题            <strong>一级标题</strong></li><li>井号井号空格标题    <strong>二级标题</strong></li><li>…以此类推，最多有六级标题</li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol><li>星号星号文字星号星号空格        <strong>加粗</strong></li><li>星号文字星号                               <em>斜体</em></li><li>星号星号星号文字星号星号星号 <em><strong>斜体加粗</strong></em></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    大于号空格</p><blockquote><p>螃蟹在剥我的壳</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>​    三个星号空格</p><hr><p><strong>or</strong></p><p>​    三个短线(0旁边)空格</p><hr><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>tab键上的波浪线</p><p><code>~~text~~</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>​    叹号左中括号图片名(随便取)右中括号括号，在括号里填本地图片的绝对路径or网络图片的地址</p><p><code>![]()</code></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>​     左中括号信息右中括号括号，括号里面填地址</p><p>[SunMonkey](<a href="https://brraida.github.io/">SunMonkey - 熬夜是不可的 (brraida.github.io)</a>)</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有次序列表"><a href="#有次序列表" class="headerlink" title="有次序列表"></a>有次序列表</h3><p>1.空格</p><ol><li>hello</li><li>hi</li></ol><hr><h3 id="无次序列表"><a href="#无次序列表" class="headerlink" title="无次序列表"></a>无次序列表</h3><p> -空格</p><ul><li>hello</li><li>hi</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    建议右键插入，或是快捷键。用语法比较慢。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    tab键上方的点，输入三次，输入要写的编程语言(c,c++,python…)。之后就是写代码了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name&#x3D;lee</code></pre></div></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	markdown的一些基本语法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Markdown" scheme="https://brraida.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
