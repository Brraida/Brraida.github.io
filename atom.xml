<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunMonkey</title>
  
  
  <link href="https://brraida.github.io/atom.xml" rel="self"/>
  
  <link href="https://brraida.github.io/"/>
  <updated>2022-02-21T06:42:01.602Z</updated>
  <id>https://brraida.github.io/</id>
  
  <author>
    <name>Brraida Hu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>createPersonalPortainer</title>
    <link href="https://brraida.github.io/posts/e531a5f8/"/>
    <id>https://brraida.github.io/posts/e531a5f8/</id>
    <published>2022-02-21T06:02:00.000Z</published>
    <updated>2022-02-21T06:42:01.602Z</updated>
    
    <content type="html"><![CDATA[<p>​    发现一个好的工具，可视化的容器管理工具。</p><blockquote><p>官网：</p><p><a href="https://www.portainer.io/">Container Management | Kubernetes GUI | Docker Swarm GUI | Portainer</a></p></blockquote><p>​    个人版是免费的，官网有教程。但是鉴于自己英语不是非常好，并且想尽可能尝试这个项目，因此装一个汉化版的。</p><p>​    一切安装命令都是以root用户进行的。</p><ol><li><p>创建缓存</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker volume create portainer_data # 用于存储之后初始化的账号信息</code></pre></div></li><li><p>创建目录下载资源</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p &#x2F;data&#x2F;portainer&#x2F;data # 创建目录cd &#x2F;data&#x2F;portainerwget https:&#x2F;&#x2F;imnks.com&#x2F;usr&#x2F;uploads&#x2F;2022&#x2F;02&#x2F;portainer-ce-2.9.3-public-cn-20211213.zip # 下载汉化资源unzip portainer-ce-2.9.3-public-cn-20211213.zip -d public #解压 </code></pre></div></li><li><p>配置、拉取、运行</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d -p 9000:9000 --name portainer \    --restart&#x3D;always \    -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \    -v portainer_data:&#x2F;data \    -v &#x2F;data&#x2F;portainer&#x2F;public:&#x2F;public \    portainer&#x2F;portainer-ce:2.11.1        # 运行，开放9000端口，用于http访问（官网的是https）;最后数字2.11.1去掉，会默认下载最新版本</code></pre></div></li><li><p>访问ip:9090</p></li></ol><p>​    如果你想加一个反向代理，推荐一个好的工具<a href="https://nginxproxymanager.com/">Nginx Proxy Manager</a>。</p><p>​    </p><p><strong>参考链接：</strong></p><p><a href="https://cloud.tencent.com/developer/article/1621103">Portainer中文汉化 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://imnks.com/3406.html">Docker管理面板Portainer中文完美汉化2021 新增CE汉化 - 我不是矿神 (imnks.com)</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
    <category term="portainer" scheme="https://brraida.github.io/tags/portainer/"/>
    
    <category term="tools" scheme="https://brraida.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ssh_tencentCloud</title>
    <link href="https://brraida.github.io/posts/d6cb9e1e/"/>
    <id>https://brraida.github.io/posts/d6cb9e1e/</id>
    <published>2022-02-03T12:47:14.000Z</published>
    <updated>2022-02-21T06:42:59.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    某个项目推荐使用非root用户进行部署,在这个过程中谈谈对<strong>新用户的建立</strong>,<strong>使用ssh的密钥对方式进行登录</strong>,其中遇到的一些问题和一些见解。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>​    使用的是腾讯云服务器,系统用的是<strong>Debian10.2</strong>；</p><p>​    两对密钥,一对是用于root,一对是用于测试普通用户；</p><p>​    Xshell客户端进行ssh登录。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-在腾讯云的控制台上获取密钥对-下载密钥到本地-并绑定实例。"><a href="#1-在腾讯云的控制台上获取密钥对-下载密钥到本地-并绑定实例。" class="headerlink" title="1.在腾讯云的控制台上获取密钥对,下载密钥到本地,并绑定实例。"></a>1.在腾讯云的控制台上获取密钥对,下载密钥到本地,并绑定实例。</h2><p><strong>note：如果是在腾讯云控制台上获取密钥对,会直接将公钥放入系统相应位置(~/.ssh/authorized_keys)中；绑定实例后将不能在腾讯云控制台上直接登录。</strong></p><blockquote><p>细节操作：</p><p><a href="https://cloud.tencent.com/document/product/1207/44573?from=copy">轻量应用服务器 管理密钥 - 操作指南 - 文档中心 - 腾讯云</a></p></blockquote><h2 id="2-用root账户在Xshell客户端进行登录。"><a href="#2-用root账户在Xshell客户端进行登录。" class="headerlink" title="2.用root账户在Xshell客户端进行登录。"></a>2.用root账户在Xshell客户端进行登录。</h2><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212038017.png" alt="image-20220204212038017"></p><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212156456.png" alt="image-20220204212156456"></p><p>​    <strong>note：第一次填的时候,需要填root(因为此时只有root账号是开放的)。</strong></p><p><img src="/img/article/ssh-tencentCloud.assets/image-20220204212541938.png" alt="image-20220204212541938"></p><h2 id="3-创建新用户-复制公钥到新用户的根目录下-并修改文件的属性使新用户可用。"><a href="#3-创建新用户-复制公钥到新用户的根目录下-并修改文件的属性使新用户可用。" class="headerlink" title="3.创建新用户,复制公钥到新用户的根目录下,并修改文件的属性使新用户可用。"></a>3.创建新用户,复制公钥到新用户的根目录下,并修改文件的属性使新用户可用。</h2><p>谈谈：Debian系统对比centos在某些方面对新手不是很友好,它在使用<code>useradd</code>命令时,是默认没有主目录和shell的。</p><h3 id="3-1创建新用户"><a href="#3-1创建新用户" class="headerlink" title="3.1创建新用户"></a>3.1创建新用户</h3><ul><li><code>useradd</code>命令格式</li></ul><p>useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号</p><p>(useradd是可以查看与修改的,查看命令<code>useradd -D</code>;修改的路径<code>/etc/default/useradd</code>。)</p><ul><li><p>我修改的默认配置（鉴于以后可能会创建多个用户，省力）</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">SHELL&#x3D;&#x2F;bin&#x2F;bash # 默认的shellGROUP&#x3D;100# 默认的用户组HOME&#x3D;&#x2F;home# 默认的家目录所在的目录INACTIVE&#x3D;-1 # 密码失效日期EXPIRE&#x3D;# 账号失效日期SKEL&#x3D;&#x2F;etc&#x2F;skel # 使用者家目录的内容数据参考目录CREATE_MAIL_SPOOL&#x3D;yes # 是否主动帮助使用者建立邮箱</code></pre></div><p>还要修改<code>/etc/login.defs</code>文件的内容，在这个文件中任意位置添加<code>CREATE_HOME    yes</code>，其作用是主动建立使用者的家目录。</p><hr><p>若是嫌麻烦，先添新组<code>groupadd -g 1790 groupName</code>;再使用<code>useradd -u 1790 -g groupName -m -s /bin/bash userName</code>添加新用户。</p></li><li><p>可以使用<code>id username</code>查看用户的一些相关参数。</p></li></ul><h3 id="3-2root用户复制公钥到新用户的根目录下-并修改文件的属性使新用户可用"><a href="#3-2root用户复制公钥到新用户的根目录下-并修改文件的属性使新用户可用" class="headerlink" title="3.2root用户复制公钥到新用户的根目录下,并修改文件的属性使新用户可用"></a>3.2root用户复制公钥到新用户的根目录下,并修改文件的属性使新用户可用</h3><ul><li><p>在root用户终端界面</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp -pr ~&#x2F;.ssh &#x2F;home&#x2F;username # 将公钥都复制过去，其实只要复制密钥对应的公钥即可chown -R username:groupname &#x2F;home&#x2F;username&#x2F;.ssh # 修改.ssh目录为新用户可操作文件chmod 700 &#x2F;home&#x2F;username&#x2F;.ssh # 以防万一，你也可以输入ls -al 查看目录权限是否为700chmod 600 &#x2F;home&#x2F;username&#x2F;.ssh&#x2F;authorized_keys # 同理</code></pre></div></li><li><p>在username用户终端界面</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -al #查看权限是否修改正确</code></pre></div></li></ul><h2 id="用新用户账号在Xshell客户端进行登录。"><a href="#用新用户账号在Xshell客户端进行登录。" class="headerlink" title="用新用户账号在Xshell客户端进行登录。"></a>用新用户账号在Xshell客户端进行登录。</h2><p>​    与用root登录同理，不同的是账号名和密钥选取。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li><p>我发现Debian10.2 的vim无法使用鼠标右键进行复制。</p><p>解决方法：</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vim81&#x2F;defaults.vim# 差不多在79行位置set mouse&#x3D;a 修改为 set mouse-&#x3D;a# 保存即可</code></pre></div></li><li><p>文件没有颜色</p><p>解决办法：修改 .bashrc 文件</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~&#x2F;.bashrc</code></pre></div><p>去掉默认某些注释</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LS_OPTIONS&#x3D;&#39;--color&#x3D;auto&#39;eval &quot;&#96;dircolors&#96;&quot;alias ls&#x3D;&#39;ls $LS_OPTIONS&#39;alias ll&#x3D;&#39;ls $LS_OPTIONS -l&#39; # 使ll有效</code></pre></div></li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
    <category term="ssh" scheme="https://brraida.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>HuaWei_disableHuaweiSearch</title>
    <link href="https://brraida.github.io/posts/94ca0eb1/"/>
    <id>https://brraida.github.io/posts/94ca0eb1/</id>
    <published>2022-01-29T07:05:01.000Z</published>
    <updated>2022-01-29T11:26:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>​    有被华为的智能搜索“冒犯”到。</p><blockquote><p>转载:</p><p><a href="https://www.zhihu.com/question/343737292">如何关闭华为的智慧搜索?就是下图的这个，好烦？ - 知乎 (zhihu.com)</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>电脑</li><li>数据线</li><li>ADB工具</li></ol><blockquote><p>ADB工具下载地址：</p><p><a href="https://brraida.lanzouy.com/b030ol6yj">https://brraida.lanzouy.com/b030ol6yj</a><br>密码:8f7e</p></blockquote><p><strong>note：</strong></p><p>​    ADB文件夹最好放置于无中文字符。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-打开手机USB调试"><a href="#1-打开手机USB调试" class="headerlink" title="1.打开手机USB调试"></a>1.打开手机USB调试</h3><p>​    1.1 打开开发者选项：设置-&gt;关于手机-&gt;版本号，连续点击，直至提示已处于开发者模式（手机如果设置密码和隐私密码，则会输入密码）。</p><p>​    1.2 打开USB调试：设置-&gt;系统更新-&gt;开发人员选项-&gt;USB调试，打开后会提示是否允许USB调试，点击确定。</p><p>​    1.3 将手机通过数据线连接到电脑。</p><p><strong>note：</strong></p><p>​    部分手机可能需要在手机上将USB连接方式改为传输文件。（我的Nova7就需要这样）</p><h3 id="2-电脑端打开ADB工具"><a href="#2-电脑端打开ADB工具" class="headerlink" title="2.电脑端打开ADB工具"></a>2.电脑端打开ADB工具</h3><p>​    2.1 进入ADB文件夹，双击<code>打开CMD命令行.bat</code></p><p>​    2.2 在CMD里输入：<code>adb devices</code>（第一次连接需要在手机上点击确认，连接成功会有提示和设备显示）</p><p>​        若没有显示，可以拔插多试几次。</p><h3 id="3-通过命令行停用-删除系统文件"><a href="#3-通过命令行停用-删除系统文件" class="headerlink" title="3.通过命令行停用/删除系统文件"></a>3.通过命令行停用/删除系统文件</h3><p>​    在电脑端之前打开的CMD窗口输入命令即可。</p><p>​    停用命令(推荐）:<code>adb shell pm diable-user com.huawei.search</code></p><p>​    恢复命令:<code>adb shell pm enable com.huawei.search</code></p><p>​    删除命令:<code>adb shell pm uninstall --user 0 com.huawei.search</code></p><p><strong>note：</strong></p><p>​    删除系统软件后无法恢复，使用时候请谨慎操作。</p><h3 id="4-完成后，关闭手机开发者模式"><a href="#4-完成后，关闭手机开发者模式" class="headerlink" title="4.完成后，关闭手机开发者模式"></a>4.完成后，关闭手机开发者模式</h3><p>​    设置-&gt;系统更新-&gt;开发人员选项</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="HuaWei" scheme="https://brraida.github.io/tags/HuaWei/"/>
    
  </entry>
  
  <entry>
    <title>cfw_SpecialTricks</title>
    <link href="https://brraida.github.io/posts/13fbfbd4/"/>
    <id>https://brraida.github.io/posts/13fbfbd4/</id>
    <published>2022-01-29T04:42:43.000Z</published>
    <updated>2022-02-21T06:44:58.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><p>​    cfw版本用的是0.19.7。如果偶尔科学上网，不配置也没问题。日常使用，如果使用全局代理的话，就不能访问国内的一些网站。所以使用规则代理。</p><blockquote><p>项目地址：<a href="https://github.com/Loyalsoldier/clash-rules">Loyalsoldier/clash-rules: 🦄️ 🎃 👻 Clash Premium 规则集(RULE-SET)，兼容 ClashX Pro、Clash for Windows 客户端。 (github.com)</a></p></blockquote><p>​    有可能是第一次需求，不知道从何下手，所以我就进行简单的、较为完整的叙述。</p><ol><li>点击下图中<code>Home Directory</code>栏的<code>Open Folder</code></li></ol><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129124944723.png" alt="image-20220129124944723"></p><ol start="2"><li><p>用记事本或是vscode打开<code>config.yaml</code></p></li><li><p>复制如下代码</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rule-providers:  reject:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;reject.txt&quot;    path: .&#x2F;ruleset&#x2F;reject.yaml    interval: 86400  icloud:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;icloud.txt&quot;    path: .&#x2F;ruleset&#x2F;icloud.yaml    interval: 86400  apple:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;apple.txt&quot;    path: .&#x2F;ruleset&#x2F;apple.yaml    interval: 86400  google:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;google.txt&quot;    path: .&#x2F;ruleset&#x2F;google.yaml    interval: 86400  proxy:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;proxy.txt&quot;    path: .&#x2F;ruleset&#x2F;proxy.yaml    interval: 86400  direct:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;direct.txt&quot;    path: .&#x2F;ruleset&#x2F;direct.yaml    interval: 86400  private:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;private.txt&quot;    path: .&#x2F;ruleset&#x2F;private.yaml    interval: 86400  gfw:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;gfw.txt&quot;    path: .&#x2F;ruleset&#x2F;gfw.yaml    interval: 86400  greatfire:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;greatfire.txt&quot;    path: .&#x2F;ruleset&#x2F;greatfire.yaml    interval: 86400  tld-not-cn:    type: http    behavior: domain    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;tld-not-cn.txt&quot;    path: .&#x2F;ruleset&#x2F;tld-not-cn.yaml    interval: 86400  telegramcidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;telegramcidr.txt&quot;    path: .&#x2F;ruleset&#x2F;telegramcidr.yaml    interval: 86400  cncidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;cncidr.txt&quot;    path: .&#x2F;ruleset&#x2F;cncidr.yaml    interval: 86400  lancidr:    type: http    behavior: ipcidr    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;lancidr.txt&quot;    path: .&#x2F;ruleset&#x2F;lancidr.yaml    interval: 86400  applications:    type: http    behavior: classical    url: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Loyalsoldier&#x2F;clash-rules@release&#x2F;applications.txt&quot;    path: .&#x2F;ruleset&#x2F;applications.yaml    interval: 86400</code></pre></div><p>添加到config.yaml文件末尾</p><hr><p>复制如下代码(白名单模式)</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">rules:  - RULE-SET,applications,DIRECT  - DOMAIN,clash.razord.top,DIRECT  - DOMAIN,yacd.haishan.me,DIRECT  - RULE-SET,private,DIRECT  - RULE-SET,reject,REJECT  - RULE-SET,icloud,DIRECT  - RULE-SET,apple,DIRECT  - RULE-SET,google,DIRECT  - RULE-SET,proxy,PROXY  - RULE-SET,direct,DIRECT  - RULE-SET,lancidr,DIRECT  - RULE-SET,cncidr,DIRECT  - RULE-SET,telegramcidr,PROXY  - GEOIP,,DIRECT  - GEOIP,CN,DIRECT  - MATCH,PROXY</code></pre></div><p>将原本文件中的<code>rules</code>取代</p></li><li><p>重启cfw，软件将会自动配置生成一个<code>ruleset</code>的新文件夹。可能会提醒出错（忘记截图了），选<code>repair</code>，然后<code>confirm</code>即会帮你自动修复。</p></li></ol><p>附上配置规则成功后的截图：</p><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129140754975.png" alt="image-20220129140754975"></p><h2 id="allow-lan"><a href="#allow-lan" class="headerlink" title="allow lan"></a>allow lan</h2><p>​    说说cfw的这个选项是干嘛的。简单的说，就是他可以实现局域网下其他设备科学上网。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​    <strong>电脑端</strong></p><p>​    开启后会得到如下信息：</p><p><img src="/img/article/cfw-SpecialTricks.assets/image-20220129141231761.png" alt="image-20220129141231761"></p><p>​    <strong>Ipad端</strong>(我测试的是)</p><p>​        <img src="/img/article/cfw-SpecialTricks.assets/B17EDD0A35EC9BCB380B55FAE0E7AD68.png" alt="iPad设置"></p><p>然后就可以科学上网了。</p><p>（完）</p><blockquote><p><a href="https://docs.cfw.lbyczf.com/contents/parser.html#%E7%89%88%E6%9C%AC%E8%A6%81%E6%B1%82">配置文件预处理 | Clash for Windows (lbyczf.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="scienceNetRules" scheme="https://brraida.github.io/tags/scienceNetRules/"/>
    
  </entry>
  
  <entry>
    <title>LinuxBasicKnowledge</title>
    <link href="https://brraida.github.io/posts/fdfafe7c/"/>
    <id>https://brraida.github.io/posts/fdfafe7c/</id>
    <published>2022-01-25T13:15:28.000Z</published>
    <updated>2022-01-28T13:51:16.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux之颜色"><a href="#linux之颜色" class="headerlink" title="linux之颜色"></a>linux之颜色</h2><p>linux中文件颜色所代表的含义：</p><ol><li><strong>绿色</strong>文件：可执行文件、可执行程序</li><li><strong>红色</strong>文件：压缩文件或者包文件</li><li><strong>蓝色</strong>文件：目录</li><li><strong>白色</strong>文件：一般性文件，如文本文件，配置文件，源码文件</li><li><strong>浅蓝色</strong>文件：链接文件，主要是使用ln命令建立的文件</li><li><strong>红色闪烁</strong>：表示链接文件有问题</li><li><strong>黄色</strong>：表示设备文件</li><li><strong>灰色</strong>：表示其他文件</li></ol><p>主要比较一下浅蓝色和蓝色区别</p><p><img src="/img/article/LinuxBasicKnowledge.assets/image-20220125212209692.png" alt="image-20220125212209692"></p><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><h3 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">具体用法是：ln -s 源文件 目标文件。源：实际存放文件的位置</code></pre></div><p>当 我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>-s 是代号（symbolic）的意思</p><p><strong>注意</strong></p><p>​    ln的链接又软链接 和硬链接两种</p><ul><li><p> <strong>软链接</strong><code>ln -s ** **</code>,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间</p></li><li><p> <strong>硬链接</strong><code>ln ** **</code>, 没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件</p></li></ul><p>  无论是软链接还是硬链接，文件都保持同步变化</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#比如我的文件在 &#x2F;opt&#x2F;cs 下面，我想在 &#x2F;opt&#x2F;var&#x2F;cs 这个路径下面也能访问到，那么应该这样来做ln -s  &#x2F;opt&#x2F;cs   &#x2F;opt&#x2F;var     # &#x2F;opt&#x2F;var下面不用创建cs这个目录，会自动创建</code></pre></div><h3 id="查看建立的软链接"><a href="#查看建立的软链接" class="headerlink" title="查看建立的软链接"></a>查看建立的软链接</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -il</code></pre></div><h3 id="删除软链接"><a href="#删除软链接" class="headerlink" title="删除软链接"></a>删除软链接</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm -rf file</code></pre></div><p>正确的删除方式（删除软链接，但不删除实际数据）</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm -rf .&#x2F;test_chk_ln</code></pre></div><blockquote><p>转载</p><p><a href="https://www.cnblogs.com/lfxiao/p/9569339.html">https://www.cnblogs.com/lfxiao/p/9569339.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux环境变量</title>
    <link href="https://brraida.github.io/posts/289d0c5f/"/>
    <id>https://brraida.github.io/posts/289d0c5f/</id>
    <published>2022-01-25T13:09:50.000Z</published>
    <updated>2022-01-28T13:59:05.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量查看"><a href="#环境变量查看" class="headerlink" title="环境变量查看"></a>环境变量查看</h2><ol><li><p>使用<code>echo</code>命令查看单个环境变量。</p><p><code>echo $PATH</code></p></li><li><p>使用<code>env</code>查看所用的环境变量。</p></li><li><p>使用<code>set</code>查看所有本地定义的环境变量。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>InstallGitBySourceCode</title>
    <link href="https://brraida.github.io/posts/ca44ae47/"/>
    <id>https://brraida.github.io/posts/ca44ae47/</id>
    <published>2022-01-25T12:30:50.000Z</published>
    <updated>2022-02-21T06:50:41.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>腾讯云、centos7</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>​    可能你为了某种需求（比如必须更好地管理文件）而要卸载git，重新安装git。</p><p><strong>一、</strong> </p><p>​    若通过yum安装git，那么只需要执行</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum remove git #卸载gitwhich git#或者whereis git #查询git残留</code></pre></div><p><strong>二、</strong></p><p>​    若通过源码安装git</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">which git#或者whereis git #查询git位置#去相应位置删除git相关文件rm -rf git</code></pre></div><p>​    最好可以备份一下，那么就可以大胆一下去删除了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    回归正题。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.9.5.tar.gz</code></pre></div><p>P.S. 可以在<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">这里</a>查找最新版本的git下载，然后替换一下git的版本数字就行。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</code></pre></div><p>​    有些依赖安装git时候不会提示，比如没有<strong>curl-devel、expat-devel</strong>将会发生<strong>git:’remote-https’ is not a git command</strong>。</p><h3 id="解压git安装包"><a href="#解压git安装包" class="headerlink" title="解压git安装包"></a>解压git安装包</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf git-2.9.5.tar.gz -C &#x2F;root #将文件解压到root文件夹下</code></pre></div><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;root&#x2F;git-2.9.5.configure -prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git&#x2F; #将资源文件集中到一个位置，便于管理</code></pre></div><h3 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">make &amp;&amp; make install</code></pre></div><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim &#x2F;etc&#x2F;profile.d&#x2F;git.sh#不在profile中配置，在这里配置是为了便于管理（不同用户有不同的路径需求，在这里配置能够更加清晰明了）#下方为git.sh文件内容GIT_HOME&#x3D;usr&#x2F;local&#x2F;git #这样做是为了使用echo查看单环境变量，大可将下方GIT_HOME取代export PATH&#x3D;$PATH:GIT_HOME&#x2F;binexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;libexe&#x2F;git-core#### wq!source &#x2F;etc&#x2F;profile #环境变量生效echo $GIT_HOME #查看环境变量</code></pre></div><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git --verison</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="install" scheme="https://brraida.github.io/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>linux_about_make</title>
    <link href="https://brraida.github.io/posts/855ab908/"/>
    <id>https://brraida.github.io/posts/855ab908/</id>
    <published>2022-01-25T07:37:45.000Z</published>
    <updated>2022-01-28T13:40:54.613Z</updated>
    
    <content type="html"><![CDATA[<p><strong>源码的安装</strong>一般由这三个步骤组成：</p><ol><li>配置（configure）</li><li>编译（make）</li><li>安装（make install）</li></ol><p>​    其中<strong>prefix</strong>选项就是配置安装的路径，如果不配置该选项，安装后可执行文件默认在/usr/local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其他资源放在/usr/local/share，比较分散。</p><p>​    为了便于集中管理某个软件的各种文件，可以配置-prefix。比如，配置一个Git的文件：</p><p>​    <code>./configure -prefix=/usr/local/git/</code></p><p>可以把所有资源文件放在/usr/local/git的路径中，这样将会更有层次。进行一些更新卸载操作都会比较简单。</p><blockquote><p>转载：</p><p><a href="https://blog.csdn.net/u014042372/article/details/80705408">configure –prefix 的用法_wuzhan的专栏-CSDN博客_prefix</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux_problem_dependency</title>
    <link href="https://brraida.github.io/posts/3f0af65b/"/>
    <id>https://brraida.github.io/posts/3f0af65b/</id>
    <published>2022-01-25T06:56:39.000Z</published>
    <updated>2022-01-28T13:47:38.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>One of the configured repositories failed…</strong></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>安装依赖的时候出现了奇怪的问题。</p><p><img src="/img/article/linux-problem-dependency.assets/image-20220125150041905.png" alt="image-20220125150041905"></p><p><img src="/img/article/linux-problem-dependency.assets/image-20220125150000581.png" alt="image-20220125150000581"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum remove epel-releaseyum updateyum install epel-release</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>yumProblem_1</title>
    <link href="https://brraida.github.io/posts/b177cd12/"/>
    <id>https://brraida.github.io/posts/b177cd12/</id>
    <published>2022-01-25T02:01:48.000Z</published>
    <updated>2022-02-21T06:50:08.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>rpmdb:BDB0113错误</p><p><img src="/img/article/yumProblem-1.assets/image-20220125100614292.png" alt="image-20220125100614292"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>rpm数据库损坏</p><h2 id="解决办法（重新构建rpm数据库）"><a href="#解决办法（重新构建rpm数据库）" class="headerlink" title="解决办法（重新构建rpm数据库）"></a>解决办法（重新构建rpm数据库）</h2><p><img src="/img/article/yumProblem-1.assets/image-20220125100813204.png" alt="image-20220125100813204"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="yum" scheme="https://brraida.github.io/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>手机换个开源字体</title>
    <link href="https://brraida.github.io/posts/99020374/"/>
    <id>https://brraida.github.io/posts/99020374/</id>
    <published>2022-01-19T13:16:41.000Z</published>
    <updated>2022-02-21T06:53:17.632Z</updated>
    
    <content type="html"><![CDATA[<p>​    有时候就是想换个壁纸、换个头像来替换一下心情。而这回我想换个<strong>字体</strong>。</p><p>​    我用的是华为手机Novo7，鸿蒙系统。不使用第三方工具，使用一套“偷梁换柱”将字体换成你想要的字体。</p><hr><p>​    看到一款开源字体，感觉不错。</p><blockquote><p><strong>霞鹜文楷</strong></p><p><a href="https://github.com/lxgw/LxgwWenKai">https://github.com/lxgw/LxgwWenKai</a></p></blockquote><p>​    </p><ol><li>打开华为的<strong>主题APP</strong>，选择字体，以<strong>免费</strong>为关键字搜索。</li><li>下载任意一款免费字体。</li><li>再下载你自己想要的一款开源或是某些渠道得到的字体。</li><li>打开<strong>文件管理APP</strong>，将步骤3中所下载的字体解压，得到后缀为ttf的字体文件，将其复制或者移动到步骤2的文件夹（所在位置一般为/Huawei/Themes/HWFonts）中。</li><li>记录步骤2下载的字体文件名字，删除该文件；将步骤3中所下载的文件的文件名替换成步骤2文件的文件名。</li><li>在<strong>主题APP</strong>中<strong>应用</strong>步骤2中下载的字体，从而达到偷梁换柱的目的。</li></ol><hr><p> 我现所遇到的问题，用一些APP的时候会偶尔的闪退。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="HuaWei" scheme="https://brraida.github.io/tags/HuaWei/"/>
    
  </entry>
  
  <entry>
    <title>电脑最大支持内存</title>
    <link href="https://brraida.github.io/posts/1f0fc3c4/"/>
    <id>https://brraida.github.io/posts/1f0fc3c4/</id>
    <published>2021-12-10T05:24:27.000Z</published>
    <updated>2022-02-21T06:48:50.405Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zhihu.com/question/25013395/answer/145545591?utm_source=qq&utm_medium=social&utm_oi=798595818130112512">怎样选购笔记本内存条？ - 知乎 (zhihu.com)</a></p></blockquote><p>​    以前在选购内存条时，参考了此信息。现在对里面的内存最大容量（电脑最大支持内存）感到疑惑，不知道他的影响因素是什么。</p><p>​    经过查阅，原来是CPU和主板同时决定内存条的最大容量，并且遵循的是短板原理（然而绝大部分情况是不考虑CPU的，因为一般来说CPU支持的最大内存&gt;主板支持的最大内存）。比如CPU支持最大的内存是32G，而主板支持的最大内存是16G，那么内存的最大容量就是16G。但是，倘若插两条16G内存条也没关系（网友说的，没有实践过），就是享受不到32G的内存。</p><hr><p>​    查询电脑最大支持内存大小（我已知的几种方法）：</p><ol><li><p>如上文链接说的一样，在中关村<a href="http://www.zol.com.cn/%E6%9F%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%B5%E8%84%91%E5%9E%8B%E5%8F%B7-&gt;%E5%8F%82%E6%95%B0-&gt;%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%EF%BC%8C%E9%82%A3%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%9C%80%E5%A4%A7%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E3%80%82">www.zol.com.cn/查自己的电脑型号-&gt;参数-&gt;存储设备，那里可以获得最大存储容量。</a></p></li><li><p>在cmd窗口运行<code>wmic memphysical get maxcapacity,MemoryDevices</code>，将获得两个参数，一个是单个卡槽的最大内存支持（MaxCapcity，单位是kb），一个是卡槽数量（MemoryDevices）。</p><p><img src="/img/article/%E7%94%B5%E8%84%91%E6%94%AF%E6%8C%81%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98/order_example.png" alt="order_example"></p><p>上图单个卡槽最大内存支持为67108864/1024/1024/8=8GB</p><p>所以该电脑最大支持内存为32GB。</p><p>但是有人说这个命令不合适，有些瑕疵。</p><blockquote><p><a href="https://blog.csdn.net/Vudno/article/details/104801961">wmic memphysical get maxcapacity存疑_Vudno的博客-CSDN博客</a></p></blockquote></li><li><p>使用aida64</p><p><strong>计算机</strong>-&gt;<strong>DMI</strong>-&gt;<strong>内存矩阵</strong>-&gt;<strong>系统内存</strong>进行查看。</p><p>附上aida64的破解版：</p><blockquote><p><a href="https://www.52pojie.cn/thread-1405758-1-1.html">功能强大的硬件检测利器 AIDA64 （工程师版 &amp; 商业版） 6.33.5700 中文绿色稳定版 - 『精品软件区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="computer" scheme="https://brraida.github.io/tags/computer/"/>
    
  </entry>
  
  <entry>
    <title>vim_config</title>
    <link href="https://brraida.github.io/posts/132608bd/"/>
    <id>https://brraida.github.io/posts/132608bd/</id>
    <published>2021-10-05T09:12:01.000Z</published>
    <updated>2021-10-05T09:18:34.957Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近在写编译原理的课设，我直接使用vim打代码，而vim的缩进让我的队友看不下去。所以修改一下vim的配置文件。</p><ol><li><p>创建.vimrc配置文件</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~&#x2F;.vimrc</code></pre></div></li><li><p>修改配置文件</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">set numberset tabstop&#x3D;2set softtabstop&#x3D;2set shiftwidth&#x3D;2set noexpandtabset autoindent</code></pre></div><p>配置说明如下：</p><p>set number：表示打开文件自动显示行号</p><p>set tabstop=2：表示一个Tab键显示出来多少个空格的长度，默认是8，这里设置为2</p><p>set softtabstop=2：表示在编辑模式下按退格键时候退回缩进的长度，设置为2</p><p>set shiftwidth=2：表示每一级缩进的长度，一般设置成和softtabstop长度一样</p><p>set noexpandtab：当设置成expantab时表示缩进用空格来表示，noexpandtab则用制表符表示一个缩进</p><p>set autoindent：表示自动缩进</p></li><li><p>保存退出</p><p>下一次使用vim的时候即是配置文件的状态。</p></li></ol><p>参考链接：</p><blockquote><p><a href="https://www.cnblogs.com/Cqlismy/p/11358259.html">vim设定Tab缩进长度 - Cqlismy - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="vim" scheme="https://brraida.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>二级域名、nginx反向代理的一些理解</title>
    <link href="https://brraida.github.io/posts/aed070af/"/>
    <id>https://brraida.github.io/posts/aed070af/</id>
    <published>2021-09-14T08:34:29.000Z</published>
    <updated>2021-09-14T10:04:06.690Z</updated>
    
    <content type="html"><![CDATA[<p>​    首先，一个域名对应一个服务。所以我以为买来的主域名只能用一次，即只能对应一个服务。但不是，买来的是主域名，还可以创建二级域名，然后用二级域名对应其他的服务，根本就不需要另外买。</p><h2 id="二级域名设置"><a href="#二级域名设置" class="headerlink" title="二级域名设置"></a>二级域名设置</h2><p><img src="/img/article/nginx-2/%E5%9B%BE1-1.png" alt="图1-1"></p><p><img src="/img/article/nginx-2/%E5%9B%BE1-2.png" alt="图1-2"></p><p>二级域名就搞定了。如果要搞SSL证书，去申请，部署。我下面就是个部署例子。</p><p><a href="https://cloud.tencent.com/document/product/400/35244">SSL 证书 Nginx 服务器 SSL 证书安装部署 - 证书安装 - 文档中心 - 腾讯云 (tencent.com)</a></p><hr><h2 id="nginx反向代理理解"><a href="#nginx反向代理理解" class="headerlink" title="nginx反向代理理解"></a>nginx反向代理理解</h2><p>​    之前理解不了nginx反向代理，个人觉得端口和服务是一一对应的（这是对的），他凭什么可以80/443端口转发到不同服务中。现在也理解了。</p><p>​    我举个我自己弄的例子。</p><p><img src="/img/article/nginx-2/%E5%9B%BE2-1.png" alt="图2-1"></p><p>​    如图，当你以<code>https://cloudreve.bao.com</code>访问时，会被443端口监听到，nginx配置中有cloudreve.bao.com上游，所以会转到5212端口，进行相应的cloudreve服务；同理，以<code>https://ttrss.bao.com</code>访问时，会被443端口监听到，nginx配置中有ttrss.bao.com上游，所以会转到181端口，进行相应的ttrss服务。</p><p>​    nginx配置如下:</p><p><img src="/img/article/nginx-2/%E5%9B%BE2-2.png" alt="图2-2"></p><p>server_name就是上游。location就是转到相应的端口进行相应的服务。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
    <category term="域名" scheme="https://brraida.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>schoolMail</title>
    <link href="https://brraida.github.io/posts/90da9727/"/>
    <id>https://brraida.github.io/posts/90da9727/</id>
    <published>2021-09-11T10:46:28.000Z</published>
    <updated>2022-02-21T06:48:36.876Z</updated>
    
    <content type="html"><![CDATA[<p>​    记录一下原本几分钟的事情，被愚蠢的我硬生生搞了个把小时。</p><p>​    我有一个<strong>网易校园邮箱</strong>，想要登录到手机自带的电子邮件客户端，然后需要填写smtp和imp一些信息。愚蠢的我按着网上的教程进行，怎么也不行，之后发现网易官网是有教程的。</p><blockquote><p><a href="https://qiye.163.com/help/l-12.html">https://qiye.163.com/help/l-12.html</a></p></blockquote><hr><p>​    我说一下大致过程（我用的是IMAP协议）</p><ol><li>在网页版登录账号，在【设置】-&gt;【客户端设置】-&gt;【设置客户端授权密码】点击开启，生成授权密码（密码会以短信形式发送，不记录也没关系）</li><li>点击<a href="https://qiye.163.com/help/l-12.html">客户端设置</a>，选择<strong>手机/平板应用设置</strong>，填入账号，之后按建议的填入就行了。</li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="emial" scheme="https://brraida.github.io/tags/emial/"/>
    
  </entry>
  
  <entry>
    <title>funAlgorithm</title>
    <link href="https://brraida.github.io/posts/d1c9f41/"/>
    <id>https://brraida.github.io/posts/d1c9f41/</id>
    <published>2021-09-07T12:36:45.000Z</published>
    <updated>2021-09-07T12:49:59.120Z</updated>
    
    <content type="html"><![CDATA[<p>​    第一次遇到概率论的问题与编程的递归思维结合的题目，除了新奇的感觉之外，还感受到了数学与代码之间细微的美妙。</p><p>​    <img src="/img/article/funAlgorithm/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%92%E5%BD%92%E6%80%9D%E7%BB%B4%E7%BB%93%E5%90%88%E7%9A%84%E9%A2%98%E7%9B%AE.png" alt="题目"></p><p>​    解决这个题目有几个要点，一是定球的位置数量要从大到小；二是定球的位置数量最多的那种情况和次多的情况是一样的，所以不要考虑次多的情况。</p><p>​    有空或是无聊的时候再来补充这个题目的代码。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://brraida.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>tmpmail</title>
    <link href="https://brraida.github.io/posts/b891a459/"/>
    <id>https://brraida.github.io/posts/b891a459/</id>
    <published>2021-09-07T02:03:42.000Z</published>
    <updated>2022-02-21T06:43:20.534Z</updated>
    
    <content type="html"><![CDATA[<p>​    有时候只是当时需要获取某网站的信息，但是该网站需要登录邮箱，而选择登录自己的邮箱，一是泄漏了不必要泄漏的信息，二是可能之后会被广告炮轰。所以使用临时邮箱，就有了必要性和实用性。</p><blockquote><p>github项目:</p><p><a href="https://github.com/sdushantha/tmpmail">sdushantha/tmpmail: A temporary email right from your terminal written in POSIX sh (github.com)</a></p></blockquote><h2 id="centos7安装tmpmail"><a href="#centos7安装tmpmail" class="headerlink" title="centos7安装tmpmail"></a>centos7安装tmpmail</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install -y w3m curl jq</code></pre></div><h3 id="安装tmpmail"><a href="#安装tmpmail" class="headerlink" title="安装tmpmail"></a>安装tmpmail</h3><p>安装github教程安装</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># Download the tmpmail file and make it executablecurl -L &quot;https:&#x2F;&#x2F;git.io&#x2F;tmpmail&quot; &gt; tmpmail &amp;&amp; chmod +x tmpmail# Then move it somewhere in your $PATH. Here is an example:mv tmpmail ~&#x2F;bin&#x2F;</code></pre></div><p>可能和我一样，莫名其妙下载不了，那么可以</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 创建tmpmail文件并编辑vim tmpmail</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 将以下代码复制进入文件#!&#x2F;usr&#x2F;bin&#x2F;env sh# by Siddharth Dushantha 2020## Dependencies: jq, curl, w3m#version&#x3D;1.1.9# By default &#39;tmpmail&#39; uses &#39;w3m&#39; as it&#39;s web browser to render# the HTML of the emailbrowser&#x3D;&quot;w3m&quot;# If the value is set to &#39;true&#39; tmpmail will convert the HTML email# to raw text and send that to stdoutraw_text&#x3D;false# Everything related to &#39;tmpmail&#39; will be stored in &#x2F;tmp&#x2F;tmpmail# so that the old emails and email addresses get cleared after# restarting the computertmpmail_dir&#x3D;&quot;&#x2F;tmp&#x2F;tmpmail&quot;# tmpmail_email_address is where we store the temporary email address# that gets generated. This prevents the user from providing# the email address everytime they run tmpmailtmpmail_email_address&#x3D;&quot;$tmpmail_dir&#x2F;email_address&quot;# tmpmail.html is where the email gets stored.# Even though the file ends with a .html extension, the raw text version of# the email will also be stored in this file so that w3m and other browsers# are able to open this filetmpmail_html_email&#x3D;&quot;$tmpmail_dir&#x2F;tmpmail.html&quot;# Default 1secmail API URLtmpmail_api_url&#x3D;&quot;https:&#x2F;&#x2F;www.1secmail.com&#x2F;api&#x2F;v1&#x2F;&quot;usage() &#123;    # Using &#39;cat &lt;&lt; EOF&#39; we can easily output a multiline text. This is much    # better than using &#39;echo&#39; for each line or using &#39;\n&#39; to create a new line.    cat &lt;&lt;EOFtmpmailtmpmail -h | --versiontmpmail -g [ADDRESS]tmpmail [-t | -b BROWSER] -r | IDWhen called with no option and no argument, tmpmail lists the messages inthe inbox and their numeric IDs.  When called with one argument, tmpmailshows the email message with specified ID.-b, --browser BROWSER        Specify BROWSER (default: w3m) that is used to render the HTML of        the email-g, --generate [ADDRESS]        Generate a new email address, either the specified ADDRESS, or        randomly create one-h, --help        Show help-r, --recent        View the most recent email message-t, --text        View the email as raw text, where all the HTML tags are removed.        Without this option, HTML is used.--version        Show versionEOF&#125;generate_email_address() &#123;    # There are 2 ways which this function is called in this script.    #  [1] The user wants to generate a new email and runs &#39;tmpmail --generate&#39;    #  [2] The user runs &#39;tmpmail&#39; to check the inbox , but &#x2F;tmp&#x2F;tmpmail&#x2F;email_address    #      is empty or nonexistant. Therefore a new email gets automatically    #      generated before showing the inbox. But of course the inbox will    #      be empty as the newly generated email address has not been    #      sent any emails.    #    # When the function &#39;generate_email_address()&#39; is called with the arguement    # &#39;true&#39;, it means that the function was called because the user    # ran &#39;tmpmail --generate&#39;.    #    # We need this variable so we can know whether or not we need to show the user    # what the email was. &lt;-- More about this can be found further down in this function.    externally&#x3D;$&#123;1:-false&#125;    # This variable lets generate_email_address know if the user has provided a custom    # email address which they want to use. custom is set to false if $2 has no value.    custom&#x3D;$&#123;2:-false&#125;    # Generate a random email address.    # This function is called whenever the user wants to generate a new email    # address by running &#39;tmpmail --generate&#39; or when the user runs &#39;tmpmail&#39;    # but &#x2F;tmp&#x2F;tmpmail&#x2F;email_address is empty or nonexistent.    #    # We create a random username by taking the first 10 lines from &#x2F;dev&#x2F;random    # and delete all the characters which are *not* lower case letters from A to Z.    # So charcters such as dashes, periods, underscore, and numbers are all deleted,    # giving us a text which only contains lower case letters form A to Z. We then take    # the first 10 characters, which will be the username of the email address    username&#x3D;$(head &#x2F;dev&#x2F;urandom | LC_ALL&#x3D;C tr -dc &quot;[:alnum:]&quot; | cut -c1-11 | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;)    valid_email_address_regex&#x3D;&quot;[a-z0-9]+@(1secmail\.(com|net|org)|esiix.co|wwjmp.com|xojxe.com|yoggm.com)&quot;    username_black_list_regex&#x3D;&quot;(abuse|webmaster|contact|postmaster|hostmaster|admin)&quot;    username_black_list&#x3D;&quot;- abuse\n- webmaster\n- contact\n- postmaster\n- hostmaster\n- admin&quot;    domains&#x3D;&quot;1secmail.com 1secmail.net 1secmail.org esiix.com wwjmp.com xojxe.com yoggm.com&quot;     # Randomly pick one of the domains mentiond above.    domain&#x3D;$(printf &quot;%b&quot; &quot;$domains&quot; | tr &quot; &quot; &quot;\n&quot; | randomize | tail -1)    email_address&#x3D;&quot;$username@$domain&quot;    # If the user provided a custom email address then use that email address    if [ &quot;$custom&quot; !&#x3D; false ]; then        email_address&#x3D;$custom        # Check if the user is using username in the email address which appears        # in the black list.        if printf %b &quot;$email_address&quot; | grep -Eq &quot;$username_black_list_regex&quot;; then            print_error &quot;For security reasons, that username cannot be used. Here are the blacklisted usernames:\n$username_black_list&quot;        fi        # Do a regex check to see if the email address provided by the user is a        # valid email address        if ! printf %b &quot;$email_address&quot; | grep -Eq &quot;$valid_email_address_regex&quot;; then            print_error &quot;Provided email is invalid. Must match $valid_email_address_regex&quot;        fi    fi    # Save the generated email address to the $tmpmail_email_address file    # so that it can be whenever &#39;tmpmail&#39; is run    printf %s &quot;$email_address&quot; &gt;&quot;$tmpmail_email_address&quot;    # If this function was called because the user wanted to generate a new    # email address, show them the email address    [ &quot;$externally&quot; &#x3D; true ] &amp;&amp; cat &quot;$tmpmail_email_address&quot; &amp;&amp; printf &quot;\n&quot;&#125;get_email_address() &#123;    # This function is only called once and that is when this script    # get executed. The output of this function gets stored in $email_address    #    # If the file that contains the email address is empty,    # that means we do not have an email address, so generate one.    [ ! -s &quot;$tmpmail_email_address&quot; ] &amp;&amp; generate_email_address    # Output the email address by getting the first line of $tmpmail_email    head -n 1 &quot;$tmpmail_email_address&quot;&#125;list_emails() &#123;    # List all the received emails in a nicely formatted order    #    # Fetch the email data using 1secmail&#39;s API    data&#x3D;$(curl -sL &quot;$tmpmail_api_url?action&#x3D;getMessages&amp;login&#x3D;$username&amp;domain&#x3D;$domain&quot;)    # Using &#39;jq&#39; we get the length of the JSON data. From this we can determine whether or not    # the email address has gotten any emails    data_length&#x3D;$(printf %s &quot;$data&quot; | jq length)    # We are showing what email address is currently being used    # in case the user has forgotten what the email address was.    printf &quot;[ Inbox for %s ]\n\n&quot; &quot;$email_address&quot;    # If the length of the data we got is 0, that means the email address    # has not received any emails yet.    [ &quot;$data_length&quot; -eq 0 ] &amp;&amp; echo &quot;No new mail&quot; &amp;&amp; exit    # This is where we store all of our emails, which is then    # displayed using &#39;column&#39;    inbox&#x3D;&quot;&quot;    # Go through each mail that has been received    index&#x3D;1    while [ $index -le &quot;$&#123;data_length&#125;&quot; ]; do        # Since arrays in JSON data start at 0, we must subtract        # the value of $index by 1 so that we dont miss one of the        # emails in the array        mail_data&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.[$index-1]&quot;)        id&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.id&quot;)        from&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.from&quot;)        subject&#x3D;$(printf %s &quot;$mail_data&quot; | jq -r &quot;.subject&quot;)        # The &#39;||&#39; are used as a divideder for &#39;column&#39;. &#39;column&#39; will use this divider as        # a point of reference to create the division. By default &#39;column&#39; uses a blank space        # but that would not work in our case as the email subject could have multiple white spaces        # and &#39;column&#39; would split the words that are seperated by white space, in different columns.        inbox&#x3D;&quot;$inbox$id ||$from ||$subject\n&quot;        index&#x3D;$((index + 1))    done    # Show the emails cleanly    printf &quot;%b&quot; &quot;$inbox&quot; | column -t -s &quot;||&quot;&#125;randomize() &#123;    # We could use &#39;shuf&#39; and &#39;sort -R&#39; but they are not a part of POSIX    awk &#39;BEGIN &#123;srand();&#125; &#123;print rand(), $0&#125;&#39; | \        sort -n -k1 | cut -d&#39; &#39; -f2&#125;view_email() &#123;    # View an email by providing it&#39;s ID    #    # The first argument provided to this function will be the ID of the email    # that has been received    email_id&#x3D;&quot;$1&quot;    data&#x3D;$(curl -sL &quot;$tmpmail_api_url?action&#x3D;readMessage&amp;login&#x3D;$username&amp;domain&#x3D;$domain&amp;id&#x3D;$email_id&quot;)    # After the data is retrieved using the API, we have to check if we got any emails.    # Luckly 1secmail&#39;s API is not complicated and returns &#39;Message not found&#39; as plain text    # if our email address as not received any emails.    # If we received the error message from the API just quit because there is nothing to do    [ &quot;$data&quot; &#x3D; &quot;Message not found&quot; ] &amp;&amp; print_error &quot;Message not found&quot;    # We pass the $data to &#39;jq&#39; which extracts the values    from&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.from&quot;)    subject&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.subject&quot;)    html_body&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.htmlBody&quot;)    attachments&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.attachments | length&quot;)        # If you get an email that is in pure text, the .htmlBody field will be empty and    # we will need to get the content from .textBody instead    [ -z &quot;$html_body&quot; ] &amp;&amp; html_body&#x3D;&quot;&lt;pre&gt;$(printf %s &quot;$data&quot; | jq -r &quot;.textBody&quot;)&lt;&#x2F;pre&gt;&quot;    # Create the HTML with all the information that is relevant and then    # assigning that HTML to the variable html_mail. This is the best method    # to create a multiline variable    html_mail&#x3D;$(cat &lt;&lt;EOF&lt;pre&gt;&lt;b&gt;To: &lt;&#x2F;b&gt;$email_address&lt;b&gt;From: &lt;&#x2F;b&gt;$from&lt;b&gt;Subject: &lt;&#x2F;b&gt;$subject&lt;&#x2F;pre&gt;$html_bodyEOF)        if [ ! &quot;$attachments&quot; &#x3D; &quot;0&quot; ]; then        html_mail&#x3D;&quot;$html_mail&lt;br&gt;&lt;b&gt;[Attachments]&lt;&#x2F;b&gt;&lt;br&gt;&quot;        index&#x3D;1        while [ &quot;$index&quot; -le &quot;$attachments&quot; ]; do            filename&#x3D;$(printf %s &quot;$data&quot; | jq -r &quot;.attachments | .[$index-1] | .filename&quot;)            link&#x3D;&quot;$tmpmail_api_url?action&#x3D;download&amp;login&#x3D;$username&amp;domain&#x3D;$domain&amp;id&#x3D;$email_id&amp;file&#x3D;$filename&quot;            html_link&#x3D;&quot;&lt;a href&#x3D;$link download&#x3D;$filename&gt;$filename&lt;&#x2F;a&gt;&lt;br&gt;&quot;            if [ &quot;$raw_text&quot; &#x3D; true ]; then                # The actual url is way too long and does not look so nice in STDOUT.                # Therefore we will shortening it using is.gd so that it looks nicer.                link&#x3D;$(curl -s -F&quot;url&#x3D;$link&quot; &quot;https:&#x2F;&#x2F;is.gd&#x2F;create.php?format&#x3D;simple&quot;)                html_mail&#x3D;&quot;$html_mail$link  [$filename]&lt;br&gt;&quot;            else                html_mail&#x3D;&quot;$html_mail$html_link&quot;            fi            index&#x3D;$((index + 1))        done    fi    # Save the $html_mail into $tmpmail_html_email    printf %s &quot;$html_mail&quot; &gt;&quot;$tmpmail_html_email&quot;    # If the &#39;--text&#39; flag is used, then use &#39;w3m&#39; to convert the HTML of    # the email to pure text by removing all the HTML tags    [ &quot;$raw_text&quot; &#x3D; true ] &amp;&amp; w3m -dump &quot;$tmpmail_html_email&quot; &amp;&amp; exit    # Open up the HTML file using $browser. By default,    # this will be &#39;w3m&#39;.    $browser &quot;$tmpmail_html_email&quot;&#125;view_recent_email() &#123;    # View the most recent email.    #    # This is done by listing all the received email like you    # normally see on the terminal when running &#39;tmpmail&#39;.    # We then grab the ID of the most recent    # email, which the first line.    mail_id&#x3D;$(list_emails | head -3 | tail -1 | cut -d&#39; &#39; -f 1)    view_email &quot;$mail_id&quot;&#125;print_error() &#123;    # Print error message    #    # The first argument provided to this function will be the error message.    # Script will exit after printing the error message.    printf &quot;%b\n&quot; &quot;Error: $1&quot; &gt;&amp;2    exit 1&#125;main() &#123;    # Iterate of the array of dependencies and check if the user has them installed.    # We are checking if $browser is installed instead of checking for &#39;w3m&#39;. By doing    # this, it allows the user to not have to install &#39;w3m&#39; if they are using another    # browser to view the HTML    for dependency in jq $browser curl; do        if ! command -v &quot;$dependency&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1; then            print_error &quot;Could not find &#39;$dependency&#39;, is it installed?&quot;        fi    done    # Create the $tmpmail_dir directory and dont throw any errors    # if it already exists    mkdir -p &quot;$tmpmail_dir&quot;    # Get the email address and save the value to the email_address variable    email_address&#x3D;&quot;$(get_email_address)&quot;    # $&#123;VAR#PATTERN&#125; Removes shortest match of pattern from start of a string.    # In this case, it takes the email_address and removed everything after    # the &#39;@&#39; symbol which gives us the username.    username&#x3D;$&#123;email_address%@*&#125;    # $&#123;VAR%PATTERN&#125; Remove shortest match of pattern from end of a string.    # In this case, it takes the email_address and removes everything until the    # period &#39;.&#39; which gives us the domain    domain&#x3D;$&#123;email_address#*@&#125;    # If no arguments are provided just the emails    [ $# -eq 0 ] &amp;&amp; list_emails &amp;&amp; exit    while [ &quot;$1&quot; ]; do        case &quot;$1&quot; in            --help | -h) usage &amp;&amp; exit ;;            --generate | -g) generate_email_address true &quot;$2&quot; &amp;&amp; exit ;;            --browser | -b) browser&#x3D;&quot;$2&quot; ;;            --text | -t) raw_text&#x3D;true ;;            --version) echo &quot;$version&quot; &amp;&amp; exit ;;            --recent | -r) view_recent_email &amp;&amp; exit ;;            *[0-9]*)                # If the user provides number as an argument,                # assume its the ID of an email and try getting                # the email that belongs to the ID                view_email &quot;$1&quot; &amp;&amp; exit                ;;            -*) print_error &quot;option &#39;$1&#39; does not exist&quot; ;;        esac        shift    done&#125;main &quot;$@&quot;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 将文件变成可执行文件chmod +x tmpmail# 移动文件到系统或是用户的路径下(&#x2F;usr&#x2F;bin 或 &#x2F;usr&#x2F;local&#x2F;bin)mv tmpmail &#x2F;usr&#x2F;local&#x2F;bin</code></pre></div><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 生成邮箱tmpmail# 重新生成邮箱tmpmail --generate# 查看邮箱有无邮件tmpmail# 以文本显示邮件信息tmpmail -t &lt;ID&gt;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="tools" scheme="https://brraida.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>优化url</title>
    <link href="https://brraida.github.io/posts/7d2eca9c/"/>
    <id>https://brraida.github.io/posts/7d2eca9c/</id>
    <published>2021-09-02T05:54:37.000Z</published>
    <updated>2022-02-21T06:48:19.843Z</updated>
    
    <content type="html"><![CDATA[<p>使url看得更顺眼，但要使用插件，这可能一定程度上使网页加载速度变慢。</p><p>使用<code>hexo-abbrlink</code>插件</p><blockquote><p>官方的安装与配置</p><p><a href="https://github.com/rozbo/hexo-abbrlink">rozbo/hexo-abbrlink: create one and only link for every post for hexo (github.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="hexo" scheme="https://brraida.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>制作hexo博客的rss源</title>
    <link href="https://brraida.github.io/posts/d56f63a7/"/>
    <id>https://brraida.github.io/posts/d56f63a7/</id>
    <published>2021-09-02T03:49:52.000Z</published>
    <updated>2021-09-02T05:52:45.735Z</updated>
    
    <content type="html"><![CDATA[<p>为自己的hexo博客制作rss源。</p><p>使用的是hexo的<code>hexo-generator-feed</code>插件。</p><blockquote><p>官方文档与相关配置信息链接:</p><p><a href="https://github.com/hexojs/hexo-generator-feed">hexojs/hexo-generator-feed: Feed generator for Hexo. (github.com)</a></p></blockquote><p>在_config.yml文件中,在Extensions中添加配置（便于管理）。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Feed Atomfeed:  enable: true  type: atom  path: atom.xml  limit: false  hub:  content: true  content_limit:   content_limit_delim:   order_by: -date  icon:   autodiscovery: true  template:</code></pre></div><p>​    运行<code>hexo clean &amp;&amp; hexo g</code>，即可在根目录下看到public文件夹，在public文件夹下有atom.xml则制作成功。    在自己的博客主页地址后面加**/atom.xml**，即可看源信息。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="rss" scheme="https://brraida.github.io/tags/rss/"/>
    
    <category term="hexo" scheme="https://brraida.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>右键新建Markdown文件</title>
    <link href="https://brraida.github.io/posts/dedab3/"/>
    <id>https://brraida.github.io/posts/dedab3/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-09-07T04:56:17.824Z</updated>
    
    <content type="html"><![CDATA[<p>新建一个<code>txt</code>文本，写入:</p><div class="code-wrapper"><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\.md]@&#x3D;&quot;Typora.md&quot;&quot;Content Type&quot;&#x3D;&quot;text&#x2F;markdown&quot;&quot;PerceivedType&quot;&#x3D;&quot;text&quot;[HKEY_CLASSES_ROOT\.md\ShellNew]&quot;NullFile&quot;&#x3D;&quot;&quot;</code></pre></div><p>然后修改<code>.txt</code>后缀为  <code>.reg</code>的注册表文件。</p><p>双击运行。</p><p>参考链接:</p><p><a href="https://www.cnblogs.com/zhoujiayingvana/p/12357812.html">Typora添加右键新建Markdown文件 - 墨莲玦 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="Markdown" scheme="https://brraida.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://brraida.github.io/posts/4a17b156/"/>
    <id>https://brraida.github.io/posts/4a17b156/</id>
    <published>2021-08-14T09:04:08.230Z</published>
    <updated>2021-09-02T05:47:42.180Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ttrss</title>
    <link href="https://brraida.github.io/posts/b4463054/"/>
    <id>https://brraida.github.io/posts/b4463054/</id>
    <published>2021-08-02T01:05:54.000Z</published>
    <updated>2022-02-21T06:47:28.893Z</updated>
    
    <content type="html"><![CDATA[<p>​    第一次部署ttrss可能没有那么简单，需要耐点心。</p><p>​    我不用宝塔面板，环境都是自己搭的，所以会需要很多时间。用宝塔面板会比较简单(本来之后想搞宝塔面板的，但是我搭好了一些环境，而宝塔面板的官方文档说要“干净”的操作系统，由此作罢。)</p><blockquote><p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html">宝塔Linux面板安装教程 - 2021年6月4日更新 - 7.6.0正式版 - Linux面板 - 宝塔面板论坛 (bt.cn)</a></p></blockquote><p>这位大佬就是用宝塔面板搞定的，还有<strong>视频教程</strong>，很nice。</p><blockquote><p><a href="https://blog.laoda.de/archives/tinytinyrss">【服务器能干什么】二十分钟搭建一个属于自己的RSS服务 - 二十五画生 (laoda.de)</a></p></blockquote><hr><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li><p>一台服务器 (我用的是腾讯云)</p></li><li><p>一个已经能解析的域名 (在这里用于隐藏端口和上ssl证书)</p></li><li><p>nginx (用于反向代理)</p></li><li><p>docker (下载镜像)</p></li><li><p>docker-compose (用于执行一堆docker指令)</p></li></ul><hr><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>  我也没有搞得很清楚，就谈谈我已知的。首先说明一点，可以不用域名，直接使用 <strong>IP:port</strong> 来进行访问，但是我记得ttrss有说，信息传输是不安全的，推荐上ssl。然后也看到诸多大佬教程都进行了https的配置。</p><p>  OK，言归正传。根据</p><blockquote><p><a href="https://cloud.tencent.com/document/product/243/19630#.E6.98.AF.E5.90.A6.E9.9C.80.E8.A6.81.E5.A4.87.E6.A1.88.E7.9A.84.E5.88.A4.E6.96.AD.E6.9D.A1.E4.BB.B6.E6.98.AF.E5.9F.9F.E5.90.8D.E8.BF.98.E6.98.AF-80-.E7.AB.AF.E5.8F.A3.EF.BC.9F">网站备案 是否需要备案 - 常见问题 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><p>中的<img src="/img/article/ttrss/%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88.png">这些信息，可知内陆服务器要进行web服务是需要备案的。所以我觉得如果搞个人网站的话，推荐香港服务器。</p><blockquote><p><a href="https://cloud.tencent.com/document/product/243/19633">网站备案 备案流程 - 常见问题 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><hr><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>官网安装教程:</p><blockquote><p><a href="https://nginx.org/en/linux_packages.html#RHEL-CentOS">nginx: Linux packages</a></p></blockquote><hr><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker安装教程</p><blockquote><p><a href="https://cloud.tencent.com/document/product/213/46000">云服务器 搭建 Docker - 最佳实践 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><hr><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>docker-compose安装教程</p><blockquote><p><a href="https://docs.docker.com/compose/install/">Install Docker Compose | Docker Documentation</a></p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>ttrss官网教程</p><p><a href="https://ttrss.henry.wang/zh/">🐋 Awesome TTRSS | 🐋 Awesome TTRSS (henry.wang)</a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载[docker-compose.yml](<a href="https://github.com/HenryQW/Awesome-TTRSS/blob/main/docker-compose.yml">Awesome-TTRSS/docker-compose.yml at main · HenryQW/Awesome-TTRSS (github.com)</a>)到一目录下。</p><p>用网上教程命令不行，我也不懂git命令。然后就粗暴的在根目录下创建了ttrss文件夹，命令如下:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ttrsscd ttrss</code></pre></div><p>然后在Windows下创建一个docker-compose.yml ,将代码复制进去，然后使用<strong>xftp 7</strong>上传文件到linux的ttrss目录下。(解释一下为什么不直接在ttrss下创建docker-compose.yml，然后复制代码到docker-compose.yml中。首先yaml文件是对空格敏感的；其次，我复制的时候，shell自动将最后后面几行自动注释了。启动配置就失败了，改空格又麻烦，所以就直接用xftp 7了。)</p><p>docker-compose.yml文件配置:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">version: &quot;3&quot;services:  service.rss:    image: wangqiru&#x2F;ttrss:latest    container_name: ttrss    ports:      - 181:80    environment:      - SELF_URL_PATH&#x3D;http:&#x2F;&#x2F;localhost:181&#x2F; # please change to your own domain      - DB_PASS&#x3D;ttrss # use the same password defined in &#96;database.postgres&#96;      - PUID&#x3D;1000      - PGID&#x3D;1000    volumes:      - feed-icons:&#x2F;var&#x2F;www&#x2F;feed-icons&#x2F;    networks:      - public_access      - service_only      - database_only    stdin_open: true    tty: true    restart: always  service.mercury: # set Mercury Parser API endpoint to &#96;service.mercury:3000&#96; on TTRSS plugin setting page    image: wangqiru&#x2F;mercury-parser-api:latest    container_name: mercury    networks:      - public_access      - service_only    restart: always  service.opencc: # set OpenCC API endpoint to &#96;service.opencc:3000&#96; on TTRSS plugin setting page    image: wangqiru&#x2F;opencc-api-server:latest    container_name: opencc    environment:      - NODE_ENV&#x3D;production    networks:      - service_only    restart: always  database.postgres:    image: postgres:13-alpine    container_name: postgres    environment:      - POSTGRES_PASSWORD&#x3D;ttrss # feel free to change the password    volumes:      - ~&#x2F;postgres&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data # persist postgres data to ~&#x2F;postgres&#x2F;data&#x2F; on the host    networks:      - database_only    restart: always  # utility.watchtower:  #   container_name: watchtower  #   image: containrrr&#x2F;watchtower:latest  #   volumes:  #     - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  #   environment:  #     - WATCHTOWER_CLEANUP&#x3D;true  #     - WATCHTOWER_POLL_INTERVAL&#x3D;86400  #   restart: alwaysvolumes:  feed-icons:networks:  public_access: # Provide the access for ttrss UI  service_only: # Provide the communication network between services only    internal: true  database_only: # Provide the communication between ttrss and database only    internal: true</code></pre></div><p>主要修改的地方是第九行,将localhost改成ip地址，其他可以先不动。先激动的试试行不行。</p></li><li><p>启动</p><p>在ttrss目录下执行如下命令:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker-compose up -d</code></pre></div><p>第一次会下载一些镜像，花费时间就一点。</p></li><li><p>查看</p><p>查看启动的镜像</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker ps</code></pre></div><p><img src="/img/article/ttrss/ttrss.png"></p><p>访问端口ip:181，可以就说明没什么问题了。</p><p>P.S. 为了安全，改一下第10行和第44行的密码，并且密码要一致。</p><p>重载docker-compose.yml，得先停、再编写、最后重启</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker-compse down #stopvim docker-compose.yml #writedocker-compose up -d #start</code></pre></div></li></ol><hr><h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p>​    ok,以上就搞定了可以使用ip加端口部署ttrss。</p><p>​    下面介绍的是nginx反向代理和上ssl锁。</p><p>​    我用的是腾讯云的域名，然后可以直接申请一个免费的ssl证书。</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>如果你是安装nginx官网安装的话，nginx的配置文件在/etc/nginx/nginx.conf。(想说一点，官网配置中，location块是分开的，和网上教程不太一样，目的是便于管理。不知道也无所谓。)</p><p>参考文档:</p><blockquote><p><a href="https://cloud.tencent.com/document/product/400/35244">SSL 证书 Nginx 服务器 SSL 证书安装部署 - 证书安装 - 文档中心 - 腾讯云 (tencent.com)</a></p></blockquote><p>因为是分开的，所以以上文档成了参考文档(不过，也差不多)。</p><ol><li><p>nginx.conf配置</p><p>在hhtp块下加上以下代码(也可以选择替换# Settings for a TLS enabled server.这注释下面的代码。)</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server &#123;    listen 443 ssl;    server_name sisilly.club;    ssl_certificate 1_sisilly.club_bundle.crt;    ssl_certificate_key 2_sisilly.club.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;#    location &#x2F; &#123;#        root html; #        index  index.html index.htm;#    &#125;&#125;</code></pre></div></li><li><p>location块配置</p><p>在default.d目录下创建一个ttrss.conf</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;ttrss.conf# bashlocation &#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;127.0.0.1:181&#x2F;;    rewrite ^&#x2F;(.*)$ &#x2F;$1 break;    proxy_redirect off;    proxy_set_header Host $host;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Upgrade-Insecure-Requests 1;    proxy_set_header X-Forwarded-Proto https;  &#125;</code></pre></div></li><li><p>测试、启动</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -tservice nginx start</code></pre></div><p>可能会报警告，只要在nginx.conf中的http块下加</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_headers_hash_max_size 51200;proxy_headers_hash_bucket_size 6400;</code></pre></div></li></ol><h3 id="ttrss的docker-compose-yml配置"><a href="#ttrss的docker-compose-yml配置" class="headerlink" title="ttrss的docker-compose.yml配置"></a>ttrss的docker-compose.yml配置</h3><p>​    将 第九行- SELF_URL_PATH=<a href="http://localhost:181/%EF%BC%8C%E6%94%B9%E6%88%90-">http://localhost:181/，改成-</a> SELF_URL_PATH=https://域名/</p><p>  至此，结束。后面就是ttrss的配置了。可以看大佬文章。<a href="https://blog.laoda.de/archives/tinytinyrss">【服务器能干什么】二十分钟搭建一个属于自己的RSS服务 - 二十五画生 (laoda.de)</a></p><p>你可能需要:</p><blockquote><p>[Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx配置文件详解</a>. Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为 全局块、events块和http块 。. 在http块中，又包含http全局块、多个server块。.,每个server块中，可以包含server全局块和多个location块。. 在同一配置块中嵌套的配置块，各个之间不存在次序关系。. 配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。. 同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。. 如果某个指令在两个不同层级的块中同时出现，则采用”就近原则”，即以较低层级块中的配置为准。.)</p></blockquote><hr><p>2021-08-21</p><p>​    实践之后进行理论填充。之前搭建的ttrss是没有开启防火墙的情况下，看了一些书籍之后，感受到了安全的重要性。所以进行防火墙的补充、遇到问题的解决办法和懒人脚本补充。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status firewalld # 防火墙状态systemctl stop firewalld   # 防火墙关闭systemctl start firewalld  # 防火墙开启firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent # 打开80端口firewall-cmd --list-all    # 查看防火墙开启的端口</code></pre></div><p>问题：PostgreSQL: Could not connect to server: TCP/IP connections on port 5432</p><p>​    ttrss用的是PostgreSQL，所以别忘记开5432端口。开启后，运行<code>docker-compose down</code>，将容器停下来，然后运行<code>service docker restart</code>，不然可能遇到<strong>ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule</strong>，然后就可以运行<code>docker-compose up -d</code>了。</p><p>​    大佬做好的一键安装脚本，容我膜拜一下。</p><blockquote><p><a href="https://www.ioiox.com/archives/139.html">https://www.ioiox.com/archives/139.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="rss" scheme="https://brraida.github.io/tags/rss/"/>
    
    <category term="ttrss" scheme="https://brraida.github.io/tags/ttrss/"/>
    
  </entry>
  
  <entry>
    <title>安装-redis</title>
    <link href="https://brraida.github.io/posts/6bcf3639/"/>
    <id>https://brraida.github.io/posts/6bcf3639/</id>
    <published>2021-07-22T11:05:58.000Z</published>
    <updated>2022-02-21T06:51:50.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该博客写于2021年7月22号</p></blockquote><p>腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>按官网的来就OK了。</p><p><a href="http://www.redis.cn/download.html">redis 6.0.6 下载 – Redis中国用户组（CRUG）</a></p><ol><li>下载、解压、编译</li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.6.tar.gztar xzf redis-6.0.6.tar.gz -C &#x2F;usr&#x2F;localcd &#x2F;usr&#x2F;local&#x2F;redis-6.0.6make</code></pre></div><ol start="2"><li>启动redis</li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;src&#x2F;redis-server</code></pre></div><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>​    主要是想讲这个，害，刚开始的时候，嫌麻烦，没弄。然后就被6379这个端口给搞了。</p><p>​    配置文件为redis.conf。</p><ol><li><p>更改端口</p><p>将port 6379改成其他端口号</p></li><li><p>以后台进程方式启动</p><p>修改daemonize no 为 daemonize yes</p><ol start="3"><li>设置redis远程连接、</li></ol><ul><li><p>如果选择不关闭防火墙，先放行端口</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">firewall-cmd --zone&#x3D;public --add-port&#x3D;8888&#x2F;tcp --permanentfire-cmd --reload</code></pre></div></li><li><p>如果用的是云服务器，你还需要放行安全组防火墙端口。</p></li><li><p>注释掉bind 127.0.0.1</p></li><li><p>设置redis远程连接密码:在requirepass foobard改成requirepass <your password></p></li></ul></li><li><p>启动redis,若redis已经启动，则先关闭。</p><p>查找redis的进程号:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ps -aux | grep redis</code></pre></div><p>杀死进程:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kill -9 &lt;PID&gt;</code></pre></div><p>启动新配置的redis:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;src&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis-6.0.6&#x2F;redis.conf</code></pre></div></li></ol><p><a href="https://baijiahao.baidu.com/s?id=1667197295239073048&wfr=spider&for=pc">（史上最详细）CentOS7环境下Redis安装部署 (baidu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="install" scheme="https://brraida.github.io/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>os-suspend</title>
    <link href="https://brraida.github.io/posts/c4a439f8/"/>
    <id>https://brraida.github.io/posts/c4a439f8/</id>
    <published>2021-07-08T01:22:18.000Z</published>
    <updated>2021-09-02T05:47:42.196Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天我想一个进程挂起，cpu要监督，所以简单的就想这个进程肯定有一部分是要占用内存的。其实，不然，cpu和内存是不能等价的。</p><p>​    进程挂起的结果是从内存转移到外存，所以<strong>挂起不占内存</strong>的。</p><p><a href="https://blog.csdn.net/weixin_37641832/article/details/83217104">操作系统——CPU和内存、挂起和阻塞_My Blogs-CSDN博客_挂起不释放cpu</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="os" scheme="https://brraida.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>hadoop&amp;spark安装</title>
    <link href="https://brraida.github.io/posts/1426aaf4/"/>
    <id>https://brraida.github.io/posts/1426aaf4/</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2022-02-21T06:45:30.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该博文写于2021-6-21</p></blockquote><p><strong>环境：腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</strong></p><h1 id="1-jdk下载与安装"><a href="#1-jdk下载与安装" class="headerlink" title="1.jdk下载与安装"></a>1.jdk下载与安装</h1><h2 id="1-1选择jdk"><a href="#1-1选择jdk" class="headerlink" title="1.1选择jdk"></a>1.1选择jdk</h2><p><img src="/img/article/hadoop&spark/Hadoop-%E9%80%89%E6%8B%A9jdk.png">                         </p><p>由Hadoop官方文档可知，最好下载java8。</p><p>下载： </p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;java&#x2F;jdk&#x2F;8u181-b13&#x2F;jdk-8u181-linux-x64.tar.gz</code></pre></div><h2 id="1-2解压"><a href="#1-2解压" class="headerlink" title="1.2解压"></a>1.2解压</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar zxvf jdk-8u181-linux-x64.tar.gz &#x2F;usr&#x2F;local  #安装软件最好这个位置，便于管理</code></pre></div><h2 id="1-3重命名"><a href="#1-3重命名" class="headerlink" title="1.3重命名"></a>1.3重命名</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv jdk-8u181-linux-x64.tar.gz jdk8 </code></pre></div><h2 id="1-4环境配置"><a href="#1-4环境配置" class="headerlink" title="1.4环境配置"></a>1.4环境配置</h2> <div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> vim ~&#x2F;.bashrc #默认你下了vim了 # java environmentexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libexport PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH# :wq保存退出</code></pre></div><h2 id="1-5环境变量生效"><a href="#1-5环境变量生效" class="headerlink" title="1.5环境变量生效"></a>1.5环境变量生效</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ~.&#x2F;bashrc</code></pre></div><h2 id="1-6验证"><a href="#1-6验证" class="headerlink" title="1.6验证"></a>1.6验证</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">java -version</code></pre></div><p>  PS：</p><p>​    1.如果之前安装过jdk，然后查询的java版本与下载的不一样，可能在”/etc/profile”设置了永久生效的环境变量。只要编辑”/etc/profile”中的相关内容就行了。</p><p>​    2.java8就是java1.8.x系列。</p><hr><h1 id="2-Hadoop作用、安装与配置"><a href="#2-Hadoop作用、安装与配置" class="headerlink" title="2.Hadoop作用、安装与配置"></a>2.Hadoop作用、安装与配置</h1><p>  <strong>是一个能够对大量数据进行分布式处理的软件框架。</strong></p><h2 id="2-1-Hadoop下载"><a href="#2-1-Hadoop下载" class="headerlink" title="2.1 Hadoop下载"></a>2.1 Hadoop下载</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;mirrors.bfsu.edu.cn&#x2F;apache&#x2F;hadoop&#x2F;common&#x2F;stable&#x2F;hadoop-3.3.0.tar.gz</code></pre></div><h2 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar zxvf hadoop-3.3.0.tar.gz &#x2F;usr&#x2F;local</code></pre></div><h2 id="2-3-重命名"><a href="#2-3-重命名" class="headerlink" title="2.3 重命名"></a>2.3 重命名</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv hadoop-3.3.0 hadoop</code></pre></div><h2 id="2-4-环境变量设置"><a href="#2-4-环境变量设置" class="headerlink" title="2.4 环境变量设置"></a>2.4 环境变量设置</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~.&#x2F;bashrc# hadoop environmentexport HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoopexport HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;nativeexport PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbinexport JAVA_LIBRAY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;lib&#x2F;native# :wq 保存退出</code></pre></div><h2 id="2-5-环境变量生效"><a href="#2-5-环境变量生效" class="headerlink" title="2.5 环境变量生效"></a>2.5 环境变量生效</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ~.&#x2F;bashrc</code></pre></div><h2 id="2-6-验证"><a href="#2-6-验证" class="headerlink" title="2.6 验证"></a>2.6 验证</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hadoop version</code></pre></div><hr><h1 id="3-Hadoop伪分布式模式配置"><a href="#3-Hadoop伪分布式模式配置" class="headerlink" title="3.Hadoop伪分布式模式配置"></a>3.Hadoop伪分布式模式配置</h1><h2 id="3-1-Hadoop目录结构"><a href="#3-1-Hadoop目录结构" class="headerlink" title="3.1 Hadoop目录结构:"></a>3.1 Hadoop目录结构:</h2><ol><li><p>bin(工具程序目录) </p></li><li><p>etc/hadoop(配置文件目录)</p></li><li><p>sbin(服务程序目录，主要为服务启停脚本)</p></li><li><p>…(其他暂时用不到)</p></li></ol><h2 id="3-2-修改各种配置文件-etc-hadoop"><a href="#3-2-修改各种配置文件-etc-hadoop" class="headerlink" title="3.2 修改各种配置文件(etc/hadoop)"></a>3.2 修改各种配置文件(etc/hadoop)</h2><ul><li>修改hadoop-env.sh</li></ul><div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8# 解决Unable to load native-hadoop library for your platform...export HADOOP_OPTS&#x3D;&quot;-Djava.library.path&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;lib&#x2F;native&quot;</code></pre></div><ul><li>修改core-site.xml</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;configuration&gt;     &lt;property&gt;       &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;       &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;       &lt;description&gt;Abase for other temporary directories.&lt;&#x2F;description&gt;     &lt;&#x2F;property&gt;     &lt;property&gt;       &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;       &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;      &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div><ul><li>修改hdfs-site.xml</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;configuration&gt;    &lt;property&gt;       &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;       &lt;value&gt;1&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;    &lt;property&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div><h2 id="3-3-测试HDFS"><a href="#3-3-测试HDFS" class="headerlink" title="3.3 测试HDFS"></a>3.3 测试HDFS</h2><ul><li>NameNode格式化</li></ul><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin&#x2F;hdfs namenode –format</code></pre></div><ul><li>启动ssh</li></ul><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service sshd start</code></pre></div><ul><li>启动dfs</li></ul><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-dfs.shjps</code></pre></div><p>​    以上是正确结果，在启动过程中可能会遇到:</p><ul><li>问题1：Error: Attempting to operate on hdfs namenode as root…</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%981.png"></p><p>​    原因：</p><blockquote><p>hadoop install for different user and you start yarn service for different user. OR in hadoop config’s hadoop-env.sh specified HDFS_NAMENODE_USER and HDFS_DATANODE_USER  user is something else.</p></blockquote><p>​    解决方法:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim &#x2F;etc&#x2F;profile#在profile中填加以下内容export HDFS_NAMENODE_USER&#x3D;rootexport HDFS_DATANODE_USER&#x3D;rootexport HDFS_SECONDARYNAMENODE_USER&#x3D;rootexport YARN_RESOURCEMANAGER_USER&#x3D;rootexport YARN_NODEMANAGER_USER&#x3D;root#:wq 保存#生效source &#x2F;etc&#x2F;profile</code></pre></div><p>​    参考链接：</p><p><a href="https://blog.csdn.net/weixin_49736959/article/details/108897129">两种解决ERROR: Attempting to operate on hdfs namenode as root的方法_世幻水的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/ystyaoshengting/article/details/103026872">ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation._ystyaoshengting的专栏-CSDN博客</a></p><ul><li>问题2：Permission denied…</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%982.png"></p><p>​    原因：</p><p>​    ssh下的文件有访问权限</p><p>​    解决方法:</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进行免密协议设置:cd ~&#x2F;.ssh&#x2F;           # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa       # 会有提示，都按回车就可以cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权chmod 600 .&#x2F;authorized_keys  # 修改文件权限chmod 600 .&#x2F;id_rsachmod 644 id_rsa.pubchmod 644 .&#x2F;known_hosts #我第一次修改的时候有这个文件夹，第二次就没有。不过对后面配置不影响。# 修改sshd_config文件HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_keyRSAAuthentication yes  #这句没有，找的地方加上就行PubkeyAuthentication yesAuthorizedKeysFile .ssh&#x2F;authorized_keys# :wq保存# 命令行输入service sshd restart</code></pre></div><ul><li>问题3：无NameNode</li></ul><p><img src="/img/article/hadoop&spark/%E9%97%AE%E9%A2%983.png"></p><p>​    原因：查阅说是多次初始化造成的。</p><p>​    解决方法:</p><ol><li><p>首先</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;stop-all.sh</code></pre></div></li><li><p>删除原先创建的目录，即core-site.xml下配置的<name>hadoop.tmp.dir</name>所指向的目录。（我这里就是tmp目录）删除后要重新建立tmp空白目录。</p></li><li><p>格式化</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;bin&#x2F;hadoop namenode -format</code></pre></div></li><li><p>启动</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-all.sh</code></pre></div></li><li><p>用jsp查询时，就能看到NameNode进程</p><p><img src="/img/article/hadoop&spark/%E6%AD%A3%E7%A1%AE%E7%BB%93%E6%9E%9C.png"></p></li></ol><h2 id="3-4-查看hadoop页面"><a href="#3-4-查看hadoop页面" class="headerlink" title="3.4 查看hadoop页面"></a>3.4 查看hadoop页面</h2><p>​    浏览器输入: 公网ip地址:9870(如果是本地: <a href="http://localhost:9870/">http://localhost:9870</a>)</p><p>​    用云服务器还要记得开9870端口</p><p><img src="/img/article/hadoop&spark/hadoop%E9%A1%B5%E9%9D%A2.png"></p><p>​    可得如上图即Hadoop部署成功一大半</p><h2 id="3-5-YARN单机配置（配置文件也在etc-hadoop中）"><a href="#3-5-YARN单机配置（配置文件也在etc-hadoop中）" class="headerlink" title="3.5 YARN单机配置（配置文件也在etc/hadoop中）"></a>3.5 YARN单机配置（配置文件也在etc/hadoop中）</h2><ul><li>修改mapred-site.xml</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">   &lt;configuration&gt;     &lt;property&gt;       &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;       &lt;value&gt;yarn&lt;&#x2F;value&gt;      &lt;&#x2F;property&gt;     &lt;property&gt;         &lt;name&gt;yarn.app.mapreduce.am.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;       &lt;&#x2F;property&gt;       &lt;property&gt;        &lt;name&gt;mapreduce.map.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;       &lt;&#x2F;property&gt;       &lt;property&gt;        &lt;name&gt;mapreduce.reduce.env&lt;&#x2F;name&gt;        &lt;value&gt;HADOOP_MAPRED_HOME&#x3D;$&#123;HADOOP_HOME&#125;&lt;&#x2F;value&gt;     &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div><ul><li>修改yarn-site.xml</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> &lt;configuration&gt;    &lt;property&gt;       &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;       &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt;</code></pre></div><h2 id="3-6-查看资源管理页面"><a href="#3-6-查看资源管理页面" class="headerlink" title="3.6 查看资源管理页面"></a>3.6 查看资源管理页面</h2><p>   运行</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;sbin&#x2F;start-all.sh</code></pre></div><p>​    打开网址:</p><p>​    公网ip地址:8080（记得开8080端口）</p><p><img src="/img/article/hadoop&spark/spark-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2.png"></p><p>​    自此，Hadoop配置完成</p><h1 id="4-Scala安装与配置"><a href="#4-Scala安装与配置" class="headerlink" title="4.Scala安装与配置"></a>4.Scala安装与配置</h1><p><img src="/img/article/hadoop&spark/spark-scala%E9%80%89%E6%8B%A9.png"> </p><p>可以看出安装spark之前还要安装一个Scala。</p><h2 id="4-1-下载-在-usr-local目录下下载，推荐"><a href="#4-1-下载-在-usr-local目录下下载，推荐" class="headerlink" title="4.1 下载(在/usr/local目录下下载，推荐)"></a>4.1 下载(在/usr/local目录下下载，推荐)</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;downloads.lightbend.com&#x2F;scala&#x2F;2.12.12&#x2F;scala-2.12.12.tgz</code></pre></div><h2 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar zxvf scala-2.12.12.tgzvim &#x2F;etc&#x2F;profile  #scala environmentexport SCALA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;scala-2.12.12&quot;export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$SCALA_HOME&#x2F;bin#wq</code></pre></div><h2 id="4-3-环境有效"><a href="#4-3-环境有效" class="headerlink" title="4.3 环境有效"></a>4.3 环境有效</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source &#x2F;etc&#x2F;profile</code></pre></div><h2 id="4-6-验证"><a href="#4-6-验证" class="headerlink" title="4.6 验证"></a>4.6 验证</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">scala -version</code></pre></div><h1 id="5-spark安装与配置"><a href="#5-spark安装与配置" class="headerlink" title="5. spark安装与配置"></a>5. spark安装与配置</h1><p>​    Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。Spark是UC Berkeley AMP lab (加州大学伯克利分校的AMP实验室)所开源的类Hadoop MapReduce的通用并行框架，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</p><h2 id="5-1-下载-在-usr-local目录下下载，推荐"><a href="#5-1-下载-在-usr-local目录下下载，推荐" class="headerlink" title="5.1 下载(在/usr/local目录下下载，推荐)"></a>5.1 下载(在/usr/local目录下下载，推荐)</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;spark&#x2F;spark-3.1.2&#x2F;spark-3.1.2-bin-hadoop3.2.tgz </code></pre></div><h2 id="5-2-解压"><a href="#5-2-解压" class="headerlink" title="5.2 解压"></a>5.2 解压</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar xzvf spark-3.1.2-bin-hadoop3.2 spark</code></pre></div><h2 id="5-3-重命名"><a href="#5-3-重命名" class="headerlink" title="5.3 重命名"></a>5.3 重命名</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv  spark-3.1.2-bin-hadoop3.2 spark</code></pre></div><h2 id="5-4-配置环境变量"><a href="#5-4-配置环境变量" class="headerlink" title="5.4 配置环境变量"></a>5.4 配置环境变量</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> vim ~&#x2F;.bashrcexport SPARK_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;sparkexport PATH&#x3D;$PATH: $&#123;SPARK_HOME&#125;&#x2F;bin</code></pre></div><h2 id="5-5-环境生效"><a href="#5-5-环境生效" class="headerlink" title="5.5 环境生效"></a>5.5 环境生效</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source &#x2F;.bashrc</code></pre></div><h2 id="5-6-配置spark（spark-conf）"><a href="#5-6-配置spark（spark-conf）" class="headerlink" title="5.6 配置spark（spark/conf）"></a>5.6 配置spark（spark/conf）</h2><p>​    修改spark-env.sh(原本没有，但是有spark-env.sh.template,可以选择复制或是重建)</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim spark-env.shexport LD_LIBRARY_PATH&#x3D;$JAVA_LIBRARY_PATHexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk8export SPARK_MASTER_IP&#x3D;localhostexport SPARK_WORKER_MEMORY&#x3D;4g</code></pre></div><h2 id="5-7启动spark"><a href="#5-7启动spark" class="headerlink" title="5.7启动spark"></a>5.7启动spark</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;usr&#x2F;local&#x2F;spark&#x2F;sbin&#x2F;start-all.shjps</code></pre></div><p><img src="/img/article/hadoop&spark/spark-%E9%BB%91%E7%9B%92%E5%AD%90%E6%98%BE%E7%A4%BA.png"></p><p>​    结果如上。</p><p>​    打开网址: 公网ip地址:8080(记得开8080端口)</p><p><img src="/img/article/hadoop&spark/spark-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA.png"></p><p>配置成功，自此结束</p><h2 id="5-8-启动pyspark"><a href="#5-8-启动pyspark" class="headerlink" title="5.8 启动pyspark"></a>5.8 启动pyspark</h2><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pyspark --master local[2]</code></pre></div><p>参考链接：</p><p>[WSL搭建Hadoop与Spark环境_文艺圈不知名刘先生-CSDN博客](<a href="https://blog.csdn.net/huiruwei">https://blog.csdn.net/huiruwei</a>    1020/article/details/115033974)</p><h1 id="6．测试spark"><a href="#6．测试spark" class="headerlink" title="6．测试spark"></a>6．测试spark</h1><p>博主也是刚玩，不会同时测试两个。所以就测试一下spark的并行运算能力。  博主会一点点python，所以选择pyspark。也可以使用scala或java。</p><p>  pi.py文件代码为(蒙特卡洛方法):</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyspark import SparkContextimport random1sc&#x3D;SparkContext(&quot;local&quot;,&quot;firstapp&quot;)def inside(p):     x, y &#x3D; random.random(), random.random()     return x*x + y*y &lt; 1NUM_SAMPLES&#x3D;10000count &#x3D; sc.parallelize(range(0, NUM_SAMPLES)) &#x2F;          .filter(inside).count()print(&quot;Pi is roughly %f&quot; % (4.0 * count &#x2F; NUM_SAMPLES))</code></pre></div><p>  命令行执行spark-submit pi.py</p><p>参考链接：</p><p><a href="http://spark.apache.org/examples.html">Examples | Apache Spark</a></p><p><a href="https://www.jianshu.com/p/5a42fe0eed4d">大数据入门与实战-PySpark的使用教程 - 简书 (jianshu.com)</a>    </p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="hadoop" scheme="https://brraida.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>py-lambda</title>
    <link href="https://brraida.github.io/posts/69805bbd/"/>
    <id>https://brraida.github.io/posts/69805bbd/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2021-09-02T05:47:42.189Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天复习到了定积分，重新学了定积分的概念。迫不及待的使用python的lambda来实验实验。</p><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%861.jpg"></p><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%862.jpg"></p><p><img src="/img/article/py-lambda/%E5%AE%9A%E7%A7%AF%E5%88%863.jpg"></p><blockquote><p>lambda[arg1[,arg2,arg3…argn]]:expression</p><p>返回的是一个方法</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getResult(a, b, n):    fx &#x3D; lambda x: x**2    gap &#x3D; (b - a) &#x2F; n    res &#x3D; 0    for i in range(n):        res +&#x3D; fx(a + i * gap + gap &#x2F; 2) * gap    return resprint(getResult(1, 2, 1000))</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一些基础linux指令</title>
    <link href="https://brraida.github.io/posts/72475525/"/>
    <id>https://brraida.github.io/posts/72475525/</id>
    <published>2021-06-12T16:00:00.000Z</published>
    <updated>2021-09-02T05:47:42.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><ul><li>修改文件名或目录名</li></ul><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv oldFileName(oldDirectoryName) newFileName(newDirectoryName)</code></pre></div><ul><li>查看端口</li></ul><p><a href="https://blog.csdn.net/qq_41675254/article/details/85208057">Linux查看端口使用状态、关闭端口及配置端口方法 详细_会发抖的秒表的博客-CSDN博客_linux 端口</a></p><p>​    lsof -i:端口号</p><p>​    losf -i        #查看全部</p><ul><li><p>vim查找</p><p><strong>:/关键词</strong> 回车开始查找，按n查找下一个</p><p><strong>:数字</strong> 回车到某行</p></li></ul><ul><li><p>查看已开放端口</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">firewall-cmd --list-all</code></pre></div></li><li><p>防火墙开放端口（开放端口后需要重载防火墙）</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanentfirewall-cmd --reload</code></pre></div></li><li><p>修改密码</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">passwd &lt;usrname&gt;</code></pre></div></li><li><p>修改主机名</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hostnamectl set-hostname &lt;newhostname&gt;</code></pre></div></li></ul><hr><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul><li><p>查看docker内全部ip地址</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker inspect --format&#x3D;&#39;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range.NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; $(docker ps -aq)</code></pre></div></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows快捷键</title>
    <link href="https://brraida.github.io/posts/459f9e41/"/>
    <id>https://brraida.github.io/posts/459f9e41/</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2022-02-21T06:49:10.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><ol><li>alt+tab 快速切换窗口，松开就切换</li><li>windows+tab 切换窗口</li><li>alt+ctrl+tab 切换窗口，可以停留</li><li>ctrl+shift 切换键盘</li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="instruct" scheme="https://brraida.github.io/tags/instruct/"/>
    
  </entry>
  
  <entry>
    <title>py study note</title>
    <link href="https://brraida.github.io/posts/a29203f1/"/>
    <id>https://brraida.github.io/posts/a29203f1/</id>
    <published>2021-06-06T16:00:00.000Z</published>
    <updated>2021-09-02T05:47:42.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>6月7号    :sunny:</p></blockquote><h2 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承(inheritance)"></a>继承(inheritance)</h2><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>​    @staticmethod</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>​    @classmethod</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>​    类方法的第一个参数必须是指向本身的引用，而静态方法可以没有任何参数。</p><hr><h4 id="受保护变量和方法-protected"><a href="#受保护变量和方法-protected" class="headerlink" title="受保护变量和方法(protected)"></a>受保护变量和方法(protected)</h4><p>​    单下划线</p><ol><li>受保护的变量能在本类和子类里被使用</li><li>受保护的方法不能在非子类中调用</li></ol><p>​    </p><h4 id="私有变量和方法-private"><a href="#私有变量和方法-private" class="headerlink" title="私有变量和方法(private)"></a>私有变量和方法(private)</h4><p>​    双下划线</p><hr><h2 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h2><p>​    定义：实现同一个功能的方法可以有不同的表现形态。</p><p>​    note：</p><ol><li>方法同名但参数类型不同，或者同一个方法能适应于不同类型的调式场景。</li><li>不允许两个方法同名但参数个数不同。（java是允许的）</li></ol><hr><h2 id="import-amp-amp-module"><a href="#import-amp-amp-module" class="headerlink" title="import &amp;&amp; module"></a>import &amp;&amp; module</h2><p>​    <strong>modules</strong>: </p><ol><li>自定义模块</li><li>内置标准模块</li><li>开源模块      <a href="https://pypi.org/">PyPI · The Python Package Index</a></li></ol><h3 id="导入现有模块"><a href="#导入现有模块" class="headerlink" title="导入现有模块"></a>导入现有模块</h3><p>​    <strong>使用方式</strong></p><ol><li><p>import moduleName as elseName</p><p>e.g import numpy as np</p></li><li><p>from moduleName import className(methodName/propertyName)</p><p>e.g from numpy import sin</p></li></ol><h3 id="导入包中模块"><a href="#导入包中模块" class="headerlink" title="导入包中模块"></a>导入包中模块</h3><p>​    如果<strong>以模块的形式复用代码</strong>出现了模块冲突的情况，则无法导入<strong>实现功能不同但是名字相同</strong>的模块，为了解决这个问题，可以用<strong>包的形式</strong>来复用现有功能。</p><p>可以导入整个模块也可以精确导入某个模块的某个方法，速度和范围的差别。</p><hr><h2 id="isinstance-amp-amp-type"><a href="#isinstance-amp-amp-type" class="headerlink" title="isinstance() &amp;&amp; type()"></a>isinstance() &amp;&amp; type()</h2><blockquote><p>用法：</p><p>isinstance(object,classinfo)</p></blockquote><blockquote><p>用法：</p><p>type(object)</p></blockquote><blockquote><p>isinstance() 与 type() 区别：</p><ul><li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p></li><li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li></ul><p><strong>如果要判断两个类型是否相同推荐使用 isinstance()。</strong></p></blockquote><hr><blockquote><p>6月8号    :sunny:</p></blockquote><h2 id="异常-exception"><a href="#异常-exception" class="headerlink" title="异常(exception)"></a>异常(exception)</h2><p>​    处理原则:出现异常不要紧，但要把异常影响范围限制到最小。</p><p>​    实现要点：</p><ol><li>正确的提示异常信息。</li><li>合理监控和设置监控范围和异常处理的措施。</li><li>使用finally从句回收系统资源。</li></ol><h3 id="常用的异常处理类（被动）"><a href="#常用的异常处理类（被动）" class="headerlink" title="常用的异常处理类（被动）"></a>常用的异常处理类（被动）</h3><table><thead><tr><th>异常处理类名</th><th align="left">触发场景</th></tr></thead><tbody><tr><td>IndexError</td><td align="left">索引出错触发</td></tr><tr><td>ValueError</td><td align="left">类型参数正确，但返回值不符合预期是会触发</td></tr><tr><td>TypeError</td><td align="left">函数参数类型不正确时会触发</td></tr><tr><td>ZeroDivisionError</td><td align="left">除零出错</td></tr><tr><td>AttributeError</td><td align="left">引用属性错误触发</td></tr><tr><td>OSError</td><td align="left">无法完成操作系统级的任务时，会触发该类异常。(无法打开文件)</td></tr><tr><td>FloatingPointError</td><td align="left">浮点类计算错误</td></tr><tr><td>OverflowError</td><td align="left">数值运算时超过此种类数值的最大范围</td></tr><tr><td>UnicodeTranslateErrror</td><td align="left">Unicode转换时出错</td></tr></tbody></table><h3 id="Raise（主动）"><a href="#Raise（主动）" class="headerlink" title="Raise（主动）"></a>Raise（主动）</h3><p>​    自定义的异常描述信息会更具有操作性。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def divide(x, y):    if y &#x3D;&#x3D; 0:        raise Exception(&#39;divisor is 0&#39;)    try:        return x &#x2F; y    except TypeError:        raise Exception(&#39;parameters Type error&#39;)try:    divide(1, 0)except Exception as e:    print(e)try:    divide(1, &#39;1&#39;)except Exception as e:    print(e)</code></pre></div><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><blockquote><p>Python 垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。</p></blockquote><p>​    作用：资源回收(比如关闭文件、数据库连接等这些的工作)</p><p>​    功能：无论try块是否发生异常，最终都要进入finally语句，并执行其中的代码块。</p><p>参考链接：<a href="http://c.biancheng.net/view/2316.html">Python try except finally：资源回收 (biancheng.net)</a></p><p>​    有点意思的地方</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def funcWithFinally():    try:        print(&quot;in try&quot;)        return &quot;try end&quot;    finally:        print(&quot;in finally&quot;)        return &quot;finally end&quot;print(funcWithFinally())</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-tex" data-language="tex"><code class="language-tex">输出结果:in tryin finallyfinally end</code></pre></div><p>​    说明第七行比第四行提前执行了。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def funcWithFinally():    try:        print(&quot;in try&quot;)        return &quot;try end&quot;    finally:        print(&quot;in finally&quot;)print(funcWithFinally())</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-tex" data-language="tex"><code class="language-tex">输出结果:in tryin finallytry end</code></pre></div><p>​    会回到第四行执行。</p><blockquote><p>6月9号    :sun_behind_large_cloud:</p></blockquote><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读取模式</td></tr><tr><td>w</td><td>写入模式。若文件不存在，则创建一个文件，写入；若文件存在，则清空再写入。</td></tr><tr><td>r+</td><td>读写模式。从文件头开始写，保留原文件中没有被覆盖的内容。</td></tr><tr><td>w+</td><td>读写模式。若文件不存在，则创建一个文件，写入；若文件存在，则清空再写入。</td></tr><tr><td>a</td><td>附加写模式(不可读)。若文件不存在，则创建一个文件；若文件存在，写入的数据会被加到文件末尾，即文件原来的内容会被保留。</td></tr><tr><td>a+</td><td>附加读写模式。若文件不存在，则创建一个文件；若文件存在，写入的数据会被加到文件末尾，即文件原来的内容会被保留。</td></tr><tr><td>b</td><td>二进制模式，非文本模式</td></tr></tbody></table><h3 id="复制和移动文件"><a href="#复制和移动文件" class="headerlink" title="复制和移动文件"></a>复制和移动文件</h3><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import os, shutildef moveFile(src, dest):    if not os.path.isfile(src):        print(&#39;file not exist!&#39; + src)    else:        fpath &#x3D; os.path.split(dest)[0]        if not os.path.exists(fpath):            os.makedirs(fpath)        shutil.move(src, dest)        print(&#39;finished moving&#39;)def copyFile(src, dest):    if not os.path.isfile(src):        print(&#39;file not exist!&#39; + src)    else:        fpath &#x3D; os.path.split(dest)[0]        if not os.path.exists(fpath):            os.makedirs(fpath)        shutil.copyfile(src, dest)    print(&#39;finished copy&#39;)srcForCopy &#x3D; &#39;D:\\3\\2.jpg&#39;destForCopy &#x3D; &#39;D:\\3\\22.jpg&#39;srcForMove &#x3D; &#39;D:\\3\\python1.txt&#39;destForMove &#x3D; &#39;D:\\3\\python3.txt&#39;copyFile(srcForCopy, destForCopy)# moveFile(srcForMove, destForMove)</code></pre></div><p>​    <strong>GET</strong></p><p>​    makedirs()    #递归创建目录</p><p>​    mkdir()    #创建一级目录</p><p>​    path.os.split(path) #返回一个数组，第一个元素是路径，第二个是文件名。</p><p>参考链接:</p><p>​    <a href="https://www.runoob.com/python/python-os-path.html">Python os.path() 模块 | 菜鸟教程 (runoob.com)</a></p><p>​    <a href="https://www.runoob.com/python/os-makedirs.html">Python os.makedirs() 方法 | 菜鸟教程 (runoob.com)</a></p><hr><blockquote><p>2021-6-13 </p></blockquote><h2 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h2><h3 id="urlopen方法"><a href="#urlopen方法" class="headerlink" title="urlopen方法"></a>urlopen方法</h3><blockquote><p>urllib.request.urlopen(url)    #GET</p><p>urllib.request.urlopen(url,data=None,[timeout]) #POST</p></blockquote><p>​    直接用urllib.request模块的urlopen（）获取页面，page的数据格式为bytes类型，需要decode（）解码，转换成str类型。反过来也就是说，在使用post这种方式的时候，data就要以字节形式做参传入。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import urllib.requeststockCode &#x3D; &#39;600895&#39;url &#x3D; &#39;http:&#x2F;&#x2F;quotes.money.163.com&#x2F;service&#x2F;chddata.html&#39;param &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;code&#39;: &#39;0&#39; + stockCode,                                      &#39;start&#39;: &#39;20210602&#39;,                                      &#39;end&#39;: &#39;20210602&#39;,                                      &#39;fields&#39;: &#39;TCLOSE;HIGH;LOW;TOPEN;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER&#39;&#125;),              encoding&#x3D;&#39;utf-8&#39;)response &#x3D; urllib.request.urlopen(url, data&#x3D;param, timeout&#x3D;10)print(response.read().decode(&#39;gbk&#39;))response.close()</code></pre></div><p>参考链接:</p><p><a href="https://blog.csdn.net/qq_41856814/article/details/99658108">Python3中urlopen()详解</a></p><h3 id="urlretrieve方法"><a href="#urlretrieve方法" class="headerlink" title="urlretrieve方法"></a>urlretrieve方法</h3><blockquote><p>urllib.request.urlretrieve(url,filename,data)    #取己所需，所以参考链接的更完整详细</p></blockquote><p>返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import urllib.requestdef getAndSaveStock(stockCodeList, path):    for stockCode in stockCodeList:        url &#x3D; &#39;http:&#x2F;&#x2F;quotes.money.163.com&#x2F;service&#x2F;chddata.html&#39;        param &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;code&#39;: &#39;0&#39; + stockCode,                                              &#39;start&#39;: &#39;20210602&#39;,                                              &#39;end&#39;: &#39;202106012&#39;,                                              &#39;fields&#39;: &#39;TCLOSE;HIGH;LOW;TOPEN;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER&#39;&#125;)                      , encoding&#x3D;&#39;utf8&#39;)        urllib.request.urlretrieve(url, path + stockCode + &#39;.csv&#39;, data&#x3D;param)stockCodeList &#x3D; []stockCodeList.append(&#39;600895&#39;)stockCodeList.append(&#39;600007&#39;)getAndSaveStock(stockCodeList, &#39;D:\\3\\&#39;)</code></pre></div><p>​    发现如果将第12行的’.csv’改成’.txt’也是可以的。真方便啊！记得我学csv的时候，还要用它的相关库，一行行写入。</p><p>参考链接:</p><p><a href="https://cloud.tencent.com/developer/article/1406358">urllib.request.urlretrieve()函数</a></p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p>​    作用：一般用来搜索和替换符合特定规则的文本。</p><blockquote><p>2021-6-14 :sunny:</p></blockquote><h4 id="常用正则字符"><a href="#常用正则字符" class="headerlink" title="常用正则字符"></a>常用正则字符</h4><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>开始标记</td></tr><tr><td>$</td><td>结束标记</td></tr><tr><td>+</td><td>匹配一次或多次</td></tr><tr><td>*</td><td>匹配零次或多次</td></tr><tr><td>[]</td><td>表示一个字符集</td></tr><tr><td>a-z</td><td>表示小写字母</td></tr><tr><td>|</td><td>表示“或”</td></tr><tr><td>{}</td><td>匹配指定字符n次</td></tr><tr><td>.</td><td>任意字符</td></tr><tr><td>？</td><td>非贪心</td></tr><tr><td>\w</td><td>匹配任何字母、数字和下划线</td></tr><tr><td>\d</td><td>匹配任何数字</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符</td></tr><tr><td>()</td><td>将位于()内的内容作为整体对待</td></tr></tbody></table><p><strong>匹配字符串一般用法：</strong></p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">myStr&#x3D;&#39;balaba&#39;myPattern&#x3D;&#39;\w+&#39;if re.match(myPattern,myStr):print(&#39;get&#39;)</code></pre></div><h4 id="正则表达式截取字符串"><a href="#正则表达式截取字符串" class="headerlink" title="正则表达式截取字符串"></a>正则表达式截取字符串</h4><p>​    绝了，发现自己以前根本不会截取字符串而是匹配字符串…</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import reprint(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;))print(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;)[0])print(re.split(&#39;&#x3D;&#39;, &#39;content&#x3D;hello&#39;)[1])str &#x3D; &#39;content&#x3D;code:(6000),price:(20)&#39;pattern &#x3D; re.compile(r&#39;[(](.*?)[)]&#39;#这个操作可以获取全部()内容，不包括()!print(re.findall(pattern, str))print(re.findall(r&#39;\((.*?)\)&#39;, str))#这个同理，就是用了转义字符rule &#x3D; r&#39;&lt;(.*?)&gt;&#39;print(re.findall(rule, &#39;&lt;vcontent&gt;&#x3D;&lt;ok?&gt;&#39;))#获取全部&lt;&gt;之间内容，不包括&lt;&gt;!print(re.findall(rule, &#39;&lt;vcontent&#x3D;&lt;ok?&gt;&#39;))print(re.findall(r&#39;a(.*?)a&#39;, &#39;acontenta &#x3D;&lt;ok?&gt;&#39;))#获取aa之间内容，不包括a!rule &#x3D; r&#39;&quot;(.*?)&quot;&#39;print(re.findall(rule, &#39;&quot;vcontent&quot;&#x3D;&lt;ok?&gt;&#39;))#获取“”之间内容str &#x3D; &#39;60001,10,12,15&#39;print(re.split(&#39;,&#39;, str))#split也可以用于re,见识短浅，以前以为只可用于strprint(str.split(&#39;,&#39;))</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>node.js安装</title>
    <link href="https://brraida.github.io/posts/63a2d85/"/>
    <id>https://brraida.github.io/posts/63a2d85/</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2022-02-21T06:47:59.682Z</updated>
    
    <content type="html"><![CDATA[<p>​    我终于知道为什么要下载安装包，而不是直接用yum源了。因为yum源里的版本可能会比较旧，去官网下载就不一样了，可以获取最新的、更好的版本。</p><blockquote><p>该博客写于2021年6月2号</p></blockquote><p>​    腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><p>​    嫌yum源太旧，去官网<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a>下载。</p><ol><li><p>下载</p><p>去官网看最新的或是最稳定的版本号，将下列语句的版本号（v14.17.0）改一下，执行。</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v14.17.0&#x2F;node-v14.17.0-linux-x64.tar.xz</code></pre></div><ol start="2"><li>解压</li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar zxvf node-v14.17.0-linux-x64.tar.xz</code></pre></div><ol start="3"><li><p>移动</p><p>一般都是将软件放在/usr/local路径下（也可以自定义）</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv node-v14.17.0-linux-x64 &#x2F;usr&#x2F;local&#x2F;node-v14</code></pre></div><ol start="4"><li><p>软链接</p><p>就是快捷键一个意思</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -s &#x2F;usr&#x2F;local&#x2F;node-v14&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node # 添加软链</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node # 删除软链(如果不小心软链错了，先删除软链，再重新添加)</code></pre></div><ol start="5"><li>查看</li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node -vnpm -v</code></pre></div><ol start="6"><li><p>配置npm环境变量</p><p>将 <strong>/usr/local/node-v14/bin</strong> 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo &#39;export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v14&#x2F;bin:$PATH&#39; &gt;&gt; &#x2F;etc&#x2F;profile</code></pre></div><ol start="7"><li>生效环境变量</li></ol><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source &#x2F;etc&#x2F;profile</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="install" scheme="https://brraida.github.io/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装</title>
    <link href="https://brraida.github.io/posts/16fe430b/"/>
    <id>https://brraida.github.io/posts/16fe430b/</id>
    <published>2021-06-01T02:04:46.000Z</published>
    <updated>2022-02-21T06:52:14.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该博文写于2021.6.1</p></blockquote><p>​    腾讯云，centos7.6，linux3.10.0-1160.11.1.el7.x86_64</p><p>​    尝试了几种方法，在失败与成功之中，选出与这种配置最快最适合的方法。愿你早日顺利入坑。</p><ul><li><p>升级yum源</p><blockquote><p>yum -y update  //升级所有包的同时，也升级软件和系统内核</p></blockquote></li></ul><p>我是将镜像重置后，上来就升级，忘记快照了。不过也无所谓啦。</p><ul><li><p>安装nginx（别名：engine X）</p><blockquote><p>yum -y install nginx</p></blockquote></li></ul><p>没想到就安装成功了，不需要换源不需要balabala，不放心可以去查看版本和配置文件</p><ol><li><p>查看nginx版本</p><blockquote><p>nginx -v</p></blockquote></li><li><p>配置文件路径</p><blockquote><p>默认的网站目录为： /usr/share/nginx/html</p><p>默认的配置文件为：/etc/nginx/nginx.conf</p><p>自定义配置文件目录为: /etc/nginx/conf.d/</p></blockquote></li><li><p>查找linux文件</p></li></ol><p>​        which ngixn   //会在环境变量$PATH设置的目录里查找符合条件的文件</p><p>​        whereis nginx //会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件;只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><p>​        先关闭防火墙<strong>systemctl stop firewalld</strong>,然后启动它 <strong>systemctl start nginx</strong>,再在浏览器访问主机的ip地址，类似192.168.1.1，云服务器那个公网ip。</p><p><img src="/img/article/%E5%AE%89%E8%A3%85-nginx/nginx%E6%88%90%E5%8A%9F%E7%94%BB%E9%9D%A2.png"></p><p>​    可能使用Redhat安装nginx，所以显示界面和网上某些教程说显示nginx不一样。</p><p>​        </p><ul><li><p><strong>启动nginx</strong></p><blockquote><p>systemctl start nginx</p></blockquote></li><li><p><strong>停止nginx</strong></p><blockquote><p>systemctl stop nginx</p></blockquote></li><li><p><strong>重启nginx</strong></p><blockquote><p>systemctl restart nginx</p></blockquote></li><li><p><strong>查看nginx状态</strong></p><blockquote><p>systemctl status nginx</p></blockquote></li><li><p><strong>启用开机启动nginx</strong></p><blockquote><p>systemctl enable nginx</p></blockquote></li><li><p><strong>禁止开机启动nginx</strong></p><blockquote><p>systemctl disable nginx</p></blockquote></li><li><p><strong>检查配置文件</strong></p><blockquote><p>nginx -t    //要在配置好的文件的路径下运行次命令</p></blockquote></li><li><p><strong>重启nginx（更新配置文件）</strong></p><blockquote><p>service nginx reload</p></blockquote></li><li><p><strong>查看进程、PID等信息</strong></p><blockquote><p>lsof -i</p></blockquote></li><li><p><strong>查看进程占用端口号</strong></p><blockquote><p>lsof -i -P|grep nginx</p></blockquote></li><li><p><strong>使用端口号查询占用进程</strong></p><blockquote><p>losf -i</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="centos" scheme="https://brraida.github.io/tags/centos/"/>
    
    <category term="install" scheme="https://brraida.github.io/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>nginx相关记录</title>
    <link href="https://brraida.github.io/posts/dbc31271/"/>
    <id>https://brraida.github.io/posts/dbc31271/</id>
    <published>2021-05-31T00:49:59.000Z</published>
    <updated>2022-02-21T06:46:17.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该博文写于2021.5.31</p></blockquote><h2 id="nginx安装与部署"><a href="#nginx安装与部署" class="headerlink" title="nginx安装与部署"></a>nginx安装与部署</h2><p>​        本来想写nginx的安装，但是发现nginx的中文文档写得不错，然后会持续更新（这个太重要了）。也可以结合nginx的官方文档看。</p><p>​        偷个懒，放个链接好了：</p><ul><li><p>nginx中文文档：<a href="https://www.nginx.cn/">nginx</a></p></li><li><p>nginx官方文档：<a href="http://nginx.org/en/docs/">nginx documentation</a></p></li></ul><hr><h2 id="nginx概念"><a href="#nginx概念" class="headerlink" title="nginx概念"></a>nginx概念</h2><p>​        可能你和我一样，是用某个其他东西的时候用到nginx，但是却不知道这是个什么，能干什么，其特点是什么。我也是个小白，所以不敢误导。</p><p>​        贴几个我觉得讲得不错的链接：</p><ul><li><p><a href="https://juejin.cn/post/6844904129987526663#heading-16">连前端都看得懂的《Nginx 入门指南》 (juejin.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx - 知乎 (zhihu.com)</a></p></li></ul><hr><h2 id="自己遇到的问题"><a href="#自己遇到的问题" class="headerlink" title="自己遇到的问题"></a>自己遇到的问题</h2><p>​        讲讲自己遇到的一些问题，因为之前不是按照中文文档安装的，按照网上的一些教程，然后发现自己找不到配置路径。现在懂了之后，感觉自己就挺搞的。</p><p>​        <strong>nginx.conf路径问题</strong>：</p><p>​        我用的是centos7.6。有一种方法是先安装开发库，然后yum换源，然后直接安装nginx。此时的nginx配置文件在etc目录下的nginx里。(这个最简单的方法，我没有成功，好气哦，说“没有niginx包提供”)<strong>cd /etc</strong> 即可以进入etc目录。另一种方法是下载安装包，解压到指定目录，一般都会解压到 <strong>/usr/local</strong> 里，此时就在和这个目录下的nginx中的conf目录下。</p><p>​        <strong>nginx.d问题</strong></p><p>​        可能你还会遇到让你在nginx.d下创建其他的*.conf文件进行清晰明了的管理配置。但是解压安装的nginx是没有nginx.d文件夹的，需要自己创建。</p><p>​        在你的nginx.conf的http块下加一句话：</p><blockquote><p>include /etc/nginx/conf.d/*.conf;</p></blockquote><p>​        这句话的意思是在关联etc下nginx下的conf.d目录文件，后面那个是配置文件。所以你可以在任意目录下建立这个conf.d目录文件，只要关联上就好了。不过，一般在etc或是解压的nginx文件下建立cong.d目录文件（个人观点。看到的各种教程都是建立在这些位置。nginx目录好理解，跟随性么，好找也好删除；之后查了etc目录作用，原来各种配置文件一般都是放在这里，那么这也就好理解了。）</p><p>​        然后只要重新加载配置文件就可以了</p><blockquote><p>service nginx reload</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
    <category term="nginx" scheme="https://brraida.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="https://brraida.github.io/posts/430d67de/"/>
    <id>https://brraida.github.io/posts/430d67de/</id>
    <published>2021-05-18T12:48:09.000Z</published>
    <updated>2021-09-02T05:47:42.243Z</updated>
    
    <content type="html"><![CDATA[<p>2021-5-17</p><hr><ul><li>花了我100多大洋买了个服务器，搞起来！</li><li>将项目移植到其他地方，改了半天的绝对路径。突然发现绝对路径的好处。</li></ul><p>2021-6-9</p><hr><ul><li><p>YAML是一个可读性高，用来表达数据序列化的格式。</p></li><li><p>XML是一种标记电子文件使其具有结构性的标记语言。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="咋咋嘴" scheme="https://brraida.github.io/tags/%E5%92%8B%E5%92%8B%E5%98%B4/"/>
    
  </entry>
  
  <entry>
    <title>编译原理1</title>
    <link href="https://brraida.github.io/posts/cc129669/"/>
    <id>https://brraida.github.io/posts/cc129669/</id>
    <published>2021-05-18T12:47:30.000Z</published>
    <updated>2021-09-02T05:47:42.240Z</updated>
    
    <content type="html"><![CDATA[<p>DFA与NFA的区别    </p><ul><li><p>这两个的主要最明显的区别就是DFA经过某一路径，到达另一个状态是确定的、唯一的。而NFA不是，而是可以到达一个或是多个状态的。也就是说，DFA是NFA的一种特例。</p></li><li><p>DFA的某一路径是的值是没有空串的。（那时候不知道这一点，在NFA进行确定化的时候，经空串也进行了计算，大失败！）</p></li></ul><p>有时候吧，想对答案的地方都没有，以后将编译原理的作业整理，丢上来。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="编译原理" scheme="https://brraida.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>py指令</title>
    <link href="https://brraida.github.io/posts/c669871/"/>
    <id>https://brraida.github.io/posts/c669871/</id>
    <published>2021-05-18T09:27:08.000Z</published>
    <updated>2022-02-21T06:46:54.081Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在cmd窗口查看python</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">python --version</code></pre></div></li><li><p>查看安装模块或是库</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">pip list</code></pre></div></li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
    <category term="instruct" scheme="https://brraida.github.io/tags/instruct/"/>
    
  </entry>
  
  <entry>
    <title>py爆破</title>
    <link href="https://brraida.github.io/posts/3cc1efd6/"/>
    <id>https://brraida.github.io/posts/3cc1efd6/</id>
    <published>2021-05-18T09:27:08.000Z</published>
    <updated>2021-09-02T05:47:42.203Z</updated>
    
    <content type="html"><![CDATA[<p>​    有时候想白嫖一些资源，但是总会有些资源是压缩加密的。就因为这个，我对爆破很感兴趣。之后有学了python，所以就兴致冲冲地写了爆破脚本。记录一下遇到的问题和解决的方法。</p><p>​    首先，学信安的小伙伴和我讲有字典就简单，代码很简单的。所以我在github在找了如下的字典库。</p><blockquote><p><a href="https://github.com/YueYongDev/Blasting_dictionary">YueYongDev/Blasting_dictionary: 爆破字典 (github.com)</a></p></blockquote><p>​    之后cv网上代码，他用的是zipfile模块（python内置的模块）、rarfile模块(github大佬写的，接口和zipfile差不多)。然后出现问题。</p><h2 id="使用zipfile模块"><a href="#使用zipfile模块" class="headerlink" title="使用zipfile模块"></a>使用zipfile模块</h2><p>​    用zipfile不能解压不是用传统加密的文件。经过科学上网查询得到这样的解答与解决。</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/zipfile%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E7%AD%94.jpg"></p><p>​    <strong>AES</strong>：密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。</p><p>​    现在加密一般都是按这个标准。</p><h2 id="使用pyzipper模块"><a href="#使用pyzipper模块" class="headerlink" title="使用pyzipper模块"></a>使用pyzipper模块</h2><p>​    所以使用pyzipper模块代替zipfile模块。</p><p>​    给上可执行正确的代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyzipperf1 &#x3D; open(&#39;D:\\1\\pwd.txt&#39;, &#39;r&#39;)with pyzipper.AESZipFile(&#39;D:\\1\\test.zip&#39;, &#39;r&#39;) as f:    for i in f1:        i &#x3D; i.rstrip(&#39;\n&#39;)        f.pwd &#x3D; str.encode(i)        try:            f.extractall(&#39;D:\\1\\2&#39;)            print(&quot;The correct password is:&quot; + i)            break        except Exception:            passf1.close()</code></pre></div><h2 id="rarfile模块"><a href="#rarfile模块" class="headerlink" title="rarfile模块"></a>rarfile模块</h2><p>​    使用rarfile模块解压rar文件问题就多了。它解压其实借助的是电脑的解压软件的unrar.exe进行解压。(可以在pypi中查看此模块，可以得到此模块的相关信息与工作原理)</p><p>​    然后我嫌下载unrar太麻烦，还要配置环境变量等等操作，并且我本地用的是WinRAR，所以将WinRAR所在的路径加入环境就解决了。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rarfile path1 &#x3D; &#39;D:\\1\\2.rar&#39; despath &#x3D; &#39;D:\\1\\2&#39;  rf &#x3D; rarfile.RarFile(path1)rf.extractall(path&#x3D;despath)rf.close()</code></pre></div><p>​    经过测试，解压没有密码压缩的可以；解压加密的压缩包里面没有文件的可以。但是不可以解压加密的有文件的压缩包。编译错误显示下图所示：</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E6%98%BE%E7%A4%BA.png"></p><p>​    所以上rarfile这个项目查了一下，其他的使用者也遇到类似这样的问题。然后有人是这么解决的，如下图所示：</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/%E6%8F%90%E9%97%AE%E8%80%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png"></p><p>​    不过，这个14年提出来并解决的。我一个21年的，只能是借鉴参考了。看到后面，果然有个20年的朋友也有这样的问题。</p><p><img src="/img/article/py-%E7%88%86%E7%A0%B4/20%E5%B9%B4%E5%90%8C%E6%8F%90%E9%97%AE%E8%80%85.png"></p><p>​    所以大胆猜测，rarfile这个模块里面确实有些问题。</p><hr><p>​    同样的代码，我室友使用rarfile在他的电脑上跑出来了。</p><p>​    我是Windows10，python3.8.3，Pycharm，压缩软件WinRAR</p><p>​    室友用的是manjaro，python3.9.4，idle，压缩软件是系统自带的</p><hr><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>​    瞅我这暴脾气，最近考试月。考试月过了，我在搞一下。</p><ol><li>Windows下，下那个unrar，搞配置尝试</li><li>1不行就去CenOs7.4服务器搭个环境尝试</li><li>2不行我也开manjaro尝试</li><li>以上都失败，就可以砸电脑了</li></ol><p>搞成功地进一步设想。</p><ol><li>zip可以了，rar可以了，怎么可以不把它们整合在一起的道理呢。</li><li>爆破怎么可以不搞多线程呢。</li><li>python怎么可以不搞封装呢。</li><li>整个界面。</li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="python" scheme="https://brraida.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>word相关技巧</title>
    <link href="https://brraida.github.io/posts/a629f612/"/>
    <id>https://brraida.github.io/posts/a629f612/</id>
    <published>2021-05-12T02:03:46.000Z</published>
    <updated>2021-12-10T05:10:51.311Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近和小组合作完成os课设，每个人写的项目不一样，所以最后各自文档合并的时候就不得不进行排版。下面是我为了完成某个目的的word技巧的记录。</p><p>我用的是word版本是<strong>office 2016</strong></p><h1 id="一次性选择同类内容"><a href="#一次性选择同类内容" class="headerlink" title="一次性选择同类内容"></a>一次性选择同类内容</h1><p>​    大家都写了一级标题、二级标题、正文等，但是合并的时候发现一级标题、二级标题、正文字体、字号不一样。然后想要统一。若是一个个格式刷是不切实际的，效率低下。那么如何快速选择全部同类的内容呢？</p><p>可以点击如下图所示的地方，也可以快捷键<strong>ctrl+shift+alt+s</strong></p><p><img src="/img/article/office-word/%E5%9B%BE1.png"></p><p>然后右侧会出现<strong>样式</strong>工具栏，点击你想修改的类型</p><p><img src="/img/article/office-word/%E5%9B%BE2.png"></p><hr><h1 id="修改图片格式"><a href="#修改图片格式" class="headerlink" title="修改图片格式"></a>修改图片格式</h1><p>​    为了防止文档在其他电脑时图片发生错位的情况，我们一般会选择嵌入型。但是我们选择嵌入型的时候，有些图片没有露出全部，只露出了一点点。</p><p>​    这是因为段落设置的问题，主要原因是行距设定成了固定值。</p><p>​    段落设置如图所示。</p><p><img src="/img/article/office-word/%E5%9B%BE3.png"></p><p>​    然后只要将这两个值修分别修改成无和单倍行距就可以了。</p><p><img src="/img/article/office-word/%E5%9B%BE4.png"></p><hr><h1 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h1><p>​    有些页不需要页眉或是不需要横线，如何删除。</p><p>​    单纯的单页删除是很容易操作，但是我现在的情况是，后20页都需要页眉，并且页眉都已经弄好了。唯独要删除这页的页眉。如何用样式删除，那么文档的全部页眉都会被删除，这是达不到我的要求的。</p><p>​    我的解决方法如下。</p><p>​    A页为要修改的页，B为A的下一页。</p><ol><li>双击页眉部分，进入修改页眉模式。</li><li>在要修改A页的下一页（即光标在B页），取消<strong>链接到前一节</strong>选项。</li></ol><p><img src="/img/article/office-word/%E5%9B%BE5.png"></p><ol start="3"><li>回到A页，选中文字，如图操作。</li></ol><p><img src="/img/article/office-word/%E5%9B%BE6.png"></p><ol start="4"><li>删除文字，双击文章地方，退出页眉模式。</li><li>over</li></ol><h1 id="软回车"><a href="#软回车" class="headerlink" title="软回车"></a>软回车</h1><p>软回车的作用是把文字换行显示，但是并没有分段；硬回车是将文字分段。</p><p>​    有时需要将软回车（向下的箭头）改成硬件头（回车箭头），修改方法为：</p><ol><li><strong>ctrl</strong>+<strong>h</strong>，打开替换</li><li>软回车的表达式是<strong>^l</strong>(为小写的字母l)，硬回车的表达式为<strong>^p</strong>。输入，替换即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="word" scheme="https://brraida.github.io/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>linux用socket实现文件传输遇到的问题总结</title>
    <link href="https://brraida.github.io/posts/4f19d5af/"/>
    <id>https://brraida.github.io/posts/4f19d5af/</id>
    <published>2021-04-29T01:34:04.000Z</published>
    <updated>2022-02-21T06:46:00.048Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近在写linux作业，要求是这样的：</p><ol><li><p>实现一个网络文件传输工具，可以使用文件和目录的传输；</p></li><li><p>增加共享目录，可以增加和删除共享的目录和文件，供网络查看；</p></li><li><p>可以查看对方共享目录和文件，并选择下载；</p></li><li><p>可以向对方传送文件和目录，并且该文件和目录会自动被对方共享。</p></li></ol><p>​    然后使用socket完成了在本地上文件的传输，之后想使用不同主机尝试传输，发现不行。开始了查找原因之旅，解决了之后mark一下。</p><p><strong>我使用的linux是centos8.1.1911-x86_64</strong></p><p><strong>室友的是ubuntu20.0.4</strong>(版本记不清了)</p><h4 id="可能造成的原因"><a href="#可能造成的原因" class="headerlink" title="可能造成的原因"></a>可能造成的原因</h4><ol><li><p>校园网</p></li><li><p>防火墙</p></li><li><p>NAT、网桥</p></li></ol><hr><h4 id="校园网"><a href="#校园网" class="headerlink" title="校园网"></a>校园网</h4><p>​    这个就比较神奇了，我先扎个坑，以后有机会在解释。同学说校园网不是局域网，要同一局域网下才行。这不是局域网震惊我一整年。查了一下校园网就是局域网，他想表达的意思应该是校园网内部是一块块的，所以你可能在这一块，而室友的电脑在那一块，导致不能连接。<strong>mark！！！</strong> 我是不太信的，我之后看清楚socket和校园网、局域网再说话。</p><p>​    先按他是对的来，进行了同一路由器下实验。结果是失败的。</p><hr><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>​    这个听了就比较合理，以前做计网实验的时候，就是因为防火墙而导致ping不通另一台主机。</p><p>​    关闭防火墙出现了问题，这里记录一下。我装了<strong>火绒</strong>，然后按照百度的方法，根本就关闭不了防火墙。（不行的方法就应该早点下架。。。）</p><p>​    <strong>可行的方法:</strong></p><ol><li>打开控制面板（windows+r，然后输入control）</li><li>点击系统和安全</li><li>点击Windows Defender防火墙</li><li>点击启动或关闭Windows Defender防火墙</li><li>关闭就可以了</li></ol><p><img src="/img/article/linux%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/firewall.png"></p><p>​    这样子后，我就成功地和室友ping通了。但是文件传输还是不行。之后听另一个室友讲，可能是NAT的问题。因为弄网桥麻烦，所以我都是直接NAT的。</p><hr><h4 id="NAT、桥接"><a href="#NAT、桥接" class="headerlink" title="NAT、桥接"></a>NAT、桥接</h4><p>​    <del>以后有时间在写NAT和桥接是啥，</del></p><blockquote><p> <a href="https://www.cnblogs.com/wzzkaifa/p/6806843.html">桥接模式和NAT模式差别 - wzzkaifa - 博客园 (cnblogs.com)</a></p><p>一句话，就是桥接可以让虚拟机在网络中像一台独立的主机，拥有ip地址,即拥有了通信能力。</p></blockquote><p>现在开始配置网桥。</p><blockquote><p>​    <a href="https://blog.csdn.net/qq_47354826/article/details/114888325">2021/3/16 “VMware虚拟机网络配置—桥接模式”_一切因为是码农-CSDN博客</a></p></blockquote><p>​    这位博主写的很详细，大致过程都没有问题。不过在配置的时候，有一处需要更正。在进行网卡配置的时候，写的是ifcfg-ens33文件，而这个是可读文件，常规的 <strong>!wq</strong> 命令是保存不了的。这时要使用</p><blockquote><p>w ! sudo tee %</p></blockquote><p>​    命令才可以写入。</p><p>​    最后终于和室友socket成功。</p><hr><h4 id="说些其他"><a href="#说些其他" class="headerlink" title="说些其他"></a>说些其他</h4><p>​    虚拟机是桥接模式下，必须与主机的网关一样，不然后果就是连不上外网。所以如果电脑这是连校园网，配置的是校园网的网关。待会连热点，就会不能访问外网。</p><p>​    我感觉是可以自动配置的，但是现在不想捯饬了，之后对linux感兴趣了，就补一下。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="linux" scheme="https://brraida.github.io/tags/linux/"/>
    
    <category term="socket" scheme="https://brraida.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://brraida.github.io/posts/5d36ff15/"/>
    <id>https://brraida.github.io/posts/5d36ff15/</id>
    <published>2021-04-16T07:58:52.000Z</published>
    <updated>2021-09-02T05:47:42.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本常用语法"><a href="#Markdown基本常用语法" class="headerlink" title="Markdown基本常用语法"></a>Markdown基本常用语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ol><li>井号空格标题            <strong>一级标题</strong></li><li>井号井号空格标题    <strong>二级标题</strong></li><li>…以此类推，最多有六级标题</li></ol><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol><li>星号星号文字星号星号空格        <strong>加粗</strong></li><li>星号文字星号                               <em>斜体</em></li><li>星号星号星号文字星号星号星号 <em><strong>斜体加粗</strong></em></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    大于号空格</p><blockquote><p>螃蟹在剥我的壳</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>​    三个星号空格</p><hr><p><strong>or</strong></p><p>​    三个短线(0旁边)空格</p><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>​    叹号左中括号图片名(随便取)右中括号括号，在括号里填本地图片的绝对路径or网络图片的地址</p><p><code>![]()</code></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>​     左中括号信息右中括号括号，括号里面填地址</p><p>[SunMonkey](<a href="https://brraida.github.io/">SunMonkey - 熬夜是不可的 (brraida.github.io)</a>)</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有次序列表"><a href="#有次序列表" class="headerlink" title="有次序列表"></a>有次序列表</h3><p>1.空格</p><ol><li>hello</li><li>hi</li></ol><hr><h3 id="无次序列表"><a href="#无次序列表" class="headerlink" title="无次序列表"></a>无次序列表</h3><p> -空格</p><ul><li>hello</li><li>hi</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    建议右键插入，或是快捷键。用语法比较慢。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​    tab键上方的点，输入三次，输入要写的编程语言(c,c++,python…)。之后就是写代码了。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name&#x3D;lee</code></pre></div>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="Markdown" scheme="https://brraida.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
